 * Probleme d'une fissure en tension dans une plaque 
 *soumise a un deplacement udon*ey sur le bord superieur 
 opti dime 2 mode plan cont; 
 opti elem tri3; 
 *opti elem tri6; 
 * 
 * 2022: commande obsolete opti epsilon lineaire obsolete 
 * par defaut operateur epsi calcul la partie sym du grad du deplacement 
 *opti epsilon lineaire; 
 ************************************************************************ 
 *----------- DONNEES------------- 
 * Materiau 
 YOU=1.; 
 v=0.4; 
 * Chargement 
 udon= 1.; 
 * Geometrie (mm) 
 *a0= 20.; 
 *l0= 100.; 
 *h0=450./2.; 
   
 a0= 20./100.; 
 l0= 1.; 
 h0=4.5/2.; 
   
 *finesse 
 f0=1.; 
 f0=0.5; 
   
 de1=f0*0.01*a0; 
 de2=f0*0.5*a0; 
 de3=f0*a0; 
 *de1=0.005*a0; 
 *de2=0.5*a0; 
   
 dens de1; 
 p1=a0 0.; 
 dens de2; 
 p0=0. 0.; 
 p2=l0 0.; 
 dens de3; 
 p3=l0 h0; 
 p4=0. h0; 
   
 d01 = droit p0 p1 ; 
 d12 = droit p1 p2 ; 
 d23 = droit p2 p3 ; 
 d34 = droit p3 p4 ; 
 d40 = droit p4 p0 ; 
   
 cont = (d01 et d12 et d23 et d34 et d40); 
 trac cont; 
   
 sur = surf cont; 
 trac sur; 
   
 *********************************************************************** 
 *----------- DEFINITION DE MODELE ET DU MATERIAU------------- 
 * 
 MOD = MODE SUR MECANIQUE ELASTIQUE ISOTROPE ; 
 MAT = MATE MOD YOUNG YOU NU v; 
 *----------- DEFINITION DE CONDITIONS AUX LIMITES----------- 
 *conditions de symetrie 
 CL1 = BLOQ uy d12 ; 
 *deplact selon ey donne sur bord sup 
 CL2 = BLOQ UY d34 ; 
 CL3 = BLOQ UX d34 ; 
 CHA = DEPI CL2 (udon/2.); 
 CLT = CL1 ET CL2 et CL3 ; 
 *----------- DEFINITION DU CHARGEMENT -------------- 
   
 *----------- CALCUL DE LA SOLUTION ---------------- 
 * calcul de la matrice de rigidité 
 rig = rigi mod mat ; 
   
 * calcul du deplacement solution 
 uu = reso (rig et clt) cha ; 
   
 *********************************************************************** 
 *----------- POST-TRAITEMENT ---------------- 
 * Determination de la force imposee 
 r = REAC CL2 uu; 
 rtot = RESULT r; 
 list rtot; 
 R0 = EXTR rtot 'FY' p3; 
   
 mess 'a=' a0; 
 mess 'R0=' R0; 
 * trace de la deformee 
 titre 'deformee' ; 
 def0 = defo sur uu 0. bleu ; 
 def1 = defo sur uu  roug ; 
 trac (def0 et def1); 
 * contraintes 
 sig1 = sigma mod mat uu ; 
 trac sig1 mod; 
 *----CALCUL DU FACTEUR D'INTENSITE DE CONTRAINTES----; 
 *----APPEL DE LA PROCEDURE SIF  ---------------------; 
 * Determination de KI par interpolation sur champ de deplacement 
 SIFTAB = TABL; 
 SIFTAB.'MODMIXTE' = FAUX; 
 SIFTAB.'LEVRE_1' = d01; 
 SIFTAB.'FRTFISS' = p1; 
 SIF SIFTAB MAT UU; 
 * SIF       PROCEDUR  FD218221  18/03/20    21:15:06     9778 
 DEBPROC SIF SUPTAB*TABLE MAT*MCHAML U*CHPOINT; 
   
 ************************************************************************ 
 *                 PROCEDURE POUR LA DETERMINATION DE K                 * 
 *                   PAR LA METHODE DES DEPLACEMENTS                    * 
 ************************************************************************ 
 *                                                                      * 
 * SUPTAB.'MAILLAGE' : EN 3D SEULEMENT, MAILLAGE DE LA PIECE            * 
 *                                                                      * 
 * SUPTAB.'FRTFISS' : FRONT DE FISSURE                                  * 
 *                    - EN 2D : POINT SITUE EN POINTE DE FISSURE        * 
 *                    - EN 3D : MAILLAGE DE LA LIGNE FRONT DE FISSURE   * 
 *                                                                      * 
 * SUPTAB.'MODMIXTE' : BOOLEEN VALANT VRAI SI ON EST EN MODE MIXTE      * 
 *                                                                      * 
 * SUPTAB.'LEVRE_1' : MAILLAGE DES LEVRES DE LA FISSURE                 * 
 *                    - EN 2D : MAILLAGE D'UNE LIGNE                    * 
 *                    - EN 3D : MAILLAGE D'UNE SURFACE                  * 
 *                    - EN CAS DE MODE MIXTE, LEVRE SUPERIEURE          * 
 * SUPTAB.'LEVRE_2' : EN CAS DE MODE MIXTE SEULEMENT                    * 
 *                    MAILLAGE DE LA LEVRE INFERIEURE                   * 
 *                                                                      * 
 * SUPTAB.'DEBOUCH' : BOOLEEN VALANT VRAI SI LA FISSURE EST DEBOUCHANTE * 
 *                    ET FAUX SINON (EN 3D SEULEMENT)                   * 
 * SUPTAB.'PDEBOUCH' : EXISTE EN CAS DE FISSURE DEBOUCHANTE EN 3D       * 
 *       * EN CAS DE FISSURE SYMETRIQUE :POINT INTERSECTION ENTRE LA    * 
 *         LIGNE DEBOUCHANTE ET FRTFISS (TYPE POINT)                    * 
 *       * EN CAS DE FISSURE NON SYMETRIQUE : LES 2 POINTS INTERSECTION * 
 *         ENTRE LA LIGNE DEBOUCHANTE ET LE FRONT DE FISSURE            * 
 *         (TYPE MAILLAGE)                                              * 
 *                                                                      * 
 * SUPTAB.'EPAI' : CHPOINT OU REEL DES EPAISSEURS AUX NOEUDS (POUR LES  * 
 *                 ELEMENTS COQUES)                                     * 
 * SUPTAB.'MEMBRANE' : BOOLEEN VALANT VRAI SI LES K1 ET EVENTUELLEMENT  * 
 *                     K2 DOIVENT ETRE EVALUES A PARTIR DES DEFORMATIONS* 
 *                     MEMBRANAIRES (POUR LES ELEMENTS COQUES)          * 
 * SUPTAB.'FLEXION' : BOOLEEN VALANT VRAI SI LES K1 ET K2 DE FLEXION    * 
 *                    DOIVENT ETRE EVALUES (POUR LES ELEMENTS COQUES)   * 
 *                                                                      * 
 * SUPTAB.'GRANDS_DEPLACEMENTS' : BOOLEEN VALANT VRAI POUR UN CALCUL EN * 
 *                                GRANDS DEPLACEMENTS                   * 
 *                                                                      * 
 * MAT   : CHAMP DE MATERIAU                                            * 
 *                                                                      * 
 * U     : CHAMP DE DEPLACEMENT                                         * 
 ************************************************************************ 
   
 ************************************************************************ 
 *                         ARGUMENTS DE SORTIE                          * 
 *                             TABLE SUPTAB                             * 
 ************************************************************************ 
 *                                                                      * 
 *SUPTAB.'K1' :* EN 2D, CONTIENT LE REEL K1 : SUPTAB.K1 = K1            * 
 *             * EN 3D, CONTIENT UNE TABLE DE REELS QUI REPRESENTENT LES* 
 *               K1 A CHAQUE NOEUD DU FRONT DE FISSURE ; CETTE TABLE DE * 
 *               REELS A POUR INDICES DES OBJETS DE TYPE POINT :        * 
 *               EXEMPLE : SUPTAB.K1.P = K1 TROUVE AU NOEUD DU FRONT    * 
 *                         DONT LES COORDONNEES SONT CELLES DE P        * 
 *             * POUR LES COQUES, CONTIENT UNE TABLE DE 3 REELS :       * 
 *                       SUPTAB.K1.TOTAL : K1(flexion) + K1(membrane)   * 
 *                       SUPTAB.K1.MEMBRANE : K1(membrane)              * 
 *                       SUPTAB.K1.FLEXION : K1(flexion)                * 
 *                                                                      * 
 *SUPTAB.'K2' :* EN 2D, CONTIENT LE REEL K2  : SUPTAB.K2 = K2           * 
 *             * EN 3D, CONTIENT UNE TABLE DE REELS QUI REPRESENTENT LES* 
 *               KII A CHAQUE NOEUD DU FRONT DE FISSURE ;CETTE TABLE DE * 
 *               REELS A POUR INDICES DES OBJETS DE TYPE POINT :        * 
 *               EXEMPLE : SUPTAB.K2.P = K2 TROUVE AU NOEUD DU FRONT    * 
 *                         DONT LES COORDONNEES SONT CELLES DE P        * 
 *             * POUR LES COQUES, CONTIENT UNE TABLE DE 3 REELS :       * 
 *                       SUPTAB.K2.TOTAL : K2(flexion) + K2(membrane)   * 
 *                       SUPTAB.K2.MEMBRANE : K2(membrane)              * 
 *                       SUPTAB.K2.FLEXION : K2(flexion)                * 
 *                                                                      * 
 ************************************************************************ 
   
   
 ************************************************************************ 
 * ACQUISITION DES DONNEES D'ENTREE ET INITIALISATIONS 
 ************************************************************************ 
   
 * Options generales 
 &DIM = VALE 'DIME'; 
 &IMP = VALE 'IMPI'; 
 &ELEM = 'VALEUR' ELEM; 
 IELEM2 = (EGA &ELEM 'TRI3') 'OU' (EGA &ELEM 'QUA4'); 
 IELEM3 = (EGA &ELEM 'CUB8') 'OU' (EGA &ELEM 'PRI6'); 
 IEL2Q =  (EGA &ELEM 'TRI6') 'OU' (EGA &ELEM 'QUA8'); 
 IEL3Q =  (EGA &ELEM 'PR15') 'OU' (EGA &ELEM 'CU20'); 
 IELEMLIN = IELEM2 'OU' IELEM3; 
 ICOQ = (EGA &DIM 3) ET ((IELEM2) 'OU' (IEL2Q)); 
 IMASS = (EGA &DIM 3) ET ((IELEM3) 'OU' (IEL3Q)); 
   
 * Type de calcul 
 SI (EXISTE SUPTAB 'MODMIXTE'); 
   MODMIXT = SUPTAB.'MODMIXTE'; 
 SINON; 
   MODMIXT = FAUX; 
 FINSI; 
   
 * Pour le cas avec des coques 
 SI (EXISTE SUPTAB 'EPAI'); 
   CHEP = SUPTAB.'EPAI'; 
 FINSI; 
 SI (EXISTE SUPTAB 'MEMBRANE'); 
   MEMB = SUPTAB.'MEMBRANE'; 
 SINON; 
   MEMB = FAUX; 
 FINSI; 
 SI (EXISTE SUPTAB 'FLEXION'); 
   FLEX = SUPTAB.'FLEXION'; 
 SINON; 
   FLEX = FAUX; 
 FINSI; 
   
 * Cas fissure debouchante 
 SI (EXISTE SUPTAB 'DEBOUCH'); 
   DEBOUCH = SUPTAB.'DEBOUCH'; 
 SINON; 
   DEBOUCH = FAUX; 
 FINSI; 
 SI DEBOUCH; 
   SI (EGA (TYPE SUPTAB.'PDEBOUCH') 'POINT   '); 
     PDBOUCH1 = SUPTAB.'PDEBOUCH'; 
   SINON; 
     PDBOUCH1 = SUPTAB.'PDEBOUCH' POIN 1; 
     PDBOUCH2 = SUPTAB.'PDEBOUCH' POIN 2; 
   FINSI; 
 FINSI; 
   
 * Cas grands deplacements (on fait les calculs sur la configuration) 
 SI (EXISTE SUPTAB 'GRANDS_DEPLACEMENTS'); 
   IGDDEP = SUPTAB.'GRANDS_DEPLACEMENTS'; 
 SINON; 
   IGDDEP = FAUX; 
 FINSI; 
 SI IGDDEP; 
   CONF0 = FORM; 
   FORM U; 
 FINSI; 
   
 * Maillage 
 SI IMASS; 
   SI (EXISTE SUPTAB 'MAILLAGE'); 
     MAILLAGE = SUPTAB.'MAILLAGE'; 
   SINON; 
     ERRE 'Il manque la donnee du maillage !'; 
   FINSI; 
 FINSI; 
   
 * Front de fissure 
 SI (EXISTE SUPTAB 'FRTFISS'); 
   SI IMASS; 
     FRTFISS = SUPTAB.'FRTFISS'; 
   SINON; 
     PF = SUPTAB.'FRTFISS'; 
   FINSI; 
 SINON; 
   ERRE 'Il manque la donnee du front de fissure !'; 
 FINSI; 
   
 * Levres de la fissure 
 SI (EXISTE SUPTAB 'LEVRE_1'); 
   SI IMASS; 
     SURFIS1 = SUPTAB.'LEVRE_1'; 
   SINON; 
     LIFIS1 = SUPTAB.'LEVRE_1'; 
   FINSI; 
 SINON; 
   ERRE 'Il manque la donnee des levres de la fissure !'; 
 FINSI; 
 SI MODMIXT; 
   SI (EXISTE SUPTAB 'LEVRE_2'); 
     SI IMASS; 
       SURFIS2 = SUPTAB.'LEVRE_2'; 
     SINON; 
       LIFIS2 = SUPTAB.'LEVRE_2'; 
     FINSI; 
   SINON; 
     ERRE 'Il manque la donnee de la levre inferieure !'; 
   FINSI; 
 FINSI; 
   
 * En 3D, on recupere des points sur les levres de la fissure mais 
 * n'appartenant pas au front 
 SI IMASS; 
   PFRTFISS = CHAN 'POI1' FRTFISS; 
   PSURFIS1 = CHAN 'POI1' SURFIS1; 
   TEMP1 = DIFF PFRTFISS PSURFIS1; 
   PSF1 = TEMP1 POIN 1; 
   SI MODMIXT; 
     PSURFIS2 = CHAN 'POI1' SURFIS2; 
     TEMP1 = DIFF PFRTFISS PSURFIS2; 
     PSF2 = TEMP1 POIN 1; 
   FINSI; 
 FINSI; 
   
   
   
 ************************************************************************ 
 * EN 3D : RECUPERATION DES 
 *         - POINTS DU FRONT DE FISSURE --> TABLE TPF 
 *         - POINTS SUR LES LIGNES PERPENDICULAIRES AU FRONT DE FISSURE 
 *           SUR LESQUELLES SERONT EFFECTUES LES CALCULS 
 *                                     -- > TABLES TLIG1 ET TLIG2 
 ************************************************************************ 
   
 SI IMASS; 
   TMAIL = TABLE; 
   TRANCHE = TABLE; 
   P = NBNO FRTFISS; 
 * recuperation des points extremites du front de fissure 
   FRTFISS = ORDO FRTFISS; 
   PINIT = FRTFISS POIN 'INIT'; 
   PFINA = FRTFISS POIN 'FINAL'; 
 * determination du volume de travail MAILVOL : 
 *  3 couches d'elements autour de la ligne de front 
   MAILVOL = FRTFISS; 
   REPETER BVOL 3; 
     MAILVOL = MAILLAGE ELEM 'APPU' 'LARG' MAILVOL; 
   FIN BVOL; 
 * récupération de la surface initiale de MAILVOL --> SURINIT 
   SURINIT = PINIT; 
   REPETER BSURINIT 3; 
     VCUB = MAILLAGE ELEM 'APPU' 'LARG' SURINIT; 
     SCUB = ENVE VCUB; 
     SURINIT = SCUB ELEM 'APPU' 'LARG' SURINIT; 
   FIN BSURINIT; 
   POINTFIS = SURINIT POIN 'PLAN' PINIT PFINA PSF1 0.01; 
   ELEMSFIS = SURINIT ELEM APPU STRI POINTFIS; 
   SURINIT = SURINIT DIFF ELEMSFIS; 
   SURINIT1 = SURINIT; 
   SURINIT = PINIT; 
   REPETER BSURI 7; 
     SURINIT = SURINIT1 ELEM APPU LARG SURINIT; 
   FIN BSURI; 
 * récupération de la surface finale de MAILVOL --> SURFIN 
   SURFIN = PFINA; 
   REPETER BSURFIN 3; 
     VCUB = MAILLAGE ELEM APPU LARG SURFIN; 
     SCUB = ENVE VCUB; 
     SURFIN = SCUB ELEM APPU LARG SURFIN; 
   FIN BSURFIN; 
   POINTFIS = SURFIN POIN 'PLAN' PINIT PFINA PSF1 0.01; 
   ELEMSFIS = SURFIN ELEM APPU STRI POINTFIS; 
   SURFIN = SURFIN DIFF ELEMSFIS; 
   SURFIN1 = SURFIN; 
   SURFIN = PFINA; 
   REPETER BSURF 7; 
     SURFIN = SURFIN1 ELEM APPU LARG SURFIN; 
   FIN BSURF; 
   
 * récuperation des mailles et des plans orthogonaux à la fissure 
 * --> tables TMAIL et TRANCHE 
   TMAIL.1 = CHAN 'POI1' SURINIT; 
   TRANCHE.1 = MAILVOL ELEM 'APPU' 'LARG' SURINIT; 
   I = 0; 
   TRANCHET = TRANCHE.1; 
   SI ((NBEL FRTFISS) > 1 ); 
     REPETER BRECU ((NBEL FRTFISS ) - 1); 
       I = I + 1; 
 *     récuperation des tranches 
       TRANCHE.(I + 1) = DIFF (MAILVOL ELEM 'APPU' 'LARG' TRANCHET) 
                              TRANCHET; 
       TRANCHET = TRANCHET ET TRANCHE.(I + 1); 
 *     si elements lineaires 
       SI IELEMLIN; 
         TMAIL.(I + 1) = INTE (CHAN 'POI1' (TRANCHE.I)) 
                              (CHAN 'POI1' (TRANCHE.(I + 1))); 
       SINON; 
 *     si elements quadratiques, points sommets 
         TMAIL.((2 * I) + 1) = INTE (CHAN 'POI1' (TRANCHE.I)) 
                                    (CHAN 'POI1' (TRANCHE.(I + 1))); 
 *     puis noeuds milieux 
         TMAIL.(2 * I) = DIFF (CHAN 'POI1' (TRANCHE.I)) 
                            (TMAIL.((2 * I) - 1) ET TMAIL.((2 * I) + 1)); 
       FINSI; 
     FIN BRECU; 
   FINSI; 
   TMAIL.P = CHAN 'POI1' SURFIN; 
   SI (NON IELEMLIN); 
     TMAIL.(P - 1) = DIFF (CHAN 'POI1' TRANCHE.(NBEL FRTFISS)) 
                          (TMAIL.P ET TMAIL.(P - 2)); 
   FINSI; 
   
 * récupération des lignes supports de calcul et des points du front de 
 * fissure --> tables TLIG1, TLIG2 et TPF 
   TLIG1 = TABLE; 
   TPF = TABLE; 
   SI MODMIXT; 
     TLIG2 = TABLE; 
   FINSI; 
   I = 0; 
   REPETER BLIG P; 
     I = I + 1; 
 *   récupération des lignes 
     TLIG1.I = INTE TMAIL.I PSURFIS1; 
     SI MODMIXT; 
       TLIG2.I = INTE TMAIL.I PSURFIS2; 
     FINSI; 
 *   récupération des points du front de fissure 
     TPF.I = (INTE TLIG1.I PFRTFISS) POIN 1; 
   FIN BLIG; 
   
 FINSI; 
   
   
   
 * ATTENTION! Pas de prise en compte de delaminages en coques. * 
 *************************************************************** 
 **************   DIMENSION 2 ET 3            ****************** 
 *************************************************************** 
 SI (EGA &DIM 2); 
   P = 1; 
 FINSI; 
 SI ICOQ; 
   SI MEMB; 
     P = 1; 
   SINON; 
     P = 0; 
   FINSI; 
   SI FLEX; 
     P = P + 1; 
   FINSI; 
 FINSI; 
   
 TABK1 = TABLE; 
 TABK2 = TABLE; 
 J = 0; 
 REPETER BKTOTALE P; 
   J = J + 1; 
   SI IMASS; 
     PF = TPF.J; 
     LIFIS1 = TLIG1.J; 
     SI (EGA MODMIXT VRAI); 
       LIFIS2 = TLIG2.J; 
     FINSI; 
     MESS '********************************************************'; 
     MESS '* NOEUD 'J' DU FRONT DE FISSURE  DE COORDONNEES : *'; 
     MESS '* ('(COOR 1 PF) (COOR 2 PF) (COOR 3 PF)' )  *'; 
   SINON; 
     LIFIS1 = LIFIS1 CHAN POI1; 
     SI (EGA MODMIXT VRAI); 
       LIFIS2 = CHAN 'POI1' LIFIS2; 
     FINSI; 
   FINSI; 
   
 *-------DETERMINATION DES POINTS DE CALCUL DE LA LIGNE------* 
 *-------     DE FISSURE LIFIS1 (ET LIFIS2 EN MIXTE) : ------* 
 *-------3 PREMIERS NOEUDS DE LA LIGNE APRES PF--------------* 
 *-------       NOEUDS MILIEUX Y COMPRIS       --------------* 
   
   SI ((NON ICOQ) OU (EGA J 1)); 
     LIGP1 = LIFIS1; 
     LIGP1 = LIGP1 DIFF (LIGP1 ELEM 'APPU' 'LARG' PF); 
     PINT11 = LIGP1 POIN 'PROC' PF; 
     LIGP1 = LIGP1 DIFF (LIGP1 ELEM 'APPU' 'LARG' PINT11); 
     PINTER1 = LIGP1 POIN 'PROC' PINT11; 
     LIGP1 = LIGP1 DIFF (LIGP1 ELEM 'APPU' 'LARG' PINTER1); 
     PINT12 = LIGP1 POIN 'PROC' PINTER1; 
     LIGP1 = PINT11 ET PINTER1 ET PINT12; 
     N = NBNO LIGP1; 
     SI MODMIXT; 
       LIGP2 = LIFIS2; 
       LIGP2 = LIGP2 DIFF (LIGP2 ELEM 'APPU' 'LARG' PF); 
       PINT21 = LIGP2 POIN 'PROC' PF; 
       LIGP2 = LIGP2 DIFF (LIGP2 ELEM 'APPU' 'LARG' PINT21); 
       PINTER2 = LIGP2 POIN 'PROC' PINT21; 
       LIGP2 = LIGP2 DIFF (LIGP2 ELEM 'APPU' 'LARG' PINTER2); 
       PINT22 = LIGP2 POIN 'PROC' PINTER2; 
       LIGP2 = PINT21 ET PINTER2 ET PINT22; 
     FINSI; 
   
 *-----------CALCUL DU COEFFICIENT DE K -----------------------* 
 *--ON RECUPERE LE MODULE D'YOUNG ET COEFFICIENT DE POISSON----* 
 *--DU PREMIER POINT DE LA SERIE DONNEE -----------------------* 
   
     MAIL = EXTR MAT 'MAIL'; 
     P1 = PINT11; 
     PN = PINT12; 
     EL1 = MAIL ELEM 'APPU' 'LARG' P1; 
     MATEL1 = REDU MAT EL1; 
     YOUNG = EXTR MATEL1 'YOUN' 1 1 1; 
     NU = EXTR MATEL1 'NU' 1 1 1; 
   
 **----------cas où l'on est en 2 D------------** 
     TYPMOD = VALE 'MODE'; 
     SI ((EGA TYPMOD 'AXIS') OU (EGA TYPMOD 'PLANDEFO')); 
       YOUNGB = YOUNG / (1 -(NU**2)); 
     FINSI; 
     SI ((EGA TYPMOD 'PLANCONT') 'OU' (ICOQ)); 
       YOUNGB = YOUNG; 
     FINSI; 
   
 **----------cas où l'on est en 3 D -----------** 
     SI IMASS; 
 **----cas de fissure débouchante----** 
 ************************************** 
       SI DEBOUCH; 
         SI (EGA (TYPE SUPTAB.'PDEBOUCH') 'POINT   '); 
 **--cas de fissure symétrique--** 
           BOOLINIT = FAUX; 
           BOOLFIN = FAUX; 
           SI (EGA PINIT PDBOUCH1); 
             BOOLINIT = VRAI; 
           SINON; 
             BOOLFIN = VRAI; 
           FINSI; 
         SINON; 
 **--cas de fissure non symétrique--** 
           BOOLINIT = VRAI; 
           BOOLFIN = VRAI; 
         FINSI; 
 **--déterminations de young--** 
         BOOL1 = FAUX; 
         BOOL2 = FAUX; 
         SI ((EGA J 1) ET BOOLINIT); 
           BOOL1 = VRAI; 
         FINSI; 
         SI ((EGA J P) ET BOOLFIN); 
           BOOL2 = VRAI; 
         FINSI; 
 **--cas où l'on se trouve en partie débouchante : contraintes planes--** 
         SI (BOOL1 OU BOOL2); 
           YOUNGB = YOUNG; 
 **--cas où l'on se trouve en partie non débouchante : déf planes--** 
         SINON; 
           YOUNGB = YOUNG / (1 - (NU**2)); 
         FINSI; 
   
 **----cas de la fissure non débouchante : def planes----** 
 ********************************************************** 
       SINON; 
         YOUNGB = YOUNG / (1 - (NU**2)); 
       FINSI; 
     FINSI; 
   
 **----calcul du coef----** 
 ************************** 
     COEF = (YOUNGB / 4.) * ((PI * 2.) ** 0.5); 
 *    COEF = YOUNGB * .6266570687; 
   
   
 *-----PASSAGE DANS LE REPERE LOCAL DE FISSURE---------------* 
   
 * TRANSLATION DES CHPS DE DEPL : NOUVELLE ORIGINE PF 
 **--récupération des composantes du déplacement--** 
     SI ((EGA TYPMOD 'PLANDEFO') OU (EGA TYPMOD 'PLANCONT') 
                                 OU (EGA TYPMOD 'TRID')); 
       CHVX = EXCO U 'UX'; 
       CHVY = EXCO U 'UY'; 
     FINSI; 
     SI (EGA TYPMOD 'AXIS'); 
       CHVX = EXCO U 'UR'; 
       CHVY = EXCO U 'UZ'; 
     FINSI; 
     VXPF= EXTR CHVX 'SCAL' PF; 
     VYPF= EXTR CHVY 'SCAL' PF; 
     PMAIL = EXTR U 'MAIL'; 
     CHVXPF=MANU CHPO PMAIL 1 'SCAL' VXPF; 
     CHVYPF=MANU CHPO PMAIL 1 'SCAL' VYPF; 
     CHVX=CHVX - CHVXPF; 
     CHVY=CHVY - CHVYPF; 
     SI (EGA TYPMOD 'TRID'); 
       CHVZ = EXCO U 'UZ'; 
       VZPF= EXTR CHVZ 'SCAL' PF; 
       CHVZPF=MANU CHPO PMAIL 1 'SCAL' VZPF; 
       CHVZ=CHVZ - CHVZPF; 
     FINSI; 
     SI (ICOQ ET FLEX); 
       CHEP = CHEP/2.; 
       CHRX = EXCO U 'RX'; 
       CHRY = EXCO U 'RY'; 
       CHRZ = EXCO U 'RZ'; 
       RXPF= EXTR CHRX 'SCAL' PF; 
       RYPF= EXTR CHRY 'SCAL' PF; 
       RZPF= EXTR CHRZ 'SCAL' PF; 
       CHRXPF=MANU CHPO PMAIL 1 'SCAL' RXPF; 
       CHRYPF=MANU CHPO PMAIL 1 'SCAL' RYPF; 
       CHRZPF=MANU CHPO PMAIL 1 'SCAL' RZPF; 
       CHRX=CHRX - CHRXPF; 
       CHRY=CHRY - CHRYPF; 
       CHRZ=CHRZ - CHRZPF; 
     FINSI; 
   
 * ROTATION DES CHPS DE DEPL : DS REPERE DE LA FISSURE 
 **----cas du 2 D----** 
     SI (EGA &DIM 2); 
       VECU = P1 MOIN PN; 
       XU = VECU / (NORM VECU); 
       YV = XU PVECT; 
       X1 Y1 = COOR XU; 
       X2 Y2 = COOR YV; 
       CHU = (CHVX * X1) + (CHVY * Y1); 
       CHV = (CHVX * X2) + (CHVY * Y2); 
 **----cas du 3 D----** 
     SINON; 
 **--récupération du repère local :XU YV ZW--** 
       VECU = P1 MOIN PN; 
       XU = VECU / (NORM VECU); 
       SI IMASS; 
         SI ((NBEL FRTFISS) > 1); 
           FRTFI = FRTFISS DIFF (FRTFISS ELEM 'APPU' 'LARG' PF); 
           PPRO = FRTFI POIN 'PROC' PF; 
         SINON; 
           FRTFI = CHAN 'POI1' FRTFISS; 
           FRTFI = FRTFI DIFF (FRTFI ELEM 'APPU' 'LARG' PF); 
           PPRO = FRTFI POIN 'PROC' PF; 
         FINSI; 
         VECV = PPRO MOIN PF; 
       FINSI; 
       SI ICOQ; 
         ELPTE = MAIL ELEM 'APPU' 'LARG' PF; 
         ELPT1 = ELPTE ELEM 'APPU' 'LARG' P1; 
         ELPT = CHAN 'POI1' ELPT1; 
         P1PN = P1 ET PF; 
         PY = ELPT DIFF P1PN; 
         NPY = NBEL PY; 
         KK = 0; 
         REPETER BKPY NPY; 
           KK = KK + 1; 
           PYP = PY POIN KK; 
           VECX = PYP MOIN P1; 
           PSUVX = PSCAL XU VECX; 
           SI (PSUVX < 0); 
             VECW = XU PVEC VECX; 
           SINON; 
             VECW = VECX PVEC XU; 
           FINSI; 
           VECV =  VECW PVEC XU; 
           NVECV = NORM VECV; 
           SI (NVECV > 1.0E-6); 
             QUITTER BKPY; 
           FINSI; 
         FIN BKPY; 
       FINSI; 
       YV = VECV / (NORM VECV); 
       ZW = XU PVEC YV; 
       ZW = ZW / (NORM ZW); 
 **--calcul de la matrice de passage --** 
       X1 Y1 Z1 = COOR XU; 
       X2 Y2 Z2 = COOR YV; 
       X3 Y3 Z3 = COOR ZW; 
 **--calcul des déplacements dans le repère local--** 
 **--mode 1--** 
       SI IMASS; 
         CHV = (X3 * CHVX) + (Y3 * CHVY) + (Z3 * CHVZ); 
         CHU = (X1 * CHVX) + (Y1 * CHVY) + (Z1 * CHVZ); 
       FINSI; 
     FINSI; 
   FINSI; 
   
   SI ICOQ; 
     SI (EGA J 1); 
       SI (MEMB); 
         CHV = (X2 * CHVX) + (Y2 * CHVY) + (Z2 * CHVZ); 
         CHU = (X1 * CHVX) + (Y1 * CHVY) + (Z1 * CHVZ); 
         CHW = (X3 * CHVX) + (Y3 * CHVY) + (Z3 * CHVZ); 
       SINON; 
         CHU = (X2 * CHRX) + (Y2 * CHRY) + (Z2 * CHRZ); 
         CHU = CHEP*CHU; 
         CHV = (X1 * CHRX) + (Y1 * CHRY) + (Z1 * CHRZ); 
         CHV = CHEP*CHV; 
         CHV = (-1.)*CHV; 
       FINSI; 
     FINSI; 
     SI (EGA J 2); 
       CHU = (X2 * CHRX) + (Y2 * CHRY) + (Z2 * CHRZ); 
       CHU = CHEP*CHU; 
       CHV = (X1 * CHRX) + (Y1 * CHRY) + (Z1 * CHRZ); 
       CHV = CHEP*CHV; 
       CHV = (-1.)*CHV; 
     FINSI; 
   FINSI; 
   
 *------------ INITIALISATIONS PRELIMINAIRES --------------* 
   VECPF = MOIN PF PN; 
   K1MOY = 0.; 
   K2MOY = 0.; 
   LIGP = TABLE; 
   I = 0; 
   CPT = 0; 
   TR = TABLE; 
   TK1 = TABLE; 
   TK2 = TABLE; 
   
 *---DEFINITION DES CONVENTIONS POUR K2 
   SI MODMIXT; 
     ELPTE = MAIL ELEM 'APPU' 'LARG' PF; 
     ELPT1 = ELPTE ELEM 'APPU' 'LARG' P1; 
     ELPT = CHAN 'POI1' ELPT1; 
     P1PN = P1 ET PF; 
     PY = ELPT DIFF P1PN; 
     NPY = NBEL PY; 
     KK = 0; 
     REPETER BKPY1 NPY; 
       KK = KK + 1; 
       PYP = PY POIN KK; 
       VECX = PYP MOIN PF; 
       VCY = PSCA VECX YV; 
       SI ((ABS(VCY)) > 1.0E-6); 
         QUITTER BKPY1; 
       FINSI; 
     FIN BKPY1; 
     SI (VCY > 0.); 
       LIGP.1 = LIGP1; 
       LIGP.2 = LIGP2; 
     SINON; 
       MESS 'ATTENTION! Echange des lignes de fissure!'; 
       LIGP.1 = LIGP2; 
       LIGP.2 = LIGP1; 
     FINSI; 
     NB = 2; 
   SINON; 
     NB = 1; 
     LIGP.1 = LIGP1; 
   FINSI; 
   
 *-----------BOUCLE  DE CALCULS------------------------------* 
   REPETER BOUCLE NB; 
     CPT = CPT + 1; 
     CHPF = MANU 'CHPO' LIGP.CPT 1 'SCAL' (NORM VECPF); 
     SI (EGA &DIM 2); 
       CHX1 = ((((COOR 1 LIGP.CPT) - (COOR 1 PN))**2) + 
               (((COOR 2 LIGP.CPT) - (COOR 2 PN))**2))**0.5; 
     SINON; 
       CHX1 = ((((COOR 1 LIGP.CPT) - (COOR 1 PN))**2) + 
               (((COOR 2 LIGP.CPT) - (COOR 2 PN))**2) + 
               (((COOR 3 LIGP.CPT) - (COOR 3 PN))**2))**0.5; 
     FINSI; 
     CHX = ABS (CHX1 - CHPF); 
     CHV1 = REDU CHV LIGP.CPT; 
     CHU2 = REDU CHU LIGP.CPT; 
   
     SI MODMIXT; 
 *--------- METHODE DES MOINDRES CARRES : MODE 2 ---------* 
       CHY = CHU2**2; 
       CHXY = CHX * CHY; 
       CHX2 = CHX**2; 
       CHY2 = CHY**2; 
       SOMX = RESU CHX; SOMX = MAXI SOMX; 
       SOMY = RESU CHY; SOMY = MAXI SOMY; 
       SOMXY = RESU CHXY; SOMXY = MAXI SOMXY; 
       SOMX2 = RESU CHX2; SOMX2 = MAXI SOMX2; 
       SOMY2 = RESU CHY2; SOMY2 = MAXI SOMY2; 
       DET1 = (N * SOMX2) - (SOMX**2); 
       ANUM = (N * SOMXY) - (SOMX * SOMY); 
       VA2 = ANUM / DET1; 
       BNUM = (SOMY * SOMX2) - (SOMXY * SOMX); 
       VB2 = BNUM / DET1; 
       DET2 = (N * SOMY2) - (SOMY**2); 
       ANUM2 = (N * SOMXY) - (SOMX * SOMY); 
       A2 = ANUM2 / DET2; 
       R2 = VA2 * A2; 
       DELTA = -1 * (VB2 / VA2); 
       SI (EGA &IMP 1); 
         MESS 'moindres carrés mode 2 : R2 = 'R2; 
       FINSI; 
     FINSI; 
 *---------- METHODE DES MOINDRES CARRES : MODE 1-------- * 
     CHV2 = CHV1**2; 
     CHY = CHV2; 
     CHXY = CHX * CHY; 
     CHX2 = CHX**2; 
     CHY2 = CHY**2; 
     SOMX = RESU CHX; SOMX = MAXI SOMX; 
     SOMY = RESU CHY; SOMY = MAXI SOMY; 
     SOMXY = RESU CHXY; SOMXY = MAXI SOMXY; 
     SOMX2 = RESU CHX2; SOMX2 = MAXI SOMX2; 
     SOMY2 = RESU CHY2; SOMY2 = MAXI SOMY2; 
     DET1 = (N * SOMX2) - (SOMX**2); 
     ANUM = (N * SOMXY) - (SOMX * SOMY); 
     VA1 = ANUM / DET1; 
     BNUM = (SOMY * SOMX2) - (SOMXY * SOMX); 
     VB1 = BNUM / DET1; 
     DET2 = (N * SOMY2) - (SOMY**2); 
     ANUM2 = (N * SOMXY) - (SOMX * SOMY); 
     A2 = ANUM2 / DET2; 
     R1 = VA1 * A2; 
     BETA = -1. * (VB1 / VA1); 
     SI (EGA &IMP 1); 
       MESS 'moindres carrés mode 1 :R1 = 'R1; 
     FINSI; 
 *------ VALEUR DE K1 ET (OU) K2 EN CHAQUE POINT---------* 
     RF = NORM VECPF; 
     VF = EXTR (REDU CHV PF) 'SCAL' PF; 
     UF = EXTR (REDU CHU PF) 'SCAL' PF; 
     VNUM=PROG (N+1) * 0.; 
     V2TH=PROG (N+1) * 0.; 
     V2NUM=PROG (N+1) * 0.; 
     DISTR=PROG (N+1) * 0.; 
     REMP VNUM 1 VF; 
     REMP V2NUM 1 (VF**2); 
     REMP V2TH 1 VB1; 
     SI MODMIXT; 
       UNUM=PROG (N+1) * 0.; 
       U2TH=PROG (N+1) * 0.; 
       U2NUM=PROG (N+1) * 0.; 
       REMP UNUM 1 UF; 
       REMP U2NUM 1 (UF**2); 
       REMP U2TH 1 VB2; 
     FINSI; 
     ITR = 0; 
     REPETER BK1 N; 
       ITR = ITR + 1; 
       I = I + 1; 
       PTI = LIGP.CPT POIN ITR; 
       VECPI = MOIN PTI PN; 
       RI = NORM VECPI; 
       R = ABS (RI - RF); 
       TR.I = R; 
       VI = EXTR (REDU CHV PTI) 'SCAL' PTI; 
       RRR = R - BETA; 
 *      MESS '    R = 'R'  BETA = 'BETA'  R - BETA = 'RRR; 
       SGNR = 1.; 
       SI (< RRR 0.); 
         SGNR = -1.; 
       FINSI; 
       RRR = SGNR*RRR; 
       K1I = SGNR*(ABS((COEF / ((RRR)**0.5)) * VI)); 
       REMP DISTR (ITR+1)  R; 
       REMP V2NUM (ITR+1) (VI**2); 
       REMP VNUM (ITR+1) VI; 
       VI2TH=(VA1 * R) + VB1; 
       REMP V2TH (ITR+1) VI2TH; 
       TK1.I = K1I; 
       K1MOY = K1MOY + K1I; 
 *-----CAS DU MODE MIXTE ------* 
       SI MODMIXT; 
         UI = EXTR (REDU CHU PTI) 'SCAL' PTI; 
         RRR = R - DELTA; 
         SGNR = 1.; 
         SI (< RRR 0.); 
           SGNR = -1.; 
         FINSI; 
         RRR = SGNR*RRR; 
         SI (< UI 0.); 
           SI (EGA CPT 1); 
             SGNR = (-1.)*SGNR; 
           FINSI; 
         FINSI; 
         SI (> UI 0.); 
           SI (EGA CPT 2); 
             SGNR = (-1.)*SGNR; 
           FINSI; 
         FINSI; 
         K2I = SGNR*(ABS((COEF / ((RRR)**0.5)) * UI)); 
         REMP U2NUM (ITR+1) (UI**2); 
         REMP UNUM (ITR+1) UI; 
         UI2TH = (VA2 * R) + VB2; 
         REMP U2TH (ITR+1) UI2TH; 
         TK2.I = K2I; 
         K2MOY = K2MOY + K2I; 
       FINSI; 
 *-----------------------------* 
     FIN BK1; 
   
 ***----------------TRACES DE COURBES--------------------**** 
     SI (EGA &IMP 1); 
       TITR 'courbes V=g(r) et U=h(r)'; 
       C1NUM = EVOL 'MANU' 'ABS' DISTR 'ORD' VNUM; 
       TITR 'droites THEORIQUES ET NUMERIQUES V**2=f(r)'; 
       CNUM1 = EVOL 'MANU' 'ABS' DISTR 'ORD' V2NUM; 
       CTH1 = EVOL 'MANU' 'ABS' DISTR 'ORD' V2TH; 
       T=TABLE; 
       T1=TABLE; 
       T.1='MARQ ETOI '; 
       T.2='MARQ TRIA '; 
       T1.1='MARQ CARR '; 
       T.'TITRE'=TABLE; 
       T1.'TITRE'=TABLE; 
       T.'TITRE'. 1 = 'MOT' 'NUM_MODE1'; 
       T.'TITRE'. 2 = 'MOT' 'THEO_MODE1'; 
       T1.'TITRE'. 1 = 'MOT' 'V=g(r)'; 
       CTOT1 =  CNUM1 et CTH1; 
       SI MODMIXT; 
         CNUM2 = EVOL 'MANU' 'ABS' DISTR 'ORD' U2NUM; 
         CTH2 = EVOL 'MANU' 'ABS' DISTR 'ORD' U2TH; 
         C2NUM = EVOL 'MANU' 'ABS' DISTR 'ORD' UNUM; 
         T.3='MARQ CARR '; 
         T.4='MARQ LOSA '; 
         T.'TITRE'. 3 = MOT 'NUM_MODE2'; 
         T.'TITRE'. 4 = MOT 'THEO_MODE2'; 
         CTOT2 = CNUM2 ET CTH2; 
         DESS (CTOT1 ET CTOT2) 'LOGO' 'LEGE' T; 
         T1.2='MARQ ETOI '; 
         T1.'TITRE'. 2= 'MOT' 'U=h(r)'; 
         DESS (C1NUM ET C2NUM) 'LOGO' 'LEGE' T1; 
       SINON; 
         DESS CTOT1 'LOGO' 'LEGE' T; 
         DESS C1NUM 'LOGO' 'LEGE' T1; 
       FINSI; 
     FINSI; 
   FIN BOUCLE; 
   
   
   
 *---------------------VALEUR MOYENNE DE K------------------* 
   SI MODMIXT; 
     N = (2 * N); 
   FINSI; 
   K1MOY = K1MOY / N; 
   SI MODMIXT; 
     K2MOY = K2MOY / N; 
   FINSI; 
   
   
   
   
 *************************************************************** 
 *                           IMPRESSIONS                       * 
 *************************************************************** 
   
   
   MESS '********************************************'; 
   MESS '*   R   *  VALEUR DE K1  * (VALEUR DE K2)  *'; 
   MESS '********************************************'; 
   IPRES = 0; 
   REPETER BIMPRESS N; 
     IPRES = IPRES + 1; 
     TTR = TR.IPRES; 
     TTK1 = TK1.IPRES; 
     SI MODMIXT; 
       SI (EGA IPRES 1); 
         MESS 'LIGNE 1'; 
       FINSI; 
       SI (EGA IPRES 4); 
         MESS 'LIGNE 2'; 
       FINSI; 
       TTK2 = TK2.IPRES; 
       MESS TTR TTK1 TTK2; 
     SINON; 
       MESS TTR TTK1; 
     FINSI; 
   FIN BIMPRESS; 
   MESS 'VALEUR MOYENNE : K1MOY = 'K1MOY; 
   SI MODMIXT; 
     MESS 'VALEUR MOYENNE : K2MOY = 'K2MOY; 
   FINSI; 
   SI IMASS; 
     TABK1.PF = K1MOY; 
     SI MODMIXT; 
       TABK2.PF = K2MOY; 
     FINSI; 
   SINON; 
     SUPTAB.'K1' = K1MOY; 
     SI MODMIXT; 
       SUPTAB.'K2' = K2MOY; 
     FINSI; 
   FINSI; 
   
   SI ICOQ; 
     SI ((EGA J 1) ET MEMB); 
       TABK1.'MEMBRANE' = K1MOY; 
       SI MODMIXT; 
         TABK2.'MEMBRANE' = K2MOY; 
       FINSI; 
     SINON; 
       TABK1.'FLEXION' = K1MOY; 
       SI MODMIXT; 
         TABK2.'FLEXION' = K2MOY; 
       FINSI; 
     FINSI; 
   FINSI; 
   
 FIN BKTOTALE; 
   
   
   
   
 SI ICOQ; 
   TABK1.'TOTAL' = 0.; 
   SI MODMIXT; 
     TABK2.'TOTAL' = 0.; 
   FINSI; 
   SI MEMB; 
     TABK1.'TOTAL' = TABK1.'MEMBRANE'; 
     SI MODMIXT; 
       TABK2.'TOTAL' = TABK2.'MEMBRANE'; 
     FINSI; 
   FINSI; 
   SI FLEX; 
     TABK1.'TOTAL' = TABK1.'TOTAL' + TABK1.'FLEXION'; 
     SI MODMIXT; 
       TABK2.'TOTAL' = TABK2.'TOTAL' + TABK2.'FLEXION'; 
     FINSI; 
   FINSI; 
 FINSI; 
   
 SI (IMASS OU ICOQ); 
   SUPTAB.'K1'= TABK1; 
   SI MODMIXT; 
     SUPTAB.'K2'= TABK2; 
   FINSI; 
 FINSI; 
   
 SI IGDDEP; 
   FORM CONF0; 
 FINSI; 
   
 FINPROC SUPTAB; 
 K1INT = SIFTAB.K1; 
 *K2INT = SIFTAB.K2; 
 *----APPEL DE LA PROCEDURE G_THETA  ---------------------; 
 GTAB = TABL; 
 GTAB . 'OBJECTIF' = MOT 'J'; 
 GTAB . 'FRONT_FISSURE'  = p1 ; 
 GTAB . 'LEVRE_SUPERIEURE' = d01; 
 GTAB . 'COUCHE' = 6; 
 GTAB . 'SOLUTION_RESO'  = uu; 
 GTAB . 'CARACTERISTIQUES' = mat; 
 GTAB . 'MODELE' = mod; 
 GTAB . 'CHARGEMENTS_MECANIQUES' = cha ; 
 G_THETA GTAB; 
 * G_THETA   PROCEDUR  JB251061  22/08/09    21:15:02     11426 
 DEBPROC G_THETA SUPTAB*'TABLE'; 
 * ============================================================================= 
 *              PROCEDURE DE MISE EN OEUVRE DE LA METHODE G-THETA 
 *              ------------------------------------------------- 
 * 
 * DESCRIPTION : CETTE PROCEDURE PERMET DE CALCULER DES INTEGRALES DE MECANIQUE 
 *               DE LA RUPTURE. CES INTEGRALES SONT : 
 *                  1) LE TAUX DE RESTITUTION D'ENERGIE G (OU INTEGRALE DE 
 *                     CONTOUR J) EN ELASTO-PLASTICITE OU ELASTO-DYNAMIQUE; 
 *                  2) dJ/dA EN ELASTOPLASTICITE; 
 *                  3) C* POUR LE FLUAGE SECONDAIRE STATIONNAIRE; 
 *                  4) C*H POUR LE FLUAGE PRIMAIRE SOUS CHARGEMENT RADIAL. 
 * 
 *               IL EST EGALEMENT POSSIBLE DE CALCULER LES FACTEURS D'INTENSITE 
 *               DES CONTRAINTES (KI, KII, KIII) VIA L'OPTION 'DECOUPLAGE'. 
 * ============================================================================= 
   
 * INTRODUCTION DE VARIABLES UTILES 
 * -------------------------------- 
   
 * CREATION DE LA TABLE DE BOOLEENS 
 * ******************************** 
   
 BOOL = TABL; 
 BOOL.'TRAC' = FAUX; 
 BOOL.'MESS' = VRAI; 
 SI BOOL.'MESS'; 
     SAUT 'LIGNE'; 
     MESS '------------------' 'DEBUT DE LA PROCEDURE G_THETA' 
     '--------------------'; 
 FINSI; 
   
 * CONFIGURATION INITIALE 
 * ********************** 
   
 CONFIG0 = FORM; 
   
   
 * ============================================================================= 
   
 * DETERMINATION DU CAS DEMANDE ET VERIFICATION DES DONNEES OBLIGATOIRES 
 * --------------------------------------------------------------------- 
   
 * APPEL A G_CAS 
 * ************* 
   
 OBJUTI = G_CAS SUPTAB BOOL; 
 SI (EGA (TYPE OBJUTI) (MOT 'ANNULE')); 
     MESS 'ERREUR : IL Y A EU UN PROBLEME INATTENDU PENDANT LA LECTURE DES'; 
     MESS '         DONNEES'; 
     QUIT G_THETA; 
 FINSI; 
 NMESS = OBJUTI.'NMESS'; 
   
   
 * LECTURE DES DONNEES FOURNIES 
 * **************************** 
   
 GDIME = OBJUTI.'DIMENSION'; 
 GMODE = OBJUTI.'MODE'; 
 MOD_MEC = OBJUTI.'MOD_MEC'; 
 MAT_MEC = OBJUTI.'MAT_MEC'; 
 SI BOOL.'PASAPAS'; 
     WTAB = OBJUTI.'WTAB'; 
 FINSI; 
 MAILLAGE = OBJUTI.'MAILLAGE'; 
 M_FRONT = OBJUTI.'FRONT'; 
   
   
 * QUELQUES DONNEES NON ISSUES DE G_CAS 
 * ************************************ 
   
 * TYPE D'ELEMENTS DU MAILLAGE 
 LELEM1 = MAILLAGE ELEM 'TYPE'; 
   
 * VERIFICATIONS DANS LE CAS DE PERSO1 
 SI BOOL.'PERSO1'; 
     SI BOOL.'MESS'; 
         MESS 'utilisation de PERSO1 en cours de dvlpt'; 
     FINSI; 
     SI (EXIS SUPTAB.'SOLUTION_PASAPAS' 'ESTIMATION'); 
         ESTIM = SUPTAB.'SOLUTION_PASAPAS'.'ESTIMATION'; 
     SINON; 
         MESS 'ERREUR : il faut une ESTIMATION dans la SOLUTION_PASAPAS'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     SI (NON (EXIS SUPTAB 'MAILLAGE_REDUIT')); 
         MESS 'Attention! utilisation de PERSO1 sans MAILLAGE_REDUIT'; 
         MESS 'uniquement valable dans le cas de fissure stationnaire'; 
     FINSI; 
 FINSI; 
   
   
 * MOTS DE COMPOSANTES UTILES 
 * ************************** 
   
 * LISTMOT SCAL : 
 MTS1 = MOTS 'SCAL'; 
 * LISTMOTS POUR LE DEPLACEMENT ET POUR LA FORCE : 
 * ON EXTRAIT LES GDIME PREMIERS MOTS CAR ON NE VEUT PAS DES ROTATIONS 
 * DANS LE CAS DES COQUES 
 MUI = EXTR (EXTR MOD_MEC 'DEPL') (LECT 1 PAS 1 GDIME); 
 MFI = EXTR (EXTR MOD_MEC 'FORC') (LECT 1 PAS 1 GDIME); 
 MU1 = EXTR MUI 1 ; MU2 = EXTR MUI 2; 
 MF1 = EXTR MFI 1 ; MF2 = EXTR MFI 2; 
 SI (EGA GDIME 3); 
     MF3 = EXTR MFI 3; 
 FINSI; 
   
   
 * CREATION DE CHAR1 SI PASAPAS 
 * **************************** 
   
 SI BOOL.'PASAPAS'; 
     CHAR1 = SUPTAB.'SOLUTION_PASAPAS'.'CHARGEMENT'; 
 FINSI; 
   
   
 * DONNEES EN CAS DE CONTACT 
 * ************************* 
   
 SI ((NON BOOL.'PASAPAS') ET BOOL.'FROT'); 
     OBJCON = SUPTAB.'MODELE_FISSURE'; 
     MAICON = EXTR OBJCON 'MAILLAGE'; 
 FINSI; 
   
   
 * ============================================================================= 
   
 * EXTRACTION DU MAILLAGE, DU CHAMP THETA ET DE LA DIRECTION DE PROPAGATION 
 * ------------------------------------------------------------------------ 
   
 * MODELE MULTICOUCHES DANS LE CAS DE COQUE 
 * **************************************** 
   
 SI BOOL.'COQ'; 
     M_DETA = EXTR MOD_MEC 'ZONE'; 
     SI (EXIS SUPTAB 'ELEMENT_MULTICOUCHE'); 
         ELMULT = SUPTAB.'ELEMENT_MULTICOUCHE'; 
         SI (NEG (TYPE ELMULT) 'MAILLAGE'); 
             MESS 'ERREUR : L ELEMENT EN MULTICOUCHE DOIT'; 
             MESS '         ETRE UN OBJET DE TYPE MAILLAGE'; 
             ERRE 21 ; QUIT G_THETA; 
         FINSI; 
         SI (NEG (NBEL ELMULT) 1); 
             MESS 'ERREUR : ON VEUT UN SEUL ELEMENT EN MULTICOUCHE'; 
             ERRE 21 ; QUIT G_THETA; 
         FINSI; 
     SINON; 
         MESS 'ERREUR : IL FAUT DESIGNER UN ELEMENT EN MULTICOUCHE'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     M_ELMU = EXTR (REDU MOD_MEC ELMULT) 'ZONE'; 
     SI ((DIME M_ELMU) '<' 10); 
         MESS 'ERREUR : IL FAUT AU MOINS 3 COUCHES (peau inf, peau'; 
         MESS '         sup, ligne moyenne) D EPAISSEUR INFERIEURE'; 
         MESS '         A 1E-4*(EPAISSEUR TOTALE) + 2 COUCHES'; 
         MESS '         INTERMEDIAIRES POUR L ELEMENT DESIGNE EN'; 
         MESS '         MULTICOUCHE PROCHE DE LA FISSURE.'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     PEX1 = PROG ; LMO1 = LECT ; MODCOU = TABLE ; EPAITO = 0.; 
     REPE NBJ5 ((DIME M_ELMU)/2); 
         I1 = (2 * &NBJ5) - 1; 
         MODCOU.&NBJ5 = M_ELMU.I1; 
         EX1 = EXTR (REDU MODCOU.&NBJ5 MAT_MEC) 'EXCE' 1 1 1; 
         EP1 = EXTR (REDU MODCOU.&NBJ5 MAT_MEC) 'EPAI' 1 1 1; 
         EPAITO = EPAITO + EP1; 
         PEX1 = PEX1 ET (PROG EX1); 
         LMO1 = LMO1 ET (LECT &NBJ5); 
     FIN NBJ5; 
     NSUPE = 0 ; NMOYE = 0 ; NINFE = 0; 
     REPE NBJ6 (DIME MODCOU); 
         EX1 = EXTR PEX1 &NBJ6; 
         LM1 = EXTR LMO1 &NBJ6; 
         SI (EGA EX1 (EPAITO/2.) 1.E-4); 
             NSUPE = LM1; 
         FINSI; 
         SI (EGA EX1 0. 1.E-10); 
             NMOYE = LM1; 
         FINSI; 
         SI (EGA EX1 (EPAITO/(-2.)) 1.E-4); 
             NINFE = LM1; 
         FINSI; 
     FIN NBJ6; 
     SI (EGA NSUPE 0); 
         MESS 'ERREUR : IL FAUT UNE COUCHE EN PEAU SUPERIEURE'; 
         MESS '         D EPAISSEUR INFERIEURE A'; 
         MESS '         1E-4*(EPAISSEUR TOTALE) '; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     SI (EGA NMOYE 0); 
         MESS 'ERREUR : IL FAUT UNE COUCHE AU PLAN MEDIAN'; 
         MESS '         AYANT UN EXCENTREMENT NUL'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     SI (EGA NINFE 0); 
         MESS 'ERREUR : IL FAUT UNE COUCHE EN PEAU INFERIEURE'; 
         MESS '         D EPAISSEUR INFERIEURE A'; 
         MESS '         1E-4*(EPAISSEUR TOTALE) '; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     SUPTAB.'EPAISSEUR' = EPAITO; 
     M_SUPE = MODCOU.NSUPE; 
     M_MOYE = MODCOU.NMOYE; 
     M_INFE = MODCOU.NINFE; 
 FINSI; 
   
   
 * MAILLAGE UTILISE DANS LA RESOLUTION PAR E.F. 
 * ******************************************** 
   
 SI BOOL.'COQ'; 
     TMULT = TABL; 
     REPE NBJ8 ((DIME M_DETA)/2); 
         M1 = M_DETA.(2*&NBJ8); 
         SI (EXIS TMULT M1); 
             ITER NBJ8; 
         FINSI; 
         M2 = EXTR (REDU MOD_MEC M1) 'ZONE'; 
         SI (> (DIME M2) 2); 
             TMULT.M1 = VRAI; 
             REPE NBJ9 (((DIME M2)/2) - 1); 
                 MAILLAGE = DIFF MAILLAGE M1; 
             FIN NBJ9; 
         FINSI; 
     FIN NBJ8; 
 FINSI; 
 SUPTAB.'MAILLAGE' = MAILLAGE; 
   
   
 * DETERMINATION DES CHAMPS THETA ET PI ET DE LA ZONE DE TRAVAIL ELTETA 
 * ******************************************************************** 
   
 SI (EXIS SUPTAB 'TAB_THETA'); 
     OTER SUPTAB 'TAB_THETA'; 
 FINSI; 
 SI (EXIS SUPTAB 'TAB_PI'); 
     OTER SUPTAB 'TAB_PI'; 
 FINSI; 
 SI (EXIS SUPTAB 'COUCHE'); 
     MESS 'CHAMP_THETA NON FOURNI PAR L''UTILISATEUR'; 
     SI (EXIS SUPTAB 'CHAMP_THETA'); 
 * CHAMP_THETA ET COUCHE SONT TOUS DEUX FOURNIS, ON ECRASE CHAMP_THETA 
         MESS 'Nombre de couches donne => on ne tient pas compte du champ fourni'/3; 
         OTER SUPTAB 'CHAMP_THETA'; 
     FINSI; 
 SINON; 
     MESS 'CHAMP_THETA FOURNI PAR L UTILISATEUR'; 
 FINSI; 
 SI BOOL.'XFEM'; 
 * ON APPELLE CH_TETX POUR CALCULER CHAMP_THETA 
     CH_THETX SUPTAB OBJUTI BOOL; 
 SINON; 
 * ON APPELLE CH_TETA POUR CALCULER CHAMP_THETA 
     CH_THETA SUPTAB OBJUTI BOOL; 
 FINSI; 
   
 * DETERMINATION DE ELTETA 
 * ELTETA1 = MAILLAGE OU TETA N EST PAS NUL + 1 COUCHE 
 CHTHETA = SUPTAB.'CHAMP_THETA'; 
 SI (NEG (TYPE CHTHETA) 'CHPOINT'); 
     CHTHETA = CHTHETA.'GLOBAL'; 
 FINSI; 
 * UU = EXTR CHTHETA 'MAILLAGE'; 
 NTHETA = (PSCA CHTHETA CHTHETA MUI MUI)**0.5; 
 ELTETA1 = MAILLAGE ELEM 'APPU' 'LARG' (NTHETA POIN 'SUPERIEUR' 0.); 
 SI (NON BOOL.'XFEM'); 
     ELTETA1 = MAILLAGE ELEM 'APPU' 'LARG' ELTETA1; 
 FINSI; 
 SI (EXIS SUPTAB 'MAILLAGE_REDUIT'); 
 *    ELTETA = MAILLAGE FOURNI PAR L UTILISATEUR 
     ELTETA = SUPTAB.'MAILLAGE_REDUIT'; 
 *    VERIFICATION DE LA COMPATIBILITE AVEC CHTHETA 
     SI ((NBEL (DIFF ELTETA ELTETA1)) NEG 0); 
         MESS 'ATTENTION : LE MAILLAGE_REDUIT DONNE EST INCOMPATIBLE AVEC LE'; 
         MESS '            CHAMP THETA, IL SERA DONC IGNORE.'; 
         ELTETA = ELTETA1; 
     FINSI; 
 SINON; 
     ELTETA = ELTETA1; 
 FINSI; 
 SI BOOL.'TRAC'; 
     VCHTHETA = VECT CHTHETA 'DEPL' 'BLEU'; 
     TRAC VCHTHETA (MAILLAGE ET M_FRONT) 'TITR' 'CHAMP_THETA'; 
 FINSI; 
 * ON STOCKE LES DIRECTIONS DANS UTILTET1 POUR PROPAGATION EN XFEM 
 * DIRECTION DE PROPAGATION : DIR1 
 * DIRECTION TANGENTE AU FRONT : DIR2 
 * DIRECTION DE CISAILLEMENT SI SEPARATION DE MODES : DIR3 
 SUPTAB.'UTILTET1' = TABL; 
 REPE I 3; 
     MDIR = CHAI 'DIRECTION' &I; 
     SI (EXIS OBJUTI MDIR); 
         SUPTAB.'UTILTET1'.MDIR = OBJUTI.MDIR; 
     FINSI; 
 FIN I; 
   
   
 * ON COMPLETE ELTETA 
 * ****************** 
   
 * AJOUT EVENTUEL DE ELPI A ELTETA 
  SI ((EXIS SUPTAB 'FRONT_FISSURE_2') ET BOOL.'DJ/DA'); 
     ELPI = SUPTAB.'FRONT_FISSURE_2'; 
     REPE MAIL2 ((SUPTAB.'COUCHE') + 1); 
         ELPI = MAILLAGE ELEM 'APPU' 'LARG' ELPI; 
     FIN MAIL2; 
     ELTETA = ELTETA ET ELPI; 
  FINSI; 
   
 * AJOUT DU NOEUD SUPPORT EN DEF.PL.GENERALISEES 
 SI (EGA GMODE 'PLANGENE'); 
     ELTETA = ELTETA ET (VALE 'MODE' 'PLANGENE'); 
 FINSI; 
 ELPOI1 = CHAN ELTETA 'POI1'; 
   
 * L'ELEMENT SUPPORTANT LE MODELE MULTICOUCHE 
 * DOIT ETRE DANS LA ZONE THETA 
 SI BOOL.'COQ'; 
     N1 = NBNO ELTETA; 
     N2 = NBNO (ELTETA ET (EXTR M_MOYE 'MAIL')); 
     SI (NEG N1 N2); 
         MESS 'ERREUR : L ELEMENT EN MULTICOUCHE DESIGNE POUR CALCULER'; 
         MESS '         L INTEGRALE SE TROUVE EN DEHORS DE LA ZONE'; 
         MESS '         DEFINIE PAR LE NOMBRE DE COUCHES DONNE.'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
 FINSI; 
   
 * ELTETA SERA PRATIQUE POUR LES TESTS DE REPRISE 
 OBJUTI.'ELTETA' = ELTETA; 
 SUPTAB.'ELTET1' = ELTETA; 
   
   
 * TESTS DE COMPATIBILITE 
 * ********************** 
   
 * BOOL.'REPRI' = VRAI SI REPRISE DE CALCUL, FAUX SINON 
 BOOL.'REPRI' = FAUX; 
 SI (BOOL.'PASAPAS' ET (NON BOOL.'PERSO1')); 
     N1 = DIME (SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'); 
     SI ((EXIS SUPTAB 'IABC') ET 
         (EXIS SUPTAB 'ELTET1') ET 
         (EXIS SUPTAB 'RESULTATS') ET 
         (EXIS SUPTAB 'EVOLUTION_RESULTATS')); 
         BOOL.'REPRI' = (N1 - 1) > SUPTAB.'IABC'; 
         MESS 'on tente une reprise...'; 
     FINSI; 
 FINSI; 
   
 * TESTS DE COMPATIBILITE SI REPRISE DE CALCUL 
 SI BOOL.'REPRI'; 
 *     ON VERIFIE QUE L OBJECTIF RESTE LE MEME 
     SI (NEG SUPTAB.'OBJ1' SUPTAB.'OBJECTIF'); 
         MESS 'ERREUR : REPRISE IMPOSSIBLE CAR L OBJECTIF DU'; 
         MESS '         CALCUL ACTUEL N EST PAS LE MEME QUE'; 
         MESS '         CELUI DU CALCUL PRECEDENT'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
 *     ON DOIT AVOIR LE MEME NOMBRE DE COUCHE (ON SUPPOSE LA FISSURE FIXE) 
     SI ((EXIS SUPTAB 'COUCHE') ET (EXIS SUPTAB 'COU1')); 
         SI (NEG SUPTAB.'COU1' SUPTAB.'COUCHE'); 
             MESS 'ERREUR : REPRISE IMPOSSIBLE CAR LE NOMBRE DE'; 
             MESS '         COUCHE ACTUEL N EST PAS LE MEME QUE'; 
             MESS '         CELUI UTILISE POUR LE CALCUL PRECEDENT'; 
             ERRE 21 ; QUIT G_THETA; 
         FINSI; 
     FINSI; 
 *    RESTE A VERIFIER LA COMPATIBILITE DES SUPPORT DE CHAMP TETA VIA ELTETA 
 *    ELTETA DOIT ETRE INCLUS DANS ELTET1 
     ELTET1 = SUPTAB.'ELTET1'; 
     SI(NEG (NBNO ELTETA) (NBNO (ELTET1 INTE ELTETA))); 
         MESS 'ERREUR : REPRISE IMPOSSIBLE CAR LE SUPPORT DU '; 
         MESS '         CHAMP_THETA FOURNI N EST PAS INCLUS DANS'; 
         MESS '         CELUI UTILISE POUR LE CALCUL PRECEDENT'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     MESS 'REPRISE DU CALCUL AUTORISE !'; 
 FINSI; 
   
 * TESTS DE COMPATIBILITE SI UTILISATION DE PERSO1 
 SI (BOOL.'PERSO1' ET (EXIS SUPTAB 'ELTET1')); 
     ELTET1 = SUPTAB.'ELTET1'; 
     SI(NEG (NBNO ELTETA) (NBNO (ELTET1 INTE ELTETA))); 
         MESS 'ERREUR : REPRISE IMPOSSIBLE CAR LE SUPPORT DU '; 
         MESS '         CHAMP_THETA FOURNI N EST PAS INCLUS DANS'; 
         MESS '         CELUI UTILISE POUR LE CALCUL PRECEDENT'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     SI BOOL.'MESS'; 
         MESS 'POURSUITE DU CALCUL VIA PERSO1 AUTORISE !'; 
     FINSI; 
 FINSI; 
   
   
 * ============================================================================= 
   
 * MODELES ET MATERIAUX DANS LA ZONE DE TRAVAIL 
 * -------------------------------------------- 
   
 * VERIFICATION DES DONNEES D ENTREE POUR MODELES_COMPOSITES 
 SI (EXIS SUPTAB 'MODELES_COMPOSITES'); 
     N1 = DIME SUPTAB.'MODELES_COMPOSITES'; 
     M1 = EXTR MOD_MEC 'MAIL'; 
     M2 = VIDE 'MAILLAGE'; 
     REPE BIN4 N1; 
         T1 = TYPE SUPTAB.'MODELES_COMPOSITES'.&BIN4; 
         SI (NEG T1 'MMODEL  '); 
             MESS 'ERREUR : LE TYPE DE L OBJET No' &BIN4 'DANS LA'; 
             MESS '         TABLE MODELES_COMPOSITES EST INCORRECTE'; 
             ERRE 21 ; QUIT G_THETA; 
         FINSI; 
         M2 = M2 ET (EXTR SUPTAB.'MODELES_COMPOSITES'.&BIN4 'MAIL'); 
     FIN BIN4; 
     SI (NEG (NBNO M1) (NBNO M2)); 
         MESS 'ERREUR : TOUS LES MODELES DE MATERIAUX'; 
         MESS '         COMPOSITES NE SONT PAS DONNES'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
 FINSI; 
   
 * CREATION DE MOD_MEC ET TABMOD 
 TABMOD = TABL; 
 SI (EXIS SUPTAB 'MODELES_COMPOSITES'); 
 *     CAS DE MODELES COMPOSITES (AVEC DISCONTINUITE) : ON A DU TRAVAIL 
     MOD_MEC_R = VIDE 'MMODEL'; 
     REPE BIN1 (DIME SUPTAB.'MODELES_COMPOSITES'); 
         M1 = SUPTAB.'MODELES_COMPOSITES'.&BIN1; 
         M2 = EXTR M1 'MAIL'; 
         N1 = NBNO M2; 
         N2 = NBNO ELTETA; 
         N3 = NBNO (ELTETA ET M2); 
 *        SI ON A DES NOEUDS EN COMMUN, ... 
         SI (NEG (N1 + N2) N3); 
             M2 = CHAN M2 'POI1'; 
 *            ... ON LES RECUPERE 
             E1 = (DIFF ELPOI1 M2) DIFF (ELPOI1 ET M2); 
             N1 = NBNO (CONT ELTETA); 
             N2 = NBNO (E1 ET (CONT ELTETA)); 
 *            SI TOUS LES NOEUDS EN COMMUN SONT SUR LE CONTOUR 
 *            => PAS D ELEMENTS A RECUPERER => ON PASSE AU MODELE SUIVANT 
             SI (EGA N1 N2); 
                 ITER BIN1; 
             FINSI; 
 *            SINON, ON RECUPERE LES ELEMENTS CONCERNES ET LE MODELE REDUIT 
             E1 = MAILLAGE ELEM 'APPU' 'STRI' E1; 
             N1 = (DIME TABMOD) + 1; 
             TABMOD.N1 = REDU M1 E1; 
             MOD_MEC_R = MOD_MEC_R ET TABMOD.N1; 
         FINSI; 
     FIN BIN1; 
 SINON; 
 *     CAS DE MODELES SANS DISCONTINUITE : ON A MOINS DE TRAVAIL 
     MOD_MEC_R = REDU MOD_MEC ELTETA; 
     TABMOD.1 = MOD_MEC_R; 
 FINSI; 
 NBOBJ = DIME TABMOD; 
 MAT_MEC = REDU MAT_MEC MOD_MEC_R; 
   
 * CHAMP EPAISSEUR DANS LA ZONE DE TRAVAIL 
 SI BOOL.'COQ'; 
     EPAICH = (CHAN (EXCO MAT_MEC 'EPAI' 'SCAL') 
                 'STRESSES' MOD_MEC_R) CHAN 'TYPE' 'SCALAIRE'; 
 FINSI; 
   
   
 * CALCUL DE C* PAR DEUX TYPES DE MODELE FLUAGE 
 * ******************************************** 
 *** ITYPEF = 1  MODELE FLUAGE POUR LEQUEL ON A UNE EXPRESSION 
 ***             EXPLICITE DE L'INTEGRATION DE LA VITESSE DE 
 ***             DEFORMATION DE FLUAGE SUR LE TEMPS 
 *** ITYPEF = 2  MODELE FLUAGE POUR LEQUEL ON N'OBTIENT PAS 
 ***             FACILEMENT CETTE EXPRESSION EXPLICITE 
 *** ITYPEF = 99 SI EN ELASTO OU THERMO-ELASTO-PLASTICITE 
   
 * DETERMINATION DE ITYPEF 
 ITYPEF = 99; 
 SI (BOOL.'C*' OU BOOL.'C*H'); 
     SI ((EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'NORTON') OU 
         (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'POLYNOMIAL')); 
         ITYPEF = 1; 
     FINSI; 
     SI ((EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'BLACKBURN') OU 
         (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'RCCMR_316') OU 
         (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'RCCMR_304') OU 
         (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'LEMAITRE')); 
         ITYPEF = 2; 
     FINSI; 
 FINSI; 
   
   
 * INTERFACES DANS LA ZONE DE TRAVAIL 
 * ********************************** 
   
 * CREATION DES INTERFACES INTER-MODELE 
 BOOL.'PARAL' = VRAI ; LINTER = TABL; 
 SI ((EXIS SUPTAB 'MODELES_COMPOSITES') ET ((DIME TABMOD) > 1)); 
 *     ON BOUCLE SUR LES MODELES QUI APPARTIENNENT A ELTETA 
     REPE BIN2 ((DIME TABMOD) - 1); 
         M1 = EXTR (TABMOD.&BIN2) 'MAIL'; 
         IIN3 = &BIN2; 
         NIN3 = (DIME TABMOD) - &BIN2; 
         REPE BIN3 NIN3; 
             IIN3 = IIN3 + 1; 
             LE1 = LECT &BIN2 IIN3; 
             M2 = EXTR (TABMOD . IIN3) 'MAIL'; 
 *            ON ITERE SI (M1 INCLUT DANS M2) OU (M2 INCLUT DANS M1) 
             SI (EGA (NBNO (M1 DIFF M2)) 0); 
                 ITER BIN3; 
             FINSI; 
 *            ON ITERE SI M1 ET M2 N ONT PAS DE NOEUDS COMMUNS 
             SI (EGA ((NBNO M1) + (NBNO M2)) (NBNO (M1 ET M2))); 
                 ITER BIN3; 
             FINSI; 
 *            ON RECUPERE L INTERFACE M1-M2 
             L1 = (CONT M1) ELEM 'APPU' (CONT M2); 
             N1 = NBNO M1 ; N2 = NBNO M2; 
 *            LO1=VRAI <=> IL EXISTE DES NOEUDS COMMUNS A M1 ET M2 
             LO1 = NEG (N1 + N2) (NBNO (M1 ET M2)); 
 *            LO2=VRAI <=> IL N'Y A PAS 1 NOEUD COMMUN A M1 ET M2 
             LO2 = NEG ('ABS' ((N1 + N2) - (NBNO (M1 ET M2)))) 1; 
 *            LO4 = M1 ET M2 FORMENT BIEN UNE INTERFACE ET NE SE CHEVAUCHENT PAS 
             LO4 = NEG (NBEL L1) 0; 
             SI (LO1 ET LO2 ET LO4); 
 *                ON AJOUTE L INTERFACE CAR ON A >1 NOEUDS EN COMMUN A M1 ET M2 
                 LINTER.LE1 = L1; 
 *                BOOL.'PARAL'=VRAI <=> TOUTES LES INTERFACES SONT // A LA FISSURE 
 *                SI BOOL.'PARAL'=FAUX IL FAUT AJOUTER DES TERMES D INTERFACES AU C 
                 P1 = (POIN L1 1) MOIN (POIN L1 2); 
                 P1 = P1 / (NORM P1); 
 *                 PETITE MODIF CAR DIR1 DOIT ETRE UN CHPOINT DESORMAIS 
 *                -> A VERIFIER ? 
                 PDIR1 = RESU OBJUTI.'DIRECTION1'; 
                 PRESU = (EXTR PDIR1 'MAIL') POIN 1; 
                 XDIR1 = EXTR PDIR1 PRESU 'UX'; 
                 YDIR1 = EXTR PDIR1 PRESU 'UY'; 
                 SI (GDIME EGA 2); 
                     PDIR1 = XDIR1 YDIR1; 
                 SINON; 
                     ZDIR1 = EXTR PDIR1 PRESU 'UZ'; 
                     PDIR1 = XDIR1 YDIR1 ZDIR1; 
                 FINSI; 
                 PDIR1 = PDIR1 / (NORM PDIR1); 
                 LO1 = ('<EG' ('DIST' P1 PDIR1      ) 1.E-6) 'OU' 
                       ('<EG' ('DIST' P1 (-1.*PDIR1)) 1.E-6); 
                 BOOL.'PARAL' = BOOL.'PARAL' ET LO1; 
             FINSI; 
         FIN BIN3; 
     FIN BIN2; 
 FINSI; 
   
 * DANS LE CAS DECOUPLAGE SEULEMENT : 
 * TEST SI FRONT_FISSURE EST DANS UNE INTERFACE 
 BOOL.'DANS' = FAUX; 
 SI ((NEG (DIME LINTER) 0) ET BOOL.'DECOUPLAGE'); 
     IND1 = INDE LINTER; 
     REPE BIN4 (DIME IND1); 
         LE1 = IND1.&BIN4; 
         M1 = CHAN LINTER.LE1 'POI1'; 
         N1 = NBNO M1; 
         N2 = NBNO (M1 ET SUPTAB.'FRONT_FISSURE'); 
         SI (EGA N1 N2); 
             BOOL.'DANS' = VRAI; 
             QUIT BIN4; 
         SINON; 
             ITER BIN4; 
         FINSI; 
     FIN BIN4; 
 FINSI; 
 * SI OUI (BOOL.'DANS'),ON DETERMINE LES MODELES SUP ET INF 
 MODINF = 0 ;  MODSUP = 0; 
 SI BOOL.'DANS'; 
 *    ON REDEFINIT : BOOL.'PARAL'=VRAI <=> L'INTERFACE A LAQUELLE APPARTIENT LA FISSURE E 
     BOOL.'PARAL' = FAUX; 
     M1 = EXTR TABMOD.(EXTR LE1 1) 'MAIL'; 
     M2 = EXTR TABMOD.(EXTR LE1 2) 'MAIL'; 
     LSUP = SUPTAB.'LEVRE_SUPERIEURE'; 
     LINF = SUPTAB.'LEVRE_INFERIEURE'; 
     N1 = NBNO M1; 
     N2 = NBNO M2; 
     NLSUP = NBNO LSUP; 
     NLINF = NBNO LINF; 
     N1SUP = NBNO (M1 ET LSUP); 
     N2INF = NBNO (M2 ET LINF); 
     SI ( ((N1 + NLSUP - N1SUP) > 1) ET ((N2 + NLINF - N2INF) > 1)); 
 *        LSUP ET MOD1 ONT PLUS D'1 POINT COMMUN  ET  IDEM POUR LINF ET MOD2 
         MODSUP = TABMOD.(EXTR LE1 1); 
         MODINF = TABMOD.(EXTR LE1 2); 
     SINON; 
         N1INF = NBNO (M1 ET LINF); 
         N2SUP = NBNO (M2 ET LSUP); 
         SI ( ((N1 + NLINF - N1INF) > 1) ET ((N2 + NLSUP - N2SUP) > 1)); 
             MODSUP = TABMOD.(EXTR LE1 2); 
             MODINF = TABMOD.(EXTR LE1 1); 
         SINON; 
             MESS 'ERREUR : INCOMPATIBILITE ENTRE LE MODELES_COMPOSITES'; 
             MESS '         ET LES LEVRE_SUPERIEURE ET _INFERIEURE'; 
             ERRE 21 ; QUIT G_THETA; 
         FINSI; 
     FINSI; 
 *    LA FISSURE EST BIEN DANS LE PROLONGEMENT DE L' INTERFACE 
     BOOL.'PARAL' = VRAI; 
 FINSI; 
 * REM: il faudrait egalement verifier que MODSUP et MODINF suffisent a decrire E 
   
   
 * MODPLA : table indicee par entier pour stocker les modeles 
 *          mecaniques de chaque objet MMODEL. 
 ************************************************** 
 *** Elle est vide si le modele est elastique ou elastoplastique 
 *** avec une courbe de traction independante de la temperature. 
 *** Dans le cas contraire la table vaut : 
 ***    1 si le modele est plastique isotrope. Alors une 
 ***      nouvelle courbe de traction EPSE-SIGMA est faite. 
 ***    2 si le modele est plastique cinematique 
 ***    3 si le modele est plastique parfaite 
   
 BOOL.'GRADYOUN' = FAUX ; BOOL.'GRADNU' = FAUX; 
 BOOL.'GRADALPH' = FAUX ; MODPLA = TABLE ; TABTRA = TABLE; 
   
 REPE BCMOD1 NBOBJ; 
     MODEI = TABMOD.&BCMOD1; 
     MATEI = REDU MAT_MEC MODEI; 
   
 * ON DETERMINE SI ON A DES GRADIENTS DE PROPRIETES (THERMO-)ELASTIQUES 
     MPROP = MOTS 'YOUN' 'NU'; 
     SI BOOL.'THER'; 
         MPROP = MPROP ET 'ALPH'; 
     FINSI; 
     REPE IPROP (DIME MPROP); 
         MCOMP = EXTR MPROP &IPROP; 
         MGRAD = CHAI 'GRAD' MCOMP; 
         PRO1 = EXCO MATEI MCOMP; 
         TYP1 = TYPE (EXTR PRO1 MCOMP 1 1 1); 
         SI (EGA TYP1 'EVOLUTIO'); 
             BOOL.MGRAD = VRAI; 
         SINON; 
             DPRO1 = (MAXI PRO1) - (MINI PRO1); 
             CRI1 = (MAXI PRO1 'ABS') * 1.E-10; 
             SI (DPRO1 > CRI1); 
                 BOOL.MGRAD = VRAI; 
             FINSI; 
         FINSI; 
     FIN IPROP; 
   
 *     COURBE DE TRACTION 
     SI (EXIS MATEI 'ECRO'); 
         TR1 = EXCO MATEI 'ECRO'; 
         TYPTR = TYPE (EXTR TR1 'ECRO' 1 1 1); 
         SI (EGA TYPTR 'NUAGE   '); 
             MODPLA.&BCMOD1 = 1; 
             TRA1 = EXTR TR1 'ECRO' 1 1 1 ; COM1 = EXTR TRA1 'COMP'; 
             NOMEVO1 = MOT 'ECRO' ; NOMFLO1 = MOT 'T'; 
             REPE BNUA1 (DIME TRA1 'UPLE'); 
                 SI (EGA &BNUA1 1); 
                     NUA1 = EXTR TRA1 'MINI' NOMFLO1; 
                 SINON; 
                     NUA1 = EXTR TRA1 'SUPE' NOMFLO1 (T1 + 1.E-10); 
                 FINSI; 
                 T1 =  EXTR NUA1 NOMFLO1; 
                 EV1 = EXTR NUA1 NOMEVO1; 
                 PSIG1 = EXTR EV1 ORDO ; PEPS1 = EXTR EV1 'ABSC'; 
                 VYOU1 = (EXTR 2 PSIG1) / (EXTR 2 PEPS1); 
                 PEPS2 = PROG; 
                 REPE BSIG1 ((DIME PSIG1) - 1); 
                     VA1 = (EXTR (&BSIG1 + 1) PEPS1) - 
                     ((EXTR (&BSIG1 + 1) PSIG1) / VYOU1); 
                     PEPS2 = PEPS2 ET (PROG VA1); 
                 FIN BSIG1; 
                 EV1 = EVOL 'MANU' 'EPSE' PEPS2 SIGM ('ENLE' PSIG1 1); 
                 SI (&BNUA1 EGA 1); 
                     TRA2 = 'NUAG' 'COMP' NOMFLO1 T1 'COMP' NOMEVO1 EV1; 
                 SINON; 
                     TRA2 = TRA2 ET ('NUAG' 'COMP' NOMFLO1 
                     T1 'COMP' NOMEVO1 EV1); 
                 FINSI; 
             FIN BNUA1; 
             TABTRA.&BCMOD1 = TRA2; 
 *             ON ENLEVE LA COURBE DE TRACTION SI ELLE DEPEND DE 
 *             LA TEMPERATURE (OPERATION TROP COUTEUSE POUR VARI) 
             MAT0 = MATEI ; LCOMP1 = EXTR MAT0 'COMP'; 
             REPE BCOM1 (DIME LCOMP1); 
                 C1 = EXTR LCOMP1 &BCOM1; 
                 SI (NEG C1 'ECRO'); 
                     SI (EGA &BCOM1 1); 
                         MATEI = 'MATE' MODEI C1 (EXCO C1 MAT0); 
                     SINON; 
                         MATEI = MATEI ET ('MATE' MODEI C1 (EXCO C1 MAT0)); 
                     FINSI; 
                 FINSI; 
             FIN BCOM1; 
         FINSI; 
 *     SIGY (et pas TRAC) 
     SINON; 
         SI (EXIS MATEI 'SIGY'); 
             SI1 = EXCO MATEI 'SIGY'; 
             TYPSI = TYPE (EXTR SI1 'SIGY' 1 1 1); 
             SI (EXIS MATEI 'H'); 
                 H1 = EXCO MATEI 'H'; 
                 TYPH = TYPE (EXTR H1 'H' 1 1 1); 
                 SI ((EGA TYPH 'EVOLUTIO') OU 
                     (EGA TYPSI 'EVOLUTIO')); 
                     MODPLA.&BCMOD1 = 2; 
                 FINSI; 
             SINON; 
                 SI (EGA TYPSI 'EVOLUTIO'); 
                     MODPLA.&BCMOD1 = 3; 
                 FINSI; 
             FINSI; 
         FINSI; 
     FINSI; 
 FIN BCMOD1; 
 BOOL.'GRADPROP' = BOOL.'GRADYOUN' OU BOOL.'GRADNU' OU BOOL.'GRADALPH'  OU ((DIME MODPLA) '>' 0); 
   
   
 * METHODE DE CALCUL DES CHAMPS AUXILIAIRES SI DECOUPLAGE (VOIR G_AUX) 
 * ******************************************************************* 
   
 SI BOOL.'DECOUPLAGE'; 
     SI (BOOL.'DANS' ET (NEG GDIME 2)); 
         MESS 'ERREUR : CAS BI-MATERIAU TRAITABLE UNIQUEMENT EN 2D'; 
         ERRE 21; 
     FINSI; 
     SI (NON (EXIS SUPTAB 'METH_AUX')); 
         MESS; 
         MESS 'L''indice METH_AUX n''est pas fourni => choix par defaut' 
               /NMESS; 
         SI BOOL.'DANS'; 
 * PAR DEFAUT ON UTILISE LA METHODE U-ANALYTIQUE DANS LE CAS BI-MATERIAU 2D 
             SUPTAB.'METH_AUX' = 'UANA'; 
         SINON; 
 * PAR DEFAUT ON UTILISE LA METHODE G-ANALYTIQUE DANS LE CAS MONO-MATERIAU 
             SUPTAB.'METH_AUX' = 'GANA'; 
         FINSI; 
     SINON; 
         SI (BOOL.'DANS' ET (NEG SUPTAB.'METH_AUX' 'UANA')); 
 * ON UTILISE TOUJOURS LA METHODE U-ANALYTIQUE POUR UN BI-MATERIAU 
             SUPTAB.'METH_AUX' = 'UANA'; 
             MESS 'ATTENTION : SEULE LA METHODE UANA EST UTILISABLE POUR'; 
             MESS '            LE CAS D''UN BI-MATERIAU => ON L''UTILISE'; 
         FINSI; 
         SAUT 'LIGNE'; 
     FINSI; 
 * VERIFICATION QUE LA METHODE EST UTILISABLE 
     METH_AUX = SUPTAB.'METH_AUX'; 
     SI ((NEG METH_AUX 'GANA') ET (NEG METH_AUX 'UANA') 
             ET (NEG METH_AUX 'MECA')); 
         MESS 'ERREUR : ON NE CONNAIT PAS LA METHODE DEMANDEE POUR CALCULER'; 
         MESS '         LES CHAMPS AUXILIAIRES'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     SI (EGA METH_AUX 'GANA'); 
         SI (NON BOOL.'XFEM'); 
             VERR = VALE 'ERRE'; 
             OPTI 'ERRE' 'IGNO'; 
             GEO2 = VERS SUPTAB.'LEVRE_SUPERIEURE'; 
             GEO2 = VERS SUPTAB.'LEVRE_INFERIEURE'; 
 * INSTRUCTION BIDON CAR SINON LA DETECTION D'ERREUR NE SE PASSE PAS BIEN... 
             VAR = VRAI; 
             OPTI 'ERRE' VERR; 
             SI (EGA (TYPE GEO2) (MOT 'ANNULE')); 
                 MESS 'ERREUR : LES LEVRES NE SONT PAS ORIENTEES CORRECTEMENT'; 
                 ERRE 21 ; QUIT G_THETA; 
             FINSI; 
         FINSI; 
     FINSI; 
     SI ((EGA METH_AUX 'MECA') ET (BOOL.'XFEM' OU (EGA GDIME 2))); 
         MESS 'ERREUR : ON NE PEUT UTILISER LA METHODE MECANIQUE QUE DANS LE'; 
         MESS '         CAS 3D AVEC DES ELEMENTS STANDARDS'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
     SI ((EGA METH_AUX 'UANA') ET (EGA GDIME 3)); 
         MESS 'ERREUR : ON NE PEUT UTILISER LA METHODE U-ANALYTIQUE'; 
         MESS '         QUE DANS LE CAS 2D'; 
         ERRE 21 ; QUIT G_THETA; 
     FINSI; 
 FINSI; 
   
   
 * CAS IMPOSSIBLE A TRAITER 
 * ************************ 
   
 SI (EXIS SUPTAB 'MODELES_COMPOSITES'); 
     SI (BOOL.'DECOUPLAGE' ET BOOL.'DANS'); 
         SI (NON BOOL.'PARAL'); 
             MESS 'ERREUR : ON NE PEUT PAS ENCORE DECOUPLER LES MODES'; 
             MESS '         EN PRESENCE D''UNE DISCONTINUITE MATERIELLE'; 
             MESS '         SI LA FISSURE N APPARTIENT PAS A L INTERFACE'; 
             ERRE 21 ; QUIT G_THETA; 
         FINSI; 
         SI (EGA GDIME 3); 
             MESS 'ERREUR : ON NE PEUT PAS ENCORE DECOUPLER LES MODES'; 
             MESS '         EN PRESENCE D''UNE DISCONTINUITE MATERIELLE'; 
             MESS '         DANS LE CAS 3D.'; 
             ERRE 21 ; QUIT G_THETA; 
         FINSI; 
     FINSI; 
 FINSI; 
   
   
   
 * ============================================================================= 
   
 * PREREQUIS POUR EFFECTUER LES CALCULS 
 * ------------------------------------ 
   
 * NOMBRE DE BOUCLE POUR LE CALCUL DES INTEGRALES 
 * ********************************************** 
   
 SI BOOL.'PASAPAS'; 
     NBG = -1; 
     NBDEP = DIME (SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'); 
     SI BOOL.'REPRI'; 
         NBG = SUPTAB.'IABC'; 
         NBDEP = NBDEP - 1 - NBG; 
     FINSI; 
     SI BOOL.'PERSO1'; 
         NBG = (WTAB . 'PAS') - 1; 
         NBDEP = 1; 
     FINSI; 
 SINON; 
     NBG = -1; 
     NBDEP = 1; 
 FINSI; 
   
   
 * SOLUTION DU PAS PRECEDENT SI REPRISE DE CALCUL OU SI PERSO1 
 * *********************************************************** 
   
 SI (BOOL.'REPRI' OU (BOOL.'PERSO1' ET (NBG >EG 0))); 
     SIG1 = (SUPTAB.'SOLUTION_PASAPAS'.'CONTRAINTES'.NBG) REDU MOD_MEC_R; 
     SI (EXIS (SUPTAB.'SOLUTION_PASAPAS') 'VARIABLES_INTERNES'); 
         VAR1 = (SUPTAB.'SOLUTION_PASAPAS'.'VARIABLES_INTERNES'.NBG) 
                 REDU MOD_MEC_R; 
     SINON; 
         VAR1 = ZERO MOD_MEC_R 'VARINTER' ;; 
     FINSI; 
     MAT_INST = SUPTAB.'MAT_INST'; 
     WELAS = 0.5*('ENER' MOD_MEC_R SIG1 ('ELAS' MOD_MEC_R SIG1 MAT_INST)); 
     WPLAS = (REDU MOD_MEC_R SUPTAB.'END1') - WELAS; 
     SI (EGA ITYPEF 2); 
         VDI1 = SUPTAB.'VDI1'; 
     FINSI; 
     SI (((DIME MODPLA) > 0) ET BOOL.'THER'); 
         WVMIS = SUPTAB.'ENV1'; 
     FINSI; 
     SI BOOL.'MESS'; 
         MESS 'RECUP DU PAS PRECEDENT OK'; 
     FINSI; 
 FINSI; 
   
 * CALCUL DE LA DEFORMATION THERMIQUE A TREF 
 SI (BOOL.'THER' ET (NON BOOL.'COQ')); 
     SI (EXIS MAT_MEC 'TREF'); 
         TREF = REDU (EXCO 'TREF' MAT_MEC 'T') ELTETA; 
         TREF = CHAN 'TYPE' TREF 'TEMPERATURES'; 
     SINON; 
         TREF = MANU 'CHML' MOD_MEC_R 'T' 0. 'TYPE' 'TEMPERATURES'; 
     FINSI; 
     MATREF = VARI 'NUAG' MOD_MEC_R MAT_MEC TREF; 
     EPTREF = EPTH MOD_MEC_R MATREF TREF; 
     EPTREF VAR2 VAR3 = INVA MOD_MEC_R EPTREF; 
     EPTREF = CHAN 'CHAM' (EPTREF/3.) MOD_MEC_R 'NOEUD'; 
     OBJUTI.'EPTREF' = EPTREF; 
 FINSI; 
   
   
 * REMPLISSAGE DE OBJUTI 
 * ********************* 
   
 OBJUTI.'MOD_MEC_R' = MOD_MEC_R; 
 OBJUTI.'MODCOU' = MODCOU; 
 OBJUTI.'TABMOD' = TABMOD; 
 OBJUTI.'LINTER' = LINTER; 
 OBJUTI.'MODPLA' = MODPLA; 
 OBJUTI.'ITYPEF' = ITYPEF; 
 OBJUTI.'NBG' = NBG; 
 * DECOUPLAGE 
 OBJUTI.'MODSUP' = MODSUP; 
 OBJUTI.'MODINF' = MODINF; 
 * AJOUT BP BT POUR LE CONTACT FROTTANT 
 SI BOOL.'FROT'; 
     OBJUTI.'OBJCON' = OBJCON; 
     OBJUTI.'MAILCON' = MAILCON; 
 FINSI; 
 * FIN AJOUT BP BT 
 SI BOOL.'PERSO1'; 
     OBJUTI.'ESTIMATION' = ESTIM; 
 FINSI; 
   
 *************************************************** 
 ** DECLARATION DES TABLES STOCKANT LES RESULTATS ** 
 *************************************************** 
 SI BOOL.'PERSO1'; 
     FLCREA = NBG EGA -1; 
 SINON; 
     FLCREA = NON BOOL.'REPRI'; 
 FINSI; 
 SI FLCREA; 
     SI ((EGA GDIME 3) OU BOOL.'PASAPAS' OU BOOL.'DECOUPLAGE'); 
         SUPTAB.'RESULTATS' = TABL; 
     FINSI; 
     SI BOOL.'PASAPAS'; 
         SI (EGA GDIME 3); 
             SUPTAB.'EVOLUTION_RESULTATS' = TABL; 
         FINSI; 
         SI (EGA ITYPEF 99); 
             SUPTAB.'CRIT_DECHA_GLOBAL1' = TABLE; 
             SUPTAB.'CRIT_DECHA_LOCAL1' = TABLE; 
             SUPTAB.'CRIT_DECHA_GLOBAL2' = TABLE; 
             SUPTAB.'CRIT_DECHA_GLOBAL2_L' = TABLE; 
             SUPTAB.'CRIT_DECHA_LOCAL2' = TABLE; 
         FINSI; 
     FINSI; 
     SI (BOOL.'COQ' ET (BOOL.'PASAPAS' OU BOOL.'DECOUPLAGE')); 
         SUPTAB.'EPAISSEUR_RESULTATS' = TABL; 
     FINSI; 
     SI BOOL.'DECOUPLAGE'; 
         REPE IRUPT GDIME; 
             MODE_RUPT = EXTR 'III' 1 &IRUPT; 
             SI ((EGA GDIME 3) OU BOOL.'PASAPAS'); 
                 SUPTAB.'RESULTATS'.MODE_RUPT = TABL; 
             FINSI; 
             SI (BOOL.'COQ' ET BOOL.'PASAPAS'); 
                 SUPTAB.'EPAISSEUR_RESULTATS'.MODE_RUPT = TABL; 
             FINSI; 
         FIN IRUPT; 
     FINSI; 
 FINSI; 
 * DECLARATION DES TABLES POUR CHPO_RESULTATS ET CHAM_RESULTATS 
 SI (NON (EXIS SUPTAB 'CHPO_RESULTATS')); 
     SI BOOL.'PASAPAS'; 
         SUPTAB.'CHPO_RESULTATS' = TABL; 
     SINON; 
         SUPTAB.'CHPO_RESULTATS' = VIDE 'CHPOINT'/'DISCRET'; 
     FINSI; 
 FINSI; 
 SI (NON (EXIS SUPTAB 'CHAM_RESULTATS')); 
     SI BOOL.'PASAPAS'; 
         SUPTAB.'CHAM_RESULTATS' = TABL; 
     SINON; 
         SUPTAB.'CHAM_RESULTATS' = VIDE 'MCHAML'; 
     FINSI; 
 FINSI; 
   
   
 * ============================================================================= 
   
 * APPEL A G_AUX SI DECOUPLAGE 
 * -------------------------- 
   
 SI BOOL.'DECOUPLAGE'; 
     OBJUTI.'MAT_INST' = MAT_MEC; 
     CH_AUX = G_AUX SUPTAB OBJUTI BOOL; 
     SI (EGA (TYPE CH_AUX) (MOT 'ANNULE')); 
         MESS 'ERREUR : G_AUX A RENCONTRE UN PROBLEME'; 
         QUIT G_CALCUL; 
     FINSI; 
     SUPTAB.'CH_AUX' = CH_AUX; 
 FINSI; 
   
 * APPEL A G_CALCUL POUR EFFECTUER LES CALCULS ET ENREGISTRER LES RESULTATS 
 * ------------------------------------------------------------------------ 
   
 G_CALCUL SUPTAB OBJUTI BOOL; 
   
 * MESSAGE DE FIN DE LA PROCEDURE 
 SI BOOL.'MESS'; 
     SAUT 'LIGNE'; 
     MESS '-------------------' 'FIN DE LA PROCEDURE G_THETA' 
     '---------------------'; 
     SAUT 'LIGNE'; 
 FINSI; 
   
 FINPROC; 
 * G_CAS     PROCEDUR  JB251061  22/08/09    21:15:02     11426 
 * ============================================================================= 
 *       PROCEDURE D'ANALYSE DE LA TABLE D'ENTREE FOURNIE A G_THETA 
 *       ---------------------------------------------------------- 
 * 
 * DESCRIPTION : DETERMINE SI LE CALCUL DEMANDE EST PREVU PAR LA VERSION 
 *               ACTUELLE DE G_THETA, ET PREVIENT L'UTILISATEUR SI LE CAS 
 *               ENVISAGE N'EST PAS TESTE OU VALIDE PAR LA BASE DE CAS TESTS 
 *               ACTUELLE. 
 *               ON EN PROFITE EGALEMENT POUR CREER CERTAINS OBJETS QUI SERONT 
 *               UTILISES PAR G_THETA. 
 * ============================================================================= 
 DEBP G_CAS SUPTAB*'TABLE' BOOL*'TABLE'; 
   
 * I - DETERMINATION DU CAS DEMANDE ET VERIFICATION DES DONNEES OBLIGATOIRES 
 * ------------------------------------------------------------------------- 
   
 MESS; 
 NMESS = 2; 
 NDEC = NMESS + 20; 
   
 * I.1 - LECTURE DES DONNEES FOURNIES A SUPTAB 
 * ******************************************* 
   
 * I.1.A - OBJECTIF 
 SI (NON (EXIS SUPTAB 'OBJECTIF')); 
     MESS 'ERREUR : IL FAUT SPECIFIER L INTEGRALE'; 
     MESS '      A CALCULER PAR UN MOT'; 
     ERRE 21 ; QUIT G_CAS; 
 SINON; 
     SI (NEG (TYPE SUPTAB.'OBJECTIF') 'MOT'); 
         MESS 'ERREUR : OBJECTIF INCORRECT. ON ATTEND UN ''MOT''.'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     GOBJ = MOT SUPTAB.'OBJECTIF'; 
 FINSI; 
 * MESSAGE 
 MESS 'OBJECTIF :'/NMESS (MOT GOBJ)/NDEC; 
   
 * I.1.B - DIMENSION ET MODE DE CALCUL 
 GDIME = VALE 'DIME'; 
 GMODE = VALE 'MODE'; 
 * MESSAGE 
 MESSDIME = CHAI 'DIMENSION :'/NMESS GDIME/NDEC; 
 MESS MESSDIME; 
 MESSMODE = CHAI 'MODE :'/NMESS GMODE/NDEC; 
 MESS MESSMODE; 
   
 * I.1.C - TYPE DE SOLUTION DONNEE 
 SI (NON ((EXIS SUPTAB 'SOLUTION_RESO') OU (EXIS SUPTAB 'SOLUTION_PASAPAS'))); 
     MESS 'ERREUR : IL FAUT UNE SOLUTION PROVENANT DE PASAPAS'; 
     MESS '       OU DE RESO POUR DETERMINER L''INTEGRALE'; 
     ERRE 21 ; QUIT G_CAS; 
 SINON; 
     SI (EXIS SUPTAB 'SOLUTION_RESO'); 
         SI (NEG (TYPE SUPTAB.'SOLUTION_RESO') 'CHPOINT'); 
             MESS 'ERREUR : SOLUTION_RESO INCORRECTE.' 
             MESS '       ON ATTEND UN ''CHPOINT''.'; 
             ERRE 21 ; QUIT G_CAS; 
         FINSI; 
         GSOLU = 'LINEAIRE'; 
     SINON; 
         GSOLU = MOT 'PASAPAS'; 
     FINSI; 
 FINSI; 
   
 * I.1.D - MODELE MECANIQUE, MATERIAU ET HYPOTHESE DE CALCUL 
 SI (EGA GSOLU 'LINEAIRE'); 
     SI (NON (EXIS SUPTAB 'MODELE')); 
         MESS 'ERREUR : UNE SOLUTION ISSUE DE RESO NECESSITE UN MODELE'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NON (EXIS SUPTAB 'CARACTERISTIQUES')); 
         MESS 'ERREUR : IL FAUT DONNER LE CHAMP CARACTERISTIQUE'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     MOD_TOT = SUPTAB.'MODELE'; 
     MOD_MEC = EXTR MOD_TOT 'FORM' 'MECANIQUE'; 
     MAT_MEC = REDU (SUPTAB.'CARACTERISTIQUES') MOD_MEC; 
     GHYPO = 'HPP'; 
 SINON; 
     SI (EXIS SUPTAB.'SOLUTION_PASAPAS' 'WTABLE'); 
         MOD_TOT = SUPTAB.'SOLUTION_PASAPAS'.'MODELE'; 
         WTAB = SUPTAB.'SOLUTION_PASAPAS'.'WTABLE'; 
         MOD_MEC = WTAB.'MOD_MEC'; 
         MAT_MEC = WTAB.'MAT_MEC'; 
     SINON; 
         MESS 'Absence de WTABLE !  l execution continue ...'; 
         MOD_TOT = SUPTAB.'SOLUTION_PASAPAS'.'MODELE'; 
         WTAB = SUPTAB.'SOLUTION_PASAPAS'; 
         MOD_MEC = EXTR MOD_TOT 'FORM' 'MECANIQUE'; 
         MAT_MEC = REDU (WTAB.'CARACTERISTIQUES') MOD_MEC; 
     FINSI; 
     SUPTAB.'MODELE' = MOD_MEC; 
     SI WTAB.'GRANDS_DEPLACEMENTS'; 
         GHYPO = 'GRANDS_DEPLACEMENTS'; 
     SINON; 
         GHYPO = 'HPP'; 
     FINSI; 
     SI WTAB.'DYNAMIQUE'; 
         GSOLU = CHAI GSOLU ' ' 'DYNAMIQUE'; 
     SINON; 
         GSOLU = CHAI GSOLU ' ' 'STATIQUE'; 
     FINSI; 
 FINSI; 
 GMTYPE = TABL; 
 * COMPORTEMENT ELASTIQUE 
 SI (EXIS MOD_MEC 'MATE' 'ISOTROPE'); 
     GMTYPE.'ELASTIQUE' = MOT 'ELASTIQUE ISOTROPE'; 
 SINON; 
     GMTYPE.'ELASTIQUE' = MOT 'ELASTIQUE ANISOTROPE'; 
 FINSI; 
 * COMPORTEMENT PLASTIQUE 
 MPLAS = TABL; 
 MPLAS.(1) MPLAS.(2) MPLAS.(3) = 'ISOTROPE' 'PARFAIT' 'CINEMATIQUE'; 
 SI (EXIS MOD_MEC 'MATE' 'PLASTIQUE'); 
     GMTYPE.'PLASTIQUE' = MOT 'PLASTIQUE'; 
     REPE I (DIME MPLAS); 
         SI (EXIS MOD_MEC 'MATE' MPLAS.&I); 
             GMTYPE.'PLASTIQUE' = CHAI GMTYPE.'PLASTIQUE' ' ' MPLAS.&I; 
         FINSI; 
     FIN I; 
 FINSI; 
 * COMPORTEMENT VISCOPLASTIQUE 
 MVISC = TABL; 
 MVISC.(1) MVISC.(2) MVISC.(3) MVISC.(4) MVISC.(5) MVISC.(6) = 
     'NORTON' 'POLYNOMIAL' 'BLACKBURN' 'RCCMR_316' 'RCCMR_304' 'LEMAITRE'; 
 SI (EXIS MOD_MEC 'MATE' 'FLUAGE'); 
     GMTYPE.'FLUAGE' = MOT 'FLUAGE'; 
     REPE I (DIME MVISC); 
         SI (EXIS MOD_MEC 'MATE' MVISC.&I); 
             GMTYPE.'FLUAGE' = CHAI GMTYPE.'FLUAGE' ' ' MVISC.&I; 
         FINSI; 
     FIN I; 
 FINSI; 
   
 * PROPRIETES QUI DEPENDENT D'UN PARAMETRE 
 CPARA = EXTR MAT_MEC 'COVA'; 
 PPARA = MOTS; 
 REPE I (DIME CPARA); 
     PPARA = PPARA ET (EXTR CPARA &I); 
 FIN I; 
 * PROPRIETES QUI DEPENDENT DE LA POSITION 
 MCOMP = EXTR MAT_MEC 'COMP'; 
 PPOSI = MOTS; 
 REPE I (DIME MCOMP); 
     ICOMP = EXTR MCOMP &I; 
     SI (NON (EXIS PPARA ICOMP)); 
         ICHAM = EXCO MAT_MEC ICOMP; 
   
 *       On teste le Type car 'COVA' a des exceptions (comme 'ECRO' qui est un EVOLUTION mais consideree constante) 
 *       Amelioration a prevoir : boucle sur les SOUS-ZONES et s'assurer qu'il y a bien au moins 1 Ã©lÃ©ment... 
 *       On aimerait bien avoir un operateur qui repond par VRAI ou FAUX si un objet est constant !!! 
         ValTyp='TYPE' ('EXTR' ICHAM ICOMP 1 1 1); 
         SI ('NEG' ValTyp ('MOT' 'FLOTTANT')); 'ITER' I ; 'FINS'; 
         SI (NEG (MINI ICHAM) (MAXI ICHAM)); 
             PPOSI = PPOSI ET ICOMP; 
         FINSI; 
     FINSI; 
 FIN I; 
 * PROPRIETES A GRADIENT 
 PGRAD = PPARA ET PPOSI; 
 * DISCONTINUITES MATERIELLES 
 SI (EXIS SUPTAB 'MODELES_COMPOSITES'); 
     DISMAT = VRAI; 
     TABMOD = SUPTAB.'MODELES_COMPOSITES'; 
 SINON; 
     DISMAT = FAUX; 
 FINSI; 
 * MESSAGE TYPE DE SOLUTION 
 MESS 'CALCUL :'/NMESS GSOLU/NDEC; 
 * MESSAGE HYPOTHESE DE CALCUL 
 MESS 'HYPOTHESE :'/NMESS GHYPO/NDEC; 
 * MESSAGE MATERIAU 
 MESSMAT = CHAI 'COMPORTEMENT :'/NMESS GMTYPE.'ELASTIQUE'/NDEC; 
 SI (EXIS GMTYPE 'PLASTIQUE'); 
     MESSMAT = CHAI MESSMAT ' ' GMTYPE.'PLASTIQUE'; 
 FINSI; 
 SI (EXIS GMTYPE 'FLUAGE'); 
     MESSMAT = CHAI MESSMAT ' ' GMTYPE.'FLUAGE'; 
 FINSI; 
 MESS MESSMAT; 
 * MESSAGE VARIATION DES PROPRIETES 
 SI DISMAT; 
     MESSVAR = CHAI 'PROPRIETES :'/NMESS 'HOMOGENES PAR MORCEAUX'/NDEC; 
 SINON; 
     SI ((DIME PGRAD) > 0); 
         MESSVAR = CHAI 'PROPRIETES :'/NMESS 'HETEROGENES A GRADIENT'/NDEC; 
     SINON; 
         MESSVAR = CHAI 'PROPRIETES :'/NMESS 'HOMOGENES'/NDEC; 
     FINSI; 
 FINSI; 
 MESS MESSVAR; 
   
 * I.1.E - MAILLAGE ET TYPE D'ELEMENTS 
 MAILLAGE = EXTR MOD_MEC 'MAIL'; 
 SUPTAB.'FISSURE' = VIDE 'MAILLAGE'; 
 SI (EXIS SUPTAB 'LEVRE_SUPERIEURE'); 
     SUPTAB.'FISSURE' = SUPTAB.'FISSURE' ET SUPTAB.'LEVRE_SUPERIEURE'; 
 FINSI; 
 SI (EXIS SUPTAB 'LEVRE_INFERIEURE'); 
     SUPTAB.'FISSURE' = SUPTAB.'FISSURE' ET SUPTAB.'LEVRE_INFERIEURE'; 
 FINSI; 
 * ELEMENTS LINEAIRES OU NONLINEAIRES 
 ELTYPE = MAILLAGE ELEM 'TYPE'; 
 ELLIN = MOTS 'TRI3' 'QUA4' 'CUB8' 'PRI6' 'PYR5' 'TET4'; 
 ELQUA = MOTS 'TRI6' 'QUA8' 'CU20' 'PR15' 'PY13' 'TE10'; 
 IENLE = LECT; 
 REPE I (DIME ELTYPE); 
     SI (NON (EXIS (ELLIN ET ELQUA) (EXTR ELTYPE &I))); 
         IENLE = IENLE ET (LECT &I); 
     FINSI; 
 FIN I; 
 SI ((DIME IENLE) NEG 0); 
     MESS 'ATTENTION : IL Y A DES ELEMENTS ATYPIQUES DANS LE MAILLAGE...'; 
     MESS '          LE CALCUL SE POURSUIT QUAND MEME.'; 
     ELTYPE = ENLE ELTYPE IENLE; 
 FINSI; 
 SI (NON ((EXIS ELLIN ELTYPE 'ET') OU (EXIS ELQUA ELTYPE 'ET'))); 
     MESS 'ATTENTION : IL Y A A LA FOIS DES ELEMENTS LINEAIRES ET DES'; 
     MESS '          ELEMENTS QUADRATIQUES DANS LE MAILLAGE'; 
     GELDEG = 1.5; 
 SINON; 
     SI (EXIS ELLIN ELTYPE 'ET'); 
         GELDEG = 1; 
     SINON; 
         GELDEG = 2; 
     FINSI; 
 FINSI; 
 * ELEMENTS XFEM OU STANDARD (MASSIF OU COQUE) 
 SI (EXIS MOD_MEC 'ELEM' 'XQ4R' 'XC8R'); 
     GELTYP = MOT 'XFEM'; 
 SINON; 
     EL2D = MOTS 'TRI3' 'TRI6' 'QUA4' 'QUA8'; 
     EL3D = MOTS 'CUB8' 'CU20' 'PRI6' 'PR15' 'PYR5' 'PY13' 'TET4' 'TE10'; 
     SI (NON ((EXIS EL2D ELTYPE 'ET') OU (EXIS EL3D ELTYPE 'ET'))); 
         MESS 'ERREUR : LE MAILLAGE SUPPORT DU MODELE EST CONSTITUE'; 
         MESS '       D''ELEMENTS 2D ET 3D.'; 
         ERRE 21 ; QUIT G_CAS; 
     SINON; 
         SI ((EGA GDIME 3) ET (EXIS EL2D ELTYPE 'ET')); 
             GELTYP = 'STD COQUE'; 
         SINON; 
             GELTYP = MOT 'STD MASSIF'; 
         FINSI; 
     FINSI; 
 FINSI; 
 * MESSAGE 
 MESSELEM = CHAI 'ELEMENTS :'/NMESS GELTYP/NDEC; 
 MESSELEM = CHAI MESSELEM ' DEGRE' ' ' GELDEG; 
 MESS MESSELEM; 
   
 * I.1.F - CHARGEMENT 
 GCHAR = TABL; 
 SI (EXIS MOD_TOT 'MATE' 'PRESSION'); 
     SI (EGA GELTYP 'XFEM'); 
         GCHAR.'PRESSION' = 'HORS LEVRES'; 
     SINON; 
         MODCHA = EXTR MOD_TOT 'FORM' 'CHARGEMENT'; 
         MODPRE = EXTR MODCHA 'COMP' 'PRESSION'; 
         MAILPTOT = EXTR MODPRE 'MAIL'; 
         MAILPF = INTE MAILPTOT (SUPTAB.'FISSURE'); 
         SI ((NBEL MAILPF) > 0); 
             GCHAR.'PRESSION' = 'SUR LEVRES'; 
         SINON; 
             GCHAR.'PRESSION' = 'HORS LEVRES'; 
         FINSI; 
     FINSI; 
 SINON; 
     GCHAR.'PRESSION' = 'AUCUN'; 
 FINSI; 
 SI (EGA GSOLU 'LINEAIRE'); 
     GCHAR.'MECANIQUE' = EXIS SUPTAB 'CHARGEMENTS_MECANIQUES'; 
     SI (EXIS SUPTAB 'TEMPERATURES'); 
         GCHAR.'THERMIQUE' = MOT 'DECOUPLE'; 
     SINON; 
         GCHAR.'THERMIQUE' = 'AUCUN'; 
     FINSI; 
     GCHAR.'DEFORMATIONS IMPOSEES' = EXIS SUPTAB 'DEFORMATIONS_IMPOSEES'; 
 SINON; 
     CHAR1 = SUPTAB.'SOLUTION_PASAPAS'.'CHARGEMENT'; 
     GCHAR.'MECANIQUE' = (EXIS CHAR1 'DIMP') OU (EXIS CHAR1 'MECA'); 
     SI (EXIS CHAR1 'T'); 
         GCHAR.'THERMIQUE' = MOT 'DECOUPLE'; 
     SINON; 
         SI ((EXIS CHAR1 'TIMP') OU (EXIS CHAR1 'Q') OU 
             (EXIS CHAR1 'TECO') OU (EXIS CHAR1 'TERA')); 
             GCHAR.'THERMIQUE' = MOT 'COUPLE'; 
         SINON; 
             GCHAR.'THERMIQUE' = 'AUCUN'; 
         FINSI; 
     FINSI; 
     GCHAR.'DEFORMATIONS IMPOSEES' = EXIS CHAR1 'DEFI'; 
 FINSI; 
 NBCHAR = 0; 
 MESSCHAR = MOT 'CHARGEMENT :'; 
 ICHAR = INDE GCHAR; 
 REPE I (DIME ICHAR); 
     MCHAR = MOT ICHAR.&I; 
     SI (NEG NBCHAR 0); 
         MESSCHAR = ' '; 
     FINSI; 
     SI (EGA (TYPE GCHAR.(MOT ICHAR.&I)) 'LOGIQUE'); 
         SI GCHAR.MCHAR; 
             MESSCHAR = CHAI MESSCHAR/NMESS MCHAR/NDEC; 
             MESS MESSCHAR; 
             NBCHAR = NBCHAR + 1; 
         FINSI; 
     FINSI; 
     SI (EGA (TYPE GCHAR.MCHAR) 'MOT'); 
         SI (NEG GCHAR.MCHAR 'AUCUN'); 
             MESSCHAR = CHAI MESSCHAR/NMESS MCHAR/NDEC; 
             MESSCHAR = CHAI MESSCHAR ' ' GCHAR.MCHAR; 
             MESS MESSCHAR; 
             NBCHAR = NBCHAR + 1; 
         FINSI; 
     FINSI; 
 FIN I; 
   
 * I.1.G - CONTACT ENTRE LEVRES DE FISSURE 
 BCONT = (EXIS SUPTAB 'MODELE_FISSURE'); 
 MESS 'CONTACT LEVRES :'/NMESS BCONT/NDEC; 
   
   
 * I.2 - VERIFICATION QUE LE CAS EST TRAITABLE 
 * ******************************************* 
   
 * I.2.A - VERIFICATION QUE L'ON CONNAIT L'OBJECTIF 
 SI ((NEG GOBJ 'J') ET (NEG GOBJ 'C*') ET (NEG GOBJ 'C*H') 
         ET (NEG GOBJ 'DJ/DA') ET (NEG GOBJ 'J_DYNA') 
             ET (NEG GOBJ 'DECOUPLAGE')); 
     MESS 'ERREUR : ON NE CONNAIT PAS L INTEGRALE SPECIFIEE'; 
     MESS '       A CALCULER'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
   
 * I.2.B - VERIFICATION QUE LE MATERIAU EST ISOTROPE 
 SI (EGA GMTYPE.'ELASTIQUE' (MOT 'ELASTIQUE ANISOTROPE')); 
     MESS 'ERREUR : ON NE PEUT PAS TRAITER LE CAS DE MATERIAUX ANISOTROPES.'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
   
 * I.2.C - VERIFICATION QUE L'ON A PAS A LA FOIS DES INTERFACES ET DES GRADIENTS 
 *        DE PROPRIETES 
 SI (DISMAT ET ((DIME PGRAD) > 0)); 
     MESS 'ERREUR : ON NE PEUT PAS TRAITER LE CAS DE DISCONTINUITES'; 
     MESS '       MATERIELLES DANS UN SOLIDE A GRADIENT DE PROPRIETES'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
   
 * I.2.D - INTERFACES (2D SEULEMENT, ET ON DOIT AVOIR AU MOINS DEUX MODELES) 
 SI DISMAT; 
     SI (EGA GDIME 3); 
         MESS 'ERREUR : ON NE PEUT PAS ENCORE TRAITER LES DISCONTINUITES DE'; 
         MESS '       PROPRIETES EN 3D'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI ((DIME SUPTAB.'MODELES_COMPOSITES') < 2); 
         MESS 'ERREUR : IL FAUT AU MOINS DEUX MODELES POUR'; 
         MESS '       DETERMINER LA LIGNE COMMUNE D''INTERFACE'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 FINSI; 
   
 * I.2.E - OBJECTIF : J 
 SI (EGA GOBJ 'J'); 
     SI (EXIS GMTYPE 'FLUAGE'); 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTOPLASTIQUE POUR'; 
         MESS '       CALCULER L''INTEGRALE J'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 FINSI; 
   
 * I.2.F - OBJECTIF : C* OU C*H 
 SI ((EGA GOBJ 'C*') OU (EGA GOBJ 'C*H')); 
     SI (NON (EXIS GMTYPE 'FLUAGE')); 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT VISCOPLASTIQUE POUR'; 
         MESS '       CALCULER L''INTEGRALE' ' ' GOBJ; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NEG GCHAR.'THERMIQUE' 'AUCUN'); 
         MESS 'ERREUR : ON NE PEUT PAS ENCORE CALCULER L''INTEGRALE' ' ' GOBJ; 
         MESS '       DANS LE CAS D''UN CHARGEMENT THERMIQUE'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NEG GHYPO 'HPP'); 
         MESS 'ERREUR : ON NE PEUT PAS ENCORE CALCULER L''INTEGRALE' ' ' GOBJ; 
         MESS '       EN GRANDS DEPLACEMENTS'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (EGA GOBJ 'C*H'); 
         REPE I (DIME MVISC); 
             SI ((NEG MVISC.&I 'NORTON') ET (EXIS MOD_MEC 'MATE' MVISC.&I)); 
                 MESS 'ERREUR : IL FAUT UN MODELE DE FLUAGE NORTON'; 
                 MESS '       SEUL POUR CALCULER L INTEGRALE' ' ' GOBJ; 
                                 ERRE 21 ; QUIT G_CAS; 
             FINSI; 
         FIN I; 
     FINSI; 
 FINSI; 
   
 * I.2.G - OBJECTIF : DJ/DA 
 SI (EGA GOBJ 'DJ/DA'); 
     SI (EXIS GMTYPE 'FLUAGE'); 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTOPLASTIQUE POUR'; 
         MESS '       CALCULER L''INTEGRALE DJ/DA'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (DISMAT OU ((DIME PGRAD) > 0)); 
         MESS 'ERREUR : ON NE PEUT CALCULER L''INTEGRALE DJ/DA QUE'; 
         MESS '       DANS LE CAS DE PROPRIETES HOMOGENES'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NEG GELTYP 'STD MASSIF'); 
         MESS 'ERREUR : ON NE PEUT CALCULER L''INTEGRALE DJ/DA QU''AVEC'; 
         MESS '       DES ELEMENTS STANDARDS MASSIFS'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NEG GHYPO 'HPP'); 
         MESS 'ERREUR : ON NE PEUT CALCULER L''INTEGRALE DJ/DA QUE'; 
         MESS '       SOUS L''HYPOTHESE DES PETITES PERTURBATIONS'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NON (EXIS SUPTAB 'BLOCAGES_MECANIQUES')); 
         MESS 'ERREUR : IL FAUT DONNER LES BLOCAGES MECANIQUES'; 
         MESS '       POUR CALCULER L''INTEGRALE DJ/DA' 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 FINSI; 
   
 * I.2.H - OBJECTIF : J_DYNA 
 SI (EGA GOBJ 'J_DYNA'); 
     SI ((EXIS GMTYPE 'PLASTIQUE') OU (EXIS GMTYPE 'FLUAGE')); 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTIQUE POUR CALCULER'; 
         MESS '       L''INTEGRALE J_DYNA'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NEG GSOLU (MOT 'PASAPAS DYNAMIQUE')); 
         MESS 'ERREUR : ON ATTEND UNE SOLUTION DE PASAPAS DYNAMIQUE POUR'; 
         MESS '       CALCULER L''INTEGRALE J_DYNA'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 FINSI; 
   
 * I.2.I - OBJECTIF : DECOUPLAGE 
 SI (EGA GOBJ (MOT 'DECOUPLAGE')); 
     SI ((EXIS GMTYPE 'PLASTIQUE') OU (EXIS GMTYPE 'FLUAGE')); 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTIQUE POUR UTILISER'; 
         MESS '       L''OPTION DECOUPLAGE'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI ((DIME PGRAD) > 0); 
         MESS 'ERREUR : ON NE PEUT PAS UTILISER L''OPTION DECOUPLAGE POUR UN'; 
         MESS '       SOLIDE A GRADIENT DE PROPRIETES'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (EGA GELTYP 'STD COQUE'); 
         MESS 'ERREUR : ON NE PEUT PAS UTILISER L''OPTION DECOUPLAGE DANS LE'; 
         MESS '       CAS DE COQUES'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 *   SI IL Y A DES INTERFACES IL FAUT VERIFIER QU'ELLES SONT PARALLELES A LA 
 *   FISSURE, MAIS LA DIRECTION DE CELLE-CI EST OBTENUE APRES AVOIR CALCULE 
 *   LE CHAMP THETA, DONC CETTE VERIFICATION EST FAITE DANS G_THETA 
 FINSI; 
   
 * I.2.J - CONTACT ENTRE LES LEVRES : UNIQUEMENT AVEC RESO ET XFEM 
 SI BCONT; 
     SI (NEG GSOLU 'LINEAIRE'); 
         MESS 'ERREUR : CONTACT ENTRE LES LEVRES NON PREVU AVEC UNE SOLUTION'; 
         MESS '       DE PASAPAS'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
     SI (NEG GELTYP (MOT 'XFEM')); 
         MESS 'ERREUR : CONTACT ENTRE LES LEVRES NON PREVU AVEC DES ELEMENTS'; 
         MESS '       STANDARDS'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 FINSI; 
   
 * I.2.K - ON VERIFIE QU'IL N'Y A PAS DE GRADIENT DE COEFFICIENT DE POISSON 
 SI (EXIS PGRAD 'NU'); 
     MESS 'ERREUR : ON NE SAIT PAS ENCORE TRAITER LA PRESENCE D''UN GRADIENT'; 
     MESS '       DE COEFFICIENT DE POISSON'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
   
   
 * I.3 - VERIFICATION DES DONNEES NECESSAIRES 
 * ****************************************** 
   
 * I.3.A - FRONT DE FISSURE 
 SI (NON (EXIS SUPTAB 'FRONT_FISSURE')); 
     MESS 'ERREUR : ON VEUT LE FRONT DE LA FISSURE'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
 M_FRONT = SUPTAB.'FRONT_FISSURE'; 
 SI ((NEG (TYPE M_FRONT) 'MAILLAGE') ET (NEG (TYPE M_FRONT) 'POINT')); 
     MESS 'ERREUR : LE FRONT DE FISSURE DOIT ETRE DE TYPE MAILLAGE OU POINT'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
 SI (EGA (TYPE M_FRONT) 'POINT'); 
     M_FRONT = MANU 'POI1' M_FRONT; 
 SINON; 
     MTYPEL = M_FRONT ELEM 'TYPE'; 
     MTYPEL = EXTR MTYPEL 1; 
     SI (NEG MTYPEL 'POI1'); 
         M_FRONT = ORDO M_FRONT; 
         SUPTAB.'FRONT_FISSURE' = M_FRONT; 
     FINSI; 
 FINSI; 
 M_FRONT = M_FRONT COUL 'OLIV'; 
   
 * I.3.B - FISSURE_2 ET SON FRONT POUR DJ/DA 
 SI (EGA GOBJ 'DJ/DA'); 
     SI ((EXIS SUPTAB 'FISSURE_2') OU (EXIS SUPTAB 'FRONT_FISSURE_2')); 
         SI (NON (EXIS SUPTAB 'FISSURE_2')); 
             MESS 'ERREUR : ON VEUT AUSSI LA FISSURE 2 POUR CALCULER'; 
             MESS '       LES TERMES CROISES DE LA MATRICE'; 
             ERRE 21 ; QUIT G_CAS; 
         FINSI; 
         SI (NON (EXIS SUPTAB 'FRONT_FISSURE_2')); 
             MESS 'ERREUR : ON VEUT AUSSI LE FROND DE LA FISSURE 2 POUR'; 
             MESS '       CALCULER LES TERMES CROISES DE LA MATRICE'; 
             ERRE 21 ; QUIT G_CAS; 
         FINSI; 
     SINON; 
         SI (EGA SUPTAB.'COUCHE' 0); 
             MESS 'ERREUR : LE NOMBRE DE COUCHES DOIT ETRE SUPERIEUR A'; 
             MESS '       0 POUR LE CALCUL DU TERME PRINCIPAL DJi/DAi'; 
             ERRE 21 ; QUIT G_CAS; 
         FINSI; 
     FINSI; 
 FINSI; 
   
 * I.3.C - PRESSION OBLIGATOIRE SI CALCUL LINEAIRE ET MODELE DE PRESSION 
 SI ((NEG GCHAR.'PRESSION' 'AUCUN') ET (EGA GSOLU 'LINEAIRE')); 
     SI (NON (EXIS SUPTAB 'PRESSION')); 
         MESS 'ERREUR : IL MANQUE LA DONNEE DU CHAMP DE PRESSION'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 FINSI; 
   
 * I.3.D - DEFINITION DE LA FISSURE NECESSAIRE 
 SI (EGA GELTYP (MOT 'XFEM')); 
     SI (NON ((EXIS SUPTAB 'PSI') ET (EXIS SUPTAB 'PHI'))); 
         MESS 'ERREUR : ON VEUT PSI et PHI LEVELSET DE LA FISSURE'; 
         ERRE 21 ; QUIT G_CAS; 
     FINSI; 
 SINON; 
     SI (EGA GT_OBJ 'DECOUPLAGE'); 
         SI (NON ((EXIS SUPTAB 'LEVRE_SUPERIEURE') ET 
                     (EXIS SUPTAB 'LEVRE_INFERIEURE'))); 
             MESS 'ERREUR : L''OBJECTIF DECOUPLAGE NECESSITE LES DEUX'; 
             MESS '       LEVRES DE LA FISSURE'; 
             ERRE 21 ; QUIT G_CAS; 
         FINSI; 
     SINON; 
         SI (NON ((EXIS SUPTAB 'LEVRE_SUPERIEURE') OU 
                     (EXIS SUPTAB 'LEVRE_INFERIEURE'))); 
             MESS 'ERREUR : IL FAUT DONNER LA FISSURE'; 
             MESS '(LEVRE_SUPERIEURE OU LEVRE_INFERIEURE OU LES 2)'; 
             ERRE 21 ; QUIT G_CAS; 
         FINSI; 
     FINSI; 
 FINSI; 
   
 * I.3.E - ON VERIFIE QU'ON A OU BIEN LE NOMBRE DE COUCHES OU BIEN CHAMP_THETA 
 SI (NON ((EXIS SUPTAB 'COUCHE') OU (EXIS SUPTAB 'CHAMP_THETA'))); 
     MESS 'ERREUR : ON VEUT LE NOMBRE DE COUCHES D ELEMENTS'; 
     MESS '       AUTOUR DE LA FISSURE QUI SE DEPLACE'; 
     MESS '       OU LE CHAMP_THETA'; 
     MESS '       POUR SIMULER LA PROPAGATION DE LA FISSURE'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
   
 * I.3.F - ON NE CALCULE PAS CORRECTEMENT LE CAS THERMIQUE AVEC DES COQUES 
 *        DONC POUR L'INSTANT ON DEBRANCHE L'OPTION 
 SI ((EGA GELTYP 'STD COQUE') ET (NEG GCHAR.'THERMIQUE' 'AUCUN')); 
     MESS 'ERREUR : UNE CORRECTION EST NECESSAIRE POUR TRAITER UN CHARGEMENT'; 
     MESS '       THERMIQUE AVEC LES ELEMENTS COQUE'; 
     ERRE 21 ; QUIT G_CAS; 
 FINSI; 
   
   
 * ============================================================================= 
   
 * II - STOCKAGE DES INFORMATIONS POUR TRANSFERT A G_THETA 
 * ------------------------------------------------------- 
   
 * II.1 - OBJETS ET INFOS UTILES DANS OBJUTI 
 * ***************************************** 
   
 OBJUTI = TABL; 
 OBJUTI.'DIMENSION' = GDIME; 
 OBJUTI.'MODE' = GMODE; 
 OBJUTI.'MOD_TOT' = MOD_TOT; 
 OBJUTI.'MOD_MEC' = MOD_MEC; 
 OBJUTI.'MAT_MEC' = MAT_MEC; 
 OBJUTI.'NMESS' = NMESS; 
 OBJUTI.'MAILLAGE' = MAILLAGE; 
 OBJUTI.'FRONT' = M_FRONT; 
 SI (NEG GSOLU 'LINEAIRE'); 
     OBJUTI.'WTAB' = WTAB; 
 FINSI; 
   
 * II.2 - BOOLEENS DANS BOOL 
 * ************************* 
   
 * OBJECTIF 
 BOOL.'J' = EGA SUPTAB.'OBJECTIF' 'J'; 
 BOOL.'C*' = EGA SUPTAB.'OBJECTIF' 'C*'; 
 BOOL.'C*H' = EGA SUPTAB.'OBJECTIF' 'C*H'; 
 BOOL.'DJ/DA' = EGA SUPTAB.'OBJECTIF' 'DJ/DA'; 
 BOOL.'J_DYNA' = EGA SUPTAB.'OBJECTIF' 'J_DYNA'; 
 BOOL.'DECOUPLAGE' = EGA SUPTAB.'OBJECTIF' (MOT 'DECOUPLAGE'); 
 * PASAPAS 
 BOOL.'PASAPAS' = NEG GSOLU 'LINEAIRE'; 
 * GRANDS DEPLACEMENTS 
 BOOL.'GRANDS_DEP' = EGA GHYPO 'GRANDS_DEPLACEMENTS'; 
 * MODELE DE PRESSION 
 BOOL.'MODE_PRES' = NEG GCHAR.'PRESSION' 'AUCUN'; 
 * PRESSION SUR FISSURE 
 BOOL.'PRES_FISS' = EGA GCHAR.'PRESSION' 'SUR LEVRES'; 
 * CHARGEMENTS THERMIQUES 
 BOOL.'THER_DECO' = EGA GCHAR.'THERMIQUE' (MOT 'DECOUPLE'); 
 BOOL.'THER' = NEG GCHAR.'THERMIQUE' 'AUCUN'; 
 * DEFORMATIONS IMPOSEES 
 BOOL.'DEF_IMP' = GCHAR.'DEFORMATIONS IMPOSEES'; 
 * ORDRE DES ELEMENTS 
 BOOL.'EL_LIN' = EGA GELDEG 1; 
 BOOL.'EL_QUA' = EGA GELDEG 2; 
 * ELEMENTS XFEM 
 BOOL.'XFEM' = EXIS MOD_MEC 'ELEM' 'XQ4R' 'XC8R'; 
 * ELEMENTS COQUE 
 BOOL.'COQ' = EGA GELTYP 'STD COQUE'; 
 * ROTATION DE CORPS RIGIDE 
 BOOL.'XFEM' = EXIS MOD_MEC 'ELEM' 'XQ4R' 'XC8R'; 
 * ELEMENTS COQUE 
 BOOL.'XFEM' = EXIS MOD_MEC 'ELEM' 'XQ4R' 'XC8R'; 
 * ELEMENTS COQUE 
 BOOL.'COQ' = EGA GELTYP 'STD COQUE'; 
 * ROTATION DE CORPS RIGIDE 
 BOOL.'ROT_RIG' = EXIS SUPTAB 'ROTATION_RIGIDIFIANTE'; 
 * PERSO1 
 SI (EXIS SUPTAB 'PERSO1'); 
     BOOL.'PERSO1' = SUPTAB.'PERSO1'; 
 SINON; 
     BOOL.'PERSO1' = FAUX; 
 FINSI; 
 * FROTTEMENT ENTRE LEVRES DE FISSURE 
 BOOL.'FROT' = EXIS SUPTAB 'MODELE_FISSURE'; 
   
   
 * SAUT DE LIGNE AVANT DE RETOURNER DANS G_THETA 
 SAUT 'LIGNE'; 
   
 FINP OBJUTI; 
 * CH_THETA  PROCEDUR  JB251061  21/06/14    21:15:01     11034 
 * ============================================================================= 
 *                    PROCEDURE DE CALCUL DU CHAMP THETA/PI 
 *                    ------------------------------------- 
 * 
 * DESCRIPTION : DETERMINE UN CHPOINT DE NORME CONSTANTE A L'INTERIEUR D'UNE 
 *               COURONNE ENTOURANT LE FRONT DE FISSURE ET NUL A L'EXTERIEUR DE 
 *               CETTE COURONNE. LE CHPOINT THETA AINSI DEFINI REPRESENTE LA 
 *               DIRECTION DE PROPAGATION EVENTUELLE DE LA FISSURE. 
 * ============================================================================= 
 DEBP CH_THETA SUPTAB*TABLE OBJUTI*'TABLE' BOOL*'TABLE' ; 
   
 * ON DETERMINE CE QUE L'ON CALCULE 
 SI (NON (EXIS SUPTAB 'CHAMP_THETA')) ; 
     CALCUL = VRAI ; 
     RESULT = MOT 'THETA' ; 
 SINON ; 
     CALCUL = FAUX ; 
     SI (NON (EXIS SUPTAB 'TAB_THETA')) ; 
         RESULT = MOT 'THETA' ; 
     SINON ; 
         SI BOOL.'DJ/DA' ; 
             SI (NON (EXIS SUPTAB 'CHAMP_PI')) ; 
                 CALCUL = VRAI ; 
                 RESULT = MOT 'PI' ; 
             SINON ; 
                 SI (NON (EXIS SUPTAB 'TAB_PI')) ; 
                     RESULT = MOT 'PI' ; 
                 SINON ; 
                     RESULT = MOT 'RIEN' ; 
                 FINSI ; 
             FINSI ; 
         SINON ; 
             RESULT = MOT 'RIEN' ; 
         FINSI ; 
     FINSI ; 
 FINSI ; 
 * SI RESULT = RIEN C'EST QU'ON A DEJA TOUT CE QU'IL FAUT 
 SI (EGA RESULT 'RIEN') ; 
     QUIT CH_THETA ; 
 FINSI ; 
   
 * RECUPERATION DE CERTAINES DONNEES 
 GDIME = OBJUTI.'DIMENSION' ; 
 MAILLAGE = SUPTAB.'MAILLAGE' ; 
 CRACK = SUPTAB.'FISSURE' ; 
 FRON1 = SUPTAB.'FRONT_FISSURE' ; 
 MOD_MEC = OBJUTI.'MOD_MEC' ; 
 * QUELQUES MOTS UTILES 
 * (ON EXTRAIT LES GDIME PREMIERS MOTS CAR ON NE VEUT PAS DES ROTATIONS 
 * DANS LE CAS DES COQUES) 
 MUI = EXTR (EXTR MOD_MEC 'DEPL') (LECT 1 PAS 1 GDIME) ; 
 MFI = EXTR (EXTR MOD_MEC 'FORC') (LECT 1 PAS 1 GDIME) ; 
 MU1 = EXTR MUI 1 ; MU2 = EXTR MUI 2 ; 
 MF1 = EXTR MFI 1 ; MF2 = EXTR MFI 2 ; 
 SI (EGA GDIME 3) ; 
     MU3 = EXTR MUI 3 ; 
     MF3 = EXTR MFI 3 ; 
 FINSI ; 
 * VECTEUR NUL 
 SI (EGA GDIME 2) ; 
     VNUL = 0. 0. ; 
 SINON ; 
     VNUL = 0. 0. 0. ; 
 FINSI ; 
 * NOEUDS POUR LESQUELS ON VEUT FAIRE LE CALCUL 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
     SI (EXIS SUPTAB 'NOEUDS_AVANCES') ; 
         NOAV = SUPTAB.'NOEUDS_AVANCES' ; 
     SINON ; 
         NOAV = FRON1 ; 
     FINSI ; 
 FINSI ; 
   
   
 * ============================================================================= 
 *                   PARTIE 1 : CALCUL DU CHAMP THETA OU PI 
 *                   -------------------------------------- 
   
 * I - COMPATIBILITE DES DONNEES 
 * ----------------------------- 
   
 * VERIFICATION DE LA VALEUR DE 'ELEM' 
 GELEM = VALE 'ELEM' ; 
 SI (EGA GELEM ' ') ; 
    MESS 'ERREUR : TYPE D''ELEMENTS NON DECLARE. UTILISEZ' ; 
    MESS '         L OPERATEUR OPTI POUR LE DECLARER' ; 
    QUIT CH_THETA ; 
 FINSI ; 
   
 * DEFINITION DU MAILLAGE ET DU NOMBRE DE NOEUDS 
 SI (EXIS SUPTAB 'MAILLAGE') ; 
     MAILLAGE = SUPTAB.'MAILLAGE' ; 
     NB1 = NBNO (CHAN MAILLAGE 'POI1') ; 
 SINON ; 
     MESS 'ERREUR : ON N A PAS TROUVE DANS LA TABLE L''INDICE ''MAILLAGE''' ; 
     QUIT CH_THETA ; 
 FINSI ; 
 M_FISS = ELEM MAILLAGE 'APPUYE' 'LARGEMENT' SUPTAB.'FRONT_FISSURE' ; 
   
 * VERIFICATION QUE L'EPAISSEUR EST DONNEE POUR LES COQUES 
 SI (BOOL.'COQ' ET (NON (EXIS SUPTAB 'EPAISSEUR'))) ; 
     MESS 'ERREUR : L EPAISSEUR DE LA COQUE N EST PAS DONNEE' ; 
     QUIT CH_THETA ; 
 FINSI ; 
   
 * VERIFICATIONS SUR LA FISSURE : 
 * ****************************** 
 * DEFINITION DE LA FISSURE 
 SI (NON (EXIS SUPTAB 'FISSURE')) ; 
     MESS 'ERREUR : LA FISSURE DU PROBLEME N EST PAS DONNEE' ; 
     QUIT CH_THETA ; 
 SINON ; 
     CRACK = SUPTAB.'FISSURE' ; 
 FINSI ; 
 * VERIFICATION QUE LA FISSURE EST DE TYPE MAILLAGE 
 SI (NEG (TYPE CRACK) 'MAILLAGE') ; 
     MESS 'ERREUR : LA FISSURE DOIT ETRE UN OBJET DE TYPE MAILLAGE' ; 
     QUIT CH_THETA ; 
 FINSI ; 
 * VERIFICATION QU'IL N'Y A PAS DE NOEUDS DOUBLES 
 NB2 = NBNO (CHAN (CRACK ET MAILLAGE) 'POI1') ; 
 SI (NEG NB1 NB2) ; 
     MESS 'ERREUR : IL Y A DES NOEUDS DOUBLES ENTRE' ; 
     MESS '         LE MAILLAGE ET LA FISSURE' ; 
     QUIT CH_THETA ; 
 FINSI ; 
 * VERIFICATION QUE LA FISSURE EST UNE LIGNE EN 2D OU 3D COQUE 
 * ET UNE SURFACE EN 3D MASSIF 
 LMFISS = ELEM CRACK 'TYPE' ; 
 LMLIGN = MOTS 'SEG2' 'SEG3' ; 
 LMSURF = MOTS 'TRI3' 'TRI6' 'QUA4' 'QUA8' ; 
 SI ((EGA GDIME 2) OU ((EGA GDIME 3) ET BOOL.'COQ')) ; 
     SI (NON (EXIS LMLIGN LMFISS 'ET')) ; 
         MESS 'ERREUR : EN 2D OU ELEMENTS DE COQUE MINCE' ; 
         MESS '         LA FISSURE DOIT ETRE UNE LIGNE' ; 
         QUIT CH_THETA ; 
     FINSI ; 
 FINSI ; 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
     SI (NON (EXIS LMSURF LMFISS 'ET')) ; 
         MESS 'ERREUR : EN 2D OU ELEMENTS DE COQUE MINCE' ; 
         MESS '         LA FISSURE DOIT ETRE UNE LIGNE' ; 
         QUIT CH_THETA ; 
     FINSI ; 
 FINSI ; 
   
 * VERIFICATIONS SUR LE FRONT DE FISSURE : 
 * *************************************** 
 * VERIFICATION QUE LE FRONT EST FOURNI 
 SI (NON (EXIS SUPTAB 'FRONT_FISSURE')) ; 
     MESS 'ERREUR : LE FRONT DE LA FISSURE N''EST PAS DONNE' ; 
     QUIT CH_THETA ; 
 FINSI ; 
 NB2 = NBNO (CHAN (SUPTAB.'FRONT_FISSURE' ET MAILLAGE) 'POI1') ; 
 SI (NEG NB1 NB2) ; 
     MESS 'ERREUR : IL Y A DES NOEUDS DOUBLES ENTRE LE' ; 
     MESS '         MAILLAGE ET LE FRONT DE LA FISSURE' ; 
     QUIT CH_THETA ; 
 FINSI ; 
 * VERIFICATION QUE LE FRONT DE FISSURE EST UNE LIGNE EN 3D MASSIF 
 * ET UN POINT EN 2D OU 3D COQUE 
 MFRONT = TYPE SUPTAB.'FRONT_FISSURE' ; 
 SI ((GDIME EGA 3) ET (NON BOOL.'COQ')) ; 
     SI (NEG MFRONT 'MAILLAGE') ; 
         MESS 'ERREUR : EN 3D AVEC ELEMENTS MASSIFS LE FRONT' ; 
         MESS '         DOIT ETRE DE TYPE MAILLAGE.' ; 
         QUIT CH_THETA ; 
     FINSI ; 
     LMFRONT = SUPTAB.'FRONT_FISSURE' ELEM 'TYPE' ; 
     SI (NON (EXIS LMLIGN LMFRONT 'ET')) ; 
         MESS 'ERREUR : EN 3D AVEC ELEMENTS MASSIFS LE FRONT' ; 
         MESS '         DE LA FISSURE DOIT ETRE UNE LIGNE' ; 
         QUIT CH_THETA ; 
     FINSI ; 
 FINSI ; 
 SI ((GDIME EGA 2) 'OU' ((GDIME EGA 3) ET BOOL.'COQ')) ; 
     SI (NON (EGA MFRONT 'POINT')) ; 
         MESS 'ERREUR : EN 2D OU ELEMENTS EN COQUE MINCE LE' ; 
         MESS '         FOND DE LA FISSURE DOIT ETRE UN POINT' ; 
         QUIT CH_THETA ; 
     FINSI ; 
 FINSI ; 
 * VERIFICATION QU'IL N'Y A PAS DE NOEUDS DOUBLES ENTRE LE FRONT ET LA FISSURE 
 NB1 = NBNO (CHAN CRACK 'POI1') ; 
 NB2 = NBNO (CHAN (SUPTAB.'FRONT_FISSURE' ET CRACK) 'POI1') ; 
 SI (NEG NB1 NB2) ; 
     MESS 'ERREUR : IL Y A DES NOEUDS DOUBLES ENTRE LE FRONT' ; 
     MESS '         DE LA FISSURE ET LA FISSURE ELLE MEME' ; 
     QUIT CH_THETA ; 
 FINSI ; 
   
 * VERIFICATION QUE LE NOMBRE DE COUCHES EST FOURNI 
 SI (EXIS SUPTAB 'COUCHE') ; 
     COUCHE = SUPTAB.'COUCHE' ; 
 SINON ; 
 * SINON ON DOIT AVOIR FOURNI CHAMP_THETA ET ON DETERMINE 
 * ALORS COUCHE A PARTIR DE CELUI-CI 
     SI (EXIS SUPTAB 'CHAMP_THETA') ; 
         THETA = SUPTAB.'CHAMP_THETA' ; 
         NTHETA = (PSCA THETA THETA MUI MUI)**0.5 ; 
         THSUPP = NTHETA POIN 'SUPERIEUR' 0. ; 
         THSUPP = MAILLAGE ELEM 'APPUYE' 'LARGEMENT' THSUPP ; 
         COUCHE = 0 ; 
         MAIL1 = FRON1 ; 
         SI (EGA (TYPE MAIL1) 'POINT') ; 
             MAIL1 = MANU 'POI1' MAIL1 ; 
         FINSI ; 
         REPE ICOUCH ; 
             COUCHE = COUCHE + 1 ; 
             MAIL2 = THSUPP ELEM 'APPUYE' 'LARGEMENT' MAIL1 ; 
             DIFF1 = DIFF MAIL2 THSUPP ; 
             DIFF2 = DIFF MAIL1 MAIL2 ; 
             NCRIT = (NBNO DIFF1) * (NBNO DIFF2) ; 
             SI ((EGA NCRIT 0)) ; 
                 QUIT ICOUCH ; 
             FINSI ; 
             MAIL1 = MAIL2 ; 
         FIN ICOUCH ; 
         LIST COUCHE ; 
     SINON ; 
         MESS 'ERREUR : IL FAUT SOIT LE NOMBRE DE COUCHES SOIT UN CHAMP THETA' ; 
         ERRE 21 ; 
     FINSI ; 
 FINSI ; 
   
 SI CALCUL ; 
   
 * VERIFICATIONS UNIQUEMENT SI CALCUL DU CHAMP GLOBAL 
   
 * CAS 3D : VERIFICATIONS EN CAS DE TUYAU DROIT ET COUDE : 
 * ******************************************************* 
 * TTD = TRANSLATION TUYAUTERIE DROITE 
 * RTD = ROTATION TUYAUTERIE DROITE 
 * RC = ROTATION COUDE 
 * DEFINITION DE BOOLEENS UTILES 
     LCHTRAN = EXIS SUPTAB 'CHPOINT_TRANSFORMATION' ; 
     LOPERA = EXIS SUPTAB 'OPERATEUR' ; 
     LPOINT1 = EXIS SUPTAB 'POINT_1' ; 
     LPOINT2 = EXIS SUPTAB 'POINT_2' ; 
     LPOINT3 = EXIS SUPTAB 'POINT_3' ; 
     SI (EGA GDIME 3) ; 
         SI (LPOINT1 ET LPOINT2 ET LPOINT3) ; 
 * LES 3 POINTS SONT DONNES 
             SI (LCHTRAN OU LOPERA) ; 
 * SI ON DONNE LES 3 POINTS PLUS L'UN DE CES 2 INDICES ON NE SAIT PAS QUOI FAIRE 
                 MESS 'ERREUR : DONNEES IMCOMPATIBLES. CONSULTEZ LA NOTICE;' ; 
                 QUIT CH_THETA ; 
             SINON ; 
 * ON A UNIQUEMENT LES 3 POINTS DONC LE CAS EST 'TTD' 
                 BOOL.'TTD' = VRAI ; 
                 BOOL.'RTD' = FAUX ; 
                 BOOL.'RC' = FAUX ; 
                 PAXEZ1 = SUPTAB.'POINT_1'; 
                 PAXEZ2 = SUPTAB.'POINT_2'; 
                 PAXEZ3 = SUPTAB.'POINT_3'; 
             FINSI ; 
         SINON ; 
 * IL MANQUE DONC AU MOINS UN POINT 
             SI (LPOINT1 ET LPOINT2) ; 
 * LES POINTS 1 ET 2 SONT DONNES 
                 BOOL.'TTD' = FAUX ; 
                 POINT_1 = SUPTAB.'POINT_1'; 
                 POINT_2 = SUPTAB.'POINT_2'; 
                 SI (LCHTRAN ET LOPERA) ; 
 * AVEC CES 2 INDICES EN PLUS ON EST DANS LE CAS 'RC' 
                     BOOL.'RTD' = FAUX ; 
                     BOOL.'RC' = VRAI ; 
                     OPER1 = MOT SUPTAB.'OPERATEUR' ; 
                 SINON ; 
 * IL MANQUE AU MOINS UN DES DEUX INDICES 
                     SI (LCHTRAN OU LOPERA) ; 
 * S'IL Y EN A UN DES DEUX ALORS IL MANQUE UNE INFO 
                         MESS 'ERREUR : LE NOM DE L''OPERATEUR ET LE CHPOINT QUI' ; 
                         MESS '         TRANSFORME LE COUDE EN TUYAUTERIE DROITE' 
                         MESS '         SONT TOUS DEUX OBLIGATOIRES.' ; 
                         QUIT CH_THETA ; 
                     SINON ; 
 * AUCUN DES DEUX INDICES N'EST DONNE DONC ON EST DANS LE CAS 'RTD' 
                         BOOL.'RTD' = VRAI ; 
                         BOOL.'RC' = FAUX ; 
                     FINSI ; 
                 FINSI ; 
             SINON ; 
 * IL MANQUE DONC AU MOINS 2 POINTS 
                 SI (LPOINT1 OU LPOINT2) ; 
 * ON NE PEUT RIEN FAIRE AVEC UN SEUL DES DEUX POINTS 
                     MESS 'ERREUR : ON VEUT POINT_1 ET POINT_2 POUR CONSTITUER' ; 
                     MESS '         L''AXE PERPENDICULAIRE A LA SECTION FISSUREE.' ; 
                     QUIT CH_THETA ; 
                 SINON ; 
 * IL N'Y A AUCUN DES POINTS 
                     BOOL.'TTD' = FAUX ; 
                     BOOL.'RTD' = FAUX ; 
                     BOOL.'RC' = FAUX ; 
                 FINSI ; 
             FINSI ; 
         FINSI ; 
 * BOOLEEN POUR ROTATION (SINON C'EST FORCEMENT UNE TRANSLATION) 
         BOOL.'ROTATION' = BOOL.'RTD' OU BOOL.'RC' ; 
     SINON ; 
 * PAS EN 3D DONC AUCUN DES INDICES NE DOIT ETRE RENSEIGNE 
         SI (LCHTRAN OU LOPERA OU LPOINT1 OU LPOINT2 OU LPOINT3) ; 
             MESS 'ERREUR : UN DES INDICES RENSEIGNES NECESSITE' ; 
             MESS '         D''ETRE EN DIMENSION 3.' ; 
             QUIT CH_THETA ; 
         SINON ; 
 * AUCUN DES INDICES N'A ETE RENSEIGNE DONC ON EST DANS AUCUN DES CAS 
             BOOL.'TTD' = FAUX ; 
             BOOL.'RTD' = FAUX ; 
             BOOL.'RC' = FAUX ; 
         FINSI ; 
     FINSI ; 
   
 * CAS 2D : VERIFICATIONS EN CAS DE FISSURE CIRCULAIRE 
     SI (EGA GDIME 2) ; 
 * BOOLEEN POUR ROTATION (SINON C'EST FORCEMENT UNE TRANSLATION) 
         BOOL.'ROTATION' = EXIS SUPTAB 'POINT_CENTRE' ; 
         SI BOOL.'ROTATION' ; 
             PCENTRE = SUPTAB.'POINT_CENTRE' ; 
         FINSI ; 
     FINSI ; 
   
 FINSI ; 
   
   
 * II - EXTRACTION DES MAILLAGES NECESSAIRES 
 * ----------------------------------------- 
   
 * CREATION DU MAILLAGE GLOBAL A BOUGER : MBOUGER 
 MBOUGER = FRON1 ; 
 REPE IBOUG COUCHE ; 
     MBOUGER = MAILLAGE ELEM 'APPUYE' 'LARGEMENT' MBOUGER ; 
 FIN IBOUG ; 
 * CREATION DU SUPPORT GLOBAL DU CHAMP THETA : MAIL 
 MAIL = MAILLAGE ELEM 'APPUYE' 'LARGEMENT' MBOUGER ; 
   
 * EN 3D MASSIF ON DECOUPE LE MAILLAGE EN TRANCHES 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
 * ON ORDONNE LE FRONT DE FISSURE 
     FRON1 = ORDO FRON1 ; 
     PINIT = FRON1 'POIN' 'INIT' ; 
     PFINA = FRON1 'POIN' 'FINA' ; 
     FDEBOUCH = NEG (NOEU PINIT) (NOEU PFINA) ; 
 * DETERMINATION DES NOEUDS DU FRONT DANS L'ORDRE DE PARCOURT 
     TPFISS = TABL ; 
     REPE IELEM (NBEL FRON1) ; 
         ELEM1 = FRON1 ELEM &IELEM ; 
         PENLE = MANU 'POI1' (ELEM1 POIN 'FINA') ; 
         PELEM1 = CHAN 'POI1' ELEM1 ; 
         PAJOU = PELEM1 DIFF PENLE ; 
         REPE IAJOU (NBNO PAJOU) ; 
             TPFISS.((DIME TPFISS) + 1) = PAJOU 'POIN' &IAJOU ; 
         FIN IAJOU ; 
     FIN IELEM ; 
     TPFISS.((DIME TPFISS) + 1) = PFINA ; 
 * DECOUPAGE EN TRANCHES DE MAIL ET MBOUGER 
     TMAIL = COPI TPFISS ; 
     N1 = (NBNO (FRON1 ELEM 1)) - 1 ; 
     REPE ICOUCH (COUCHE + 1) ; 
         REPE IELEM (NBEL FRON1) ; 
             I1 = (N1*(&IELEM - 1)) + 1 ; 
             I2 = I1 + N1 ; 
             SURF1 = TMAIL.I1 ; 
             SURF2 = TMAIL.I2 ; 
             VOL1 = MAILLAGE ELEM 'APPUYE' 'LARGEMENT' SURF1 ; 
             VOL2 = MAILLAGE ELEM 'APPUYE' 'LARGEMENT' SURF2 ; 
             VOL3 = VOL1 INTE VOL2 ; 
             DVOL3 = ENVE VOL3 ; 
             SURF1 = DVOL3 ELEM 'APPUYE' 'LARGEMENT' SURF1 ; 
             SURF2 = DVOL3 ELEM 'APPUYE' 'LARGEMENT' SURF2 ; 
             SURF12 = SURF1 INTE SURF2 ; 
             SURF1 = SURF1 DIFF SURF12 ; 
             SURF2 = SURF2 DIFF SURF12 ; 
             TMAIL.I1 = SURF1 ; 
             SI (EGA N1 2) ; 
                 MIL1 = (CHAN 'POI1' VOL3) DIFF (CHAN 'POI1' (SURF1 ET SURF2)) ; 
                 TMAIL.(I1 + 1) = MIL1 ; 
             FINSI ; 
         FIN IELEM ; 
         TMAIL.(DIME TMAIL) = SURF2 ; 
         SI (EGA &ICOUCH COUCHE) ; 
             TMBOUGER = COPI TMAIL ; 
         FINSI ; 
     FIN ICOUCH ; 
 * SI LE FRONT EST FERME ON ENLEVE LES DERNIERS INDICES DES TABLEAUX 
 * CAR ILS SONT IDENTIQUES AUX PREMIERS 
     SI (NON FDEBOUCH) ; 
         OTER TPFISS (DIME TPFISS) ; 
         OTER TMAIL (DIME TMAIL) ; 
         OTER TMBOUGER (DIME TMBOUGER) ; 
     FINSI ; 
 * ON AJOUTE LES MAILLAGES GLOBAUX 
     NPFISS = DIME TPFISS ; 
     TPFISS.(NPFISS + 1) = FRON1 ; 
     TMAIL.(NPFISS + 1) = MAIL ; 
     TMBOUGER.(NPFISS + 1) = MBOUGER ; 
 FINSI ; 
   
   
 * III - CALCUL DU CHAMP THETA/PI 
 * ------------------------------ 
   
 SI CALCUL ; 
   
 * III.1 - DIRECTION DE PROPAGATION 
 * ******************************** 
   
 * CAS 2D OU 3D COQUE : 
 * ******************** 
     SI ((EGA GDIME 2) OU BOOL.'COQ') ; 
 * ON DETERMINE LA DIRECTION DE PROPAGATION 
         FISS1 = CRACK ELEM 'APPUYE' 'LARGEMENT' FRON1 ; 
         NELEM = NBEL FISS1 ; 
 * ON FAIT LA MOYENNE SUR LES DEUX POINTS QUI NE SONT PAS FRON1 
 * POUR LE CAS OU LES DEUX LEVRES SONT MODELISEES 
         VECTEUR = VNUL ; 
         REPE IELEM NELEM ; 
             SEG1 = FISS1 ELEM &IELEM ; 
             PINIFIN = ('POIN' SEG1 'INIT') ET ('POIN' SEG1 'FINA') ; 
             P1 = 'POIN' ('DIFF' PINIFIN ('MANU' 'POI1' FRON1)) 1 ; 
             VEC1 = FRON1 MOIN P1 ; 
             VECTEUR = VECTEUR PLUS VEC1 ; 
         FIN IELEM ; 
         VECTEUR = VECTEUR / NELEM ; 
     FINSI ; 
   
 * CAS 3D MASSIF : 
 * *************** 
     SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
 * DETERMINATION DU VECTEUR NORMAL AU PLAN DE FISSURE 
         SEG1 = (CHAN 'LIGNE' CRACK) ELEM 'APPUYE' 'LARGEMENT' PINIT ; 
         SEG1 = SEG1 DIFF (SEG1 INTE FRON1) ; 
         PMOY = PINIT MOIN PINIT ; 
         REPE IELEM (NBEL SEG1) ; 
             ELEM1 = SEG1 ELEM &IELEM ; 
             PINIFIN = ('POIN' ELEM1 'INIT') ET ('POIN' ELEM1 'FINA') ; 
             P1 = 'POIN' ('DIFF' PINIFIN ('MANU' 'POI1' PINIT)) 1 ; 
             PMOY = PMOY PLUS P1 ; 
         FIN IELEM ; 
         PMOY = PMOY / (NBEL SEG1) ; 
         VEC1 = PINIT MOIN PMOY ; 
         VEC2 = TPFISS.(2) MOIN TPFISS.(1) ; 
         VNORM = VEC1 PVEC VEC2 ; 
         VNORM = VNORM / (NORM VNORM) ; 
   
 * PASSAGE DU TUYAU EN PLAQUE 
         SI BOOL.'TTD' ; 
             DEPL MAILLAGE 'COOR' 'CYLI' PAXEZ1 PAXEZ2 PAXEZ3 ; 
         FINSI ; 
   
 * DIRECTION D'AVANCEE DE FISSURE EN CHAQUE POINT DU FRONT 
         TVECTEUR = TABL ; 
         LN1 = LECT NPFISS 1 PAS 1 (NPFISS - 1) ; 
         LN2 = LECT 2 PAS 1 NPFISS 1 ; 
         SI FDEBOUCH ; 
 * SI LE FRONT EST DEBOUCHANT ON ENLEVE LE PREMIER ET LE DERNIER NOEUD... 
             LN1 = ENLE LN1 (LECT 1 NPFISS) ; 
             LN2 = ENLE LN2 (LECT 1 NPFISS) ; 
             I0 = 1 ; 
 * ...ET ON LES TRAITE ICI 
             LENT1 = LECT 1 NPFISS ; 
             REPE IENT 2 ; 
 * ON BOUCLE SUR LE PREMIER ET LE DERNIER NOEUD 
                 INOEU = EXTR LENT1 &IENT ; 
                 P1 = TPFISS.INOEU ; 
                 SEG1 = (CHAN 'LIGNE' CRACK) ELEM 'APPUYE' 'LARGEMENT' P1 ; 
                 SEG1 = SEG1 DIFF (SEG1 INTE FRON1) ; 
                 PMOY = P1 MOIN P1 ; 
                 REPE IELEM (NBEL SEG1) ; 
 * ON BOUCLE SUR LE OU LES SEGMENTS APPUYES SUR P1 (1 OU 2 LEVRES DONNEES) 
                     ELEM1 = SEG1 ELEM &IELEM ; 
                     PINIFIN = (ELEM1 POIN 'INIT') ET (ELEM1 POIN 'FINA') ; 
                     P2 = (DIFF (CHAN 'POI1' ELEM1) (MANU 'POI1' P1)) POIN 'PROC' P1 ; 
                     PMOY = PMOY PLUS P2 ; 
                 FIN IELEM ; 
                 PMOY = PMOY / (NBEL SEG1) ; 
                 TVECTEUR.INOEU = P1 MOIN PMOY ; 
             FIN IENT ; 
         SINON ; 
             I0 = 0 ; 
         FINSI ; 
         REPE IPFISS (DIME LN1) ; 
 * POINTS P1 ET P2 DE PART ET D'AUTRE DU POINT &IPFISS 
             P1 = TPFISS.(EXTR LN1 &IPFISS) ; 
             P2 = TPFISS.(EXTR LN2 &IPFISS) ; 
 * ON OBTIENT LE VECTEUR TANGENT AU FRONT 
             VTANG = (P2 MOIN P1)/2. ; 
 * LE PRODUIT VECTORIEL AVEC VNORM DONNE LA DIRECTION DE PROPAGATION 
             TVECTEUR.(&IPFISS + I0) = VTANG PVEC VNORM ; 
         FIN IPFISS ; 
   
 * ON AJOUTE LE CHAMP GLOBAL DE DIRECTION DE PROPAGATION 
         LNORM = PROG ; 
 * ON BOUCLE SUR LES NOEUDS POUR DETERMINER LE MIN DES NORMES DES VECTEURS 
         REPE IPFISS NPFISS ; 
             LNORM = LNORM ET (PROG (NORM TVECTEUR.&IPFISS)) ; 
         FIN IPFISS ; 
         MINNORM = MINI LNORM ; 
 * PUIS ON REBOUCLE POUR CREER LE CHPO DE DIRECTION 
         GDIR = 'VIDE' 'CHPOINT'/'DIFFUS' ; 
         REPE IPFISS NPFISS ; 
             N1 = MINNORM / (EXTR LNORM &IPFISS) ; 
             X Y Z = COOR (TVECTEUR.&IPFISS * N1) ; 
             CHPO1 = MANU 'CHPO' TMAIL.&IPFISS MUI (PROG X Y Z) 'NATURE' 'DIFFUS' ; 
             GDIR = GDIR + CHPO1 ; 
         FIN IPFISS ; 
         TVECTEUR.(NPFISS + 1) = GDIR ; 
   
 * ON REPASSE LA PLAQUE EN TUYAU 
         SI BOOL.'TTD' ; 
             DEPL MAILLAGE 'COOR' 'CART' ; 
         FINSI ; 
   
         VECTEUR = GDIR ; 
     FINSI ; 
   
   
 * III.2 - CHAMP THETA GLOBAL 
 * ************************** 
   
 * CONFIGURATION INITIALE 
     CONF0 = FORM ; 
   
 * ON COMMENCE PAR DEPLACER LES NOEUDS DE MBOUGER 
     SI BOOL.'ROTATION' ; 
 * CAS DE LA ROTATION 
         ANG1 = .01 ; 
         SI (EGA GDIME 2) ; 
             DEPL 'TOUR' MBOUGER ANG1 PCENTRE ; 
         SINON ; 
             SI BOOL.'RC' ; 
                 DEPL OPER1 MAILLAGE SUPTAB.'CHPOINT_TRANSFORMATION' ; 
             FINSI ; 
             DEPL 'TOUR' MBOUGER ANG1 POINT_1 POINT_2 ; 
             SI BOOL.'RC' ; 
                 DEPL OPER1 MAILLAGE (-1.*(SUPTAB.'CHPOINT_TRANSFORMATION')) ; 
             FINSI ; 
         FINSI ; 
     SINON ; 
 * CAS DE LA TRANSLATION 
         SI BOOL.'TTD' ; 
             DEPL MAILLAGE 'COOR' 'CYLI' PAXEZ1 PAXEZ2 PAXEZ3 ; 
         FINSI ; 
         DEPL 'PLUS' MBOUGER VECTEUR ; 
         SI BOOL.'TTD' ; 
             DEPL MAILLAGE 'COOR' 'CART' ; 
         FINSI ; 
     FINSI ; 
 * ON CREE MAIL2 
     MAIL2 = MAIL PLUS VNUL ; 
 * PUIS ON INVERSE LA TRANSFORMATION 
     SI BOOL.'ROTATION' ; 
 * CAS DE LA ROTATION 
         SI (EGA GDIME 2) ; 
             DEPL 'TOUR' MBOUGER (0. - ANG1) PCENTRE ; 
         SINON ; 
             SI BOOL.'RC' ; 
                 DEPL OPER1 MAILLAGE SUPTAB.'CHPOINT_TRANSFORMATION' ; 
             FINSI ; 
             DEPL 'TOUR' MBOUGER (0. - ANG1) POINT_1 POINT_2 ; 
             SI BOOL.'RC' ; 
                 DEPL OPER1 MAILLAGE (-1.*(SUPTAB.'CHPOINT_TRANSFORMATION')) ; 
             FINSI ; 
         FINSI ; 
     SINON ; 
 * CAS DE LA TRANSLATION 
         SI BOOL.'TTD' ; 
             DEPL MAILLAGE 'COOR' 'CYLI' PAXEZ1 PAXEZ2 PAXEZ3 ; 
         FINSI ; 
         DEPL 'MOIN' MBOUGER VECTEUR ; 
         SI BOOL.'TTD' ; 
             DEPL MAILLAGE 'COOR' 'CART' ; 
         FINSI ; 
     FINSI ; 
   
 * CHAMP THETA GLOBAL 
     THETA = MAIL2 MOIN MAIL ; 
   
 * ON REND THETA COMPATIBLE AVEC LES RELATIONS DE CONFORMITE DU MODELE 
     THETA = CFND THETA OBJUTI.'MOD_MEC' ; 
   
 * ON REPREND LA CONFIGURATION INITIALE DANS LE CAS OU ELLE AURAIT ETE 
 * MODIFIEE PAR DEPL 
     FORM CONF0 ; 
   
 * STOCKAGE DANS SUPTAB 
     SUPTAB.(CHAI 'CHAMP_' RESULT) = THETA ; 
   
 FINSI ; 
   
   
 * IV - CREATION ET REMPLISSAGE DE LA TABLE TTHETA 
 * ----------------------------------------------- 
   
 * FONCTIONS D'INTERPOLATION 
 TINTER = TABL ; 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
     REPE IPFISS NPFISS ; 
         SI (DANS TPFISS.&IPFISS NOAV) ; 
             FINTER = MANU 'CHPO' TMBOUGER.&IPFISS 1 'SCAL' 1. 'NATURE' 'DISCRET' ; 
             TINTER.&IPFISS = FINTER ; 
         FINSI ; 
     FIN IPFISS ; 
 SINON ; 
     TINTER.(1) = MANU 'CHPO' MBOUGER 1 'SCAL' 1. 'NATURE' 'DISCRET' ; 
 FINSI ; 
 * TABLE TTHETA 
 TTHETA = TABL ; 
 TIND = INDE TINTER ; 
 REPE IIND (DIME TIND) ; 
     FINTER = TINTER.(TIND.&IIND) ; 
     THETI = FINTER * THETA ; 
     FFRON = REDU FINTER FRON1 ; 
     TTHETA.FFRON = THETI ; 
 FIN IIND ; 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
     TTHETA.'GLOBAL' = THETA ; 
 FINSI ; 
   
   
 * V - NORMALISATION DU CHAMP THETA 
 * -------------------------------- 
   
 * CE QU'ON VEUT C'EST QUE LA SURFACE DE FISSURE CREEE PAR LE MOUVEMENT INFINITESIMAL 
 * EPS1*THETA SOIT EGALE A 2.*EPS1 LORSQUE EPS1 << 1. 
 * NB : ON VEUT 2.*EPS1 CAR LA FISSURE A FORCEMENT DEUX LEVRES, MEME SI UNE SEULE 
 * EST MODELISEE ! 
   
 * PARTIE DE LA FISSURE QUI AVANCE 
 CRACK1 = CRACK ELEM 'APPUY' 'LARGEMENT' MBOUGER ; 
 * MODELE THERMIQUE ISOTROPE POUR INTEGRER SUR LES LEVRES DE FISSURE 
 * AVANTAGE : FONCTIONNE DANS TOUS LES CAS 
 * (2D, 3D ET PAS BESOIN DE MULTIPLIER PAR 2*PI*R EN AXISYMETRIQUE) 
 MODTH = MODE CRACK1 'THERMIQUE' ; 
 CHML1 = MANU 'CHML' MODTH 'SCAL' 1. ; 
 * ON CALCULE L'AIRE INITIALE 
 A0 = INTG CHML1 MODTH ; 
 * ON DETERMINE LA DIMENSION CARACTERISTIQUE LMIN DU MAILLAGE DU FRONT 
 LIG1 = CHAN 'LIGNE' CRACK1 ; 
 MES1 = MESU LIG1 'DENS' ; 
 LMIN = MINI MES1 ; 
 * PETIT FLOTTANT POUR QUE LE MOUVEMENT SOIT INFINITESIMAL 
 EPS1 = 1.E-4 ; 
 * BOUCLE SUR LES CHAMPS 
 TIND = INDE TTHETA ; 
 REPE ICHAM (DIME TIND) ; 
     THETI = TTHETA.(TIND.&ICHAM) ; 
 * ON CREE UN CHAMP THETI DONT LA NORME EST PROCHE DE LA DIMENSION DES ELEMENTS 
     NTHETI = (PSCA THETI THETI MUI MUI)**0.5 ; 
     THETI = THETI * LMIN / (MAXI NTHETI) ; 
 * ON DEPLACE LES NOEUDS, ON CALCULE L'AIRE, PUIS ON INVERSE LA TRANSFORMATION 
     DEPL MBOUGER 'PLUS' (EPS1*THETI) ; 
     A1 = INTG CHML1 MODTH ; 
     DEPL MBOUGER 'MOIN' (EPS1*THETI) ; 
 * DELTA_A EST LA SURFACE DE FISSURE CREEE PAR LEVRE 
     DELTA_A = (A1 - A0) / EPS1 ; 
     SI BOOL.'COQ' ; 
 * POUR LES COQUES IL FAUT MULTIPLIER PAR L'EPAISSEUR 
         DELTA_A = DELTA_A * SUPTAB.'EPAISSEUR' ; 
     FINSI ; 
     THETI = THETI * 2. / DELTA_A ; 
 * ON REND LES THETI COMPATIBLES AVEC LES RELATIONS DE CONFORMITE DU MODELE 
     THETI = CFND THETI OBJUTI.'MOD_MEC' ; 
     TTHETA.(TIND.&ICHAM) = THETI ; 
 FIN ICHAM ; 
 * STOCKAGE DANS SUPTAB 
 SUPTAB.(CHAI 'TAB_' RESULT) = TTHETA ; 
   
   
 * ============================================================================= 
 *              PARTIE 2 : EXTRACTION DE LA DIRECTION DE PROPAGATION 
 *              ---------------------------------------------------- 
   
 SI (NON (EXIS OBJUTI 'DIRECTION1')) ; 
 * ON EXTRAIT LA DIRECTION DE PROPAGATION ET LES NORMALES DU CHAMP THETA 
     CHTHETA = SUPTAB.'CHAMP_THETA' ; 
     DIR1 = REDU CHTHETA (SUPTAB.'FRONT_FISSURE') ; 
     NDIR1 = (PSCA DIR1 DIR1 MUI MUI)**0.5 ; 
     DIR1 = DIR1 / NDIR1 ; 
     SI (NON BOOL.'COQ') ; 
         SI (EXIS SUPTAB 'LEVRE_SUPERIEURE') ; 
             F1 = PRES 'MASS' MOD_MEC SUPTAB.'LEVRE_SUPERIEURE' 1. ; 
         SINON ; 
             F1 = PRES 'MASS' MOD_MEC SUPTAB.'LEVRE_INFERIEURE' -1. ; 
         FINSI ; 
         DIR2 = REDU F1 (SUPTAB.'FRONT_FISSURE') ; 
         DIR2 = EXCO DIR2 MFI MUI 'NOID' ; 
         NDIR2 = (PSCA DIR2 DIR2 MUI MUI)**0.5 ; 
         DIR2 = DIR2 / NDIR2 ; 
         SI (EGA GDIME 3) ; 
             DIR3 = PVEC DIR1 DIR2 MUI MUI MUI ; 
         FINSI ; 
     FINSI ; 
 * ON STOCKE LES DIRECTIONS DANS OBJUTI 
     OBJUTI.'DIRECTION1' = DIR1 ; 
     SI (NON BOOL.'COQ') ; 
         OBJUTI.'DIRECTION2' = DIR2 ; 
         SI (EGA GDIME 3) ; 
             OBJUTI.'DIRECTION3' = DIR3 ; 
         FINSI ; 
     FINSI ; 
 FINSI ; 
   
   
 * ============================================================================= 
 *              PARTIE 3 : APPEL RECURSIF POUR LE CALCUL DU CHAMP PI 
 *              ---------------------------------------------------- 
   
 * SI L'OBJECTIF EST 'DJ/DA' ET QU'ON A PAS ENCORE DETERMINE LE CHAMP PI, ALORS 
 * ON RELANCE CH_THETA SUR UNE COPIE DE SUPTAB AVEC LES MODIFICATIONS 
 * NECESSAIRES, PUIS ON EXTRAIT LES INDICES 'CHAMP_PI' ET 'TAB_PI' DU RESULTAT 
 SI (BOOL.'DJ/DA' ET (NON (EXIS SUPTAB 'TAB_PI'))) ; 
     SUPTAB2 = COPI SUPTAB ; 
     SI (NON (EXIS SUPTAB 'FRONT_FISSURE_2')) ; 
         SUPTAB2.'COUCHE' = (SUPTAB.'COUCHE') - 1 ; 
     SINON ; 
         SUPTAB2.'FRONT_FISSURE' = SUPTAB.'FRONT_FISSURE_2' ; 
         SUPTAB2.'FISSURE' = SUPTAB.'FISSURE_2' ; 
     FINSI ; 
     CH_THETA SUPTAB2 OBJUTI BOOL ; 
     SUPTAB.'CHAMP_PI' SUPTAB.'TAB_PI' = SUPTAB2.'CHAMP_PI' SUPTAB2.'TAB_PI' ; 
 FINSI ; 
   
 FINP ; 
 * G_CALCUL  PROCEDUR  JB251061  22/09/05    21:15:01     11444 
 DEBP G_CALCUL SUPTAB*'TABLE' OBJUTI*'TABLE' BOOL*'TABLE'; 
 * ============================================================================= 
 *           PROCEDURE DE CALCUL DES INTEGRALES NECESSAIRES A G_THETA 
 *           -------------------------------------------------------- 
 * 
 * DESCRIPTION : EFFECTUE LE CALCUL DE L'INTEGRALE SPECIFIEE DANS L'INDICE 
 *               'OBJECTIF' DE LA TABLE SUPTAB. 
 *               ON BOUCLE SUR LES PAS DE CALCUL, SUR LES INTEGRALES A CALCULER 
 *               ET ENFIN SUR LES NOEUDS DU FRONT DE FISSURE. 
 * ============================================================================= 
   
 * QUELQUES OBJETS UTILES 
   
 MOD_MEC_R = OBJUTI.'MOD_MEC_R'; 
 MAILMOD = EXTR MOD_MEC_R 'MAILLAGE'; 
 SI BOOL.'DECOUPLAGE'; 
     CH_AUX = SUPTAB.'CH_AUX'; 
 FINSI; 
 * CHAMPS NULS 
 CMD000 = CHAN 'NOEUD' MOD_MEC_R (ZERO MOD_MEC_R 'DEPLACEM'); 
 CMD001 = CHAN 'STRESSES' MOD_MEC_R (ZERO MOD_MEC_R 'DEPLACEM'); 
 GRA000 = ZERO MOD_MEC_R 'GRADIENT'; 
 FOR000 = CHAN 'CHPO' MOD_MEC_R (ZERO MOD_MEC_R 'FORCES  '); 
 DEP000 = CHAN 'CHPO' MOD_MEC_R (ZERO MOD_MEC_R 'DEPLACEM'); 
 SI (EGA GMODE 'PLANGENE'); 
     FOR000 = MANU 'CHPO' (EXTR MOD_MEC_R 'MAIL') 2 'FX' 0. 
                 'FY' 0. 'TITR' 'FORCES  ' 'NATURE' 'DIFFUS'; 
     FOR000 = FOR000 ET (MANU 'CHPO' (VALE 'MODE' 'PLANGENE') 
                 3 'FZ' 0. 'MX' 0. 'MY' 0. 
                 'TITR' 'FORCES  ' 'NATURE' 'DIFFUS'); 
     DEP000 = MANU 'CHPO' (EXTR MOD_MEC_R 'MAIL') 2 'UX' 0. 
                 'UY' 0. 'TITR' 'DEPLACEM' 'NATURE' 'DIFFUS'; 
     DEP000 = DEP000 ET (MANU 'CHPO' (VALE 'MODE' 'PLANGENE') 
                 3 'UZ' 0. 'RX' 0. 'RY' 0. 
                 'TITR' 'DEPLACEM' 'NATURE' 'DIFFUS'); 
 FINSI; 
 * EN CAS D'UN MODELE DE PRESSION 
 SI BOOL.'MODE_PRES'; 
     MODCHA = EXTR OBJUTI.'MOD_TOT' 'FORM' 'CHARGEMENT'; 
     MODPRE = EXTR MODCHA 'COMP' 'PRESSION'; 
     SI (NON BOOL.'PASAPAS'); 
         MATPRE = REDU (SUPTAB.'PRESSION') MODPRE; 
     FINSI; 
     MAILPTOT = EXTR MODPRE 'MAIL'; 
     MAILPF = INTE MAILPTOT (SUPTAB.'FISSURE'); 
 FINSI; 
   
   
 SI (BOOL.'COQ' ET BOOL.'EL_QUA'); 
    MAT2 = MAT_INST; 
 SINON; 
    MAT2 = TEXT '        '; 
 FINSI; 
 SI BOOL.'COQ'; 
     MATCOMP = EXTR MAT_MEC 'COMP'; 
     MOTCARA = MOTS 'EPAI' 'EXCE' 'DIM3'; 
     CAR1 = EXCO MAT_MEC MOTCARA 'NOID'; 
 SINON; 
     CAR1 = TEXT '   '; 
 FINSI; 
   
 NBG = OBJUTI.'NBG'; 
   
 * FRONT DE FISSURE EN POI1 
 FF = SUPTAB.'FRONT_FISSURE'; 
 SI (EGA (TYPE FF) 'POINT'); 
     FF1 = MANU 'POI1' FF; 
 FINSI; 
 SI (EGA (TYPE FF) 'MAILLAGE'); 
     FF1 = CHAN 'POI1' FF; 
 FINSI; 
   
 * QUELQUES MOTS POUR SIMPLIFIER L'ECRITURE 
   
 NEXTR = GDIME; 
 SI BOOL.'COQ'; 
     NEXTR = 6; 
 FINSI; 
 MUI = EXTR (EXTR MOD_MEC_R 'DEPL') (LECT 1 PAS 1 NEXTR); 
 MFI = EXTR (EXTR MOD_MEC_R 'FORC') (LECT 1 PAS 1 NEXTR); 
 MGI = EXTR MOD_MEC_R 'GRAD'; 
 MU1 = EXTR MUI 1 ; MU2 = EXTR MUI 2 ; MU3  = MOT 'UZ'; 
 MF1 = EXTR MFI 1 ; MF2 = EXTR MFI 2 ; MF3  = MOT 'FZ'; 
 MFA1= MOT  'FAX' ; MFA2 = MOT 'FAY' ; MFA3 = MOT 'FAZ'; 
 GR1 GR2 GR3 = (EXTR MGI 1) (EXTR MGI 2) (EXTR MGI 3); 
 GR4 GR5 GR6 = (EXTR MGI 4) (EXTR MGI 5) (EXTR MGI 6); 
 GR7 GR8 GR9 = (EXTR MGI 7) (EXTR MGI 8) (EXTR MGI 9); 
 SM1 = MOT  'SMXX' ; SM2  = MOT 'SMYY' ; SM3  = MOT 'SMZZ'; 
 SM4 = MOT  'SMXY' ; SM5  = MOT 'SMXZ' ; SM6  = MOT 'SMYZ'; 
 EP1 = MOT  'EPXX' ; EP2  = MOT 'EPYY' ; EP3  = MOT 'EPZZ'; 
 EP4 = MOT  'GAXY' ; EP5  = MOT 'GAXZ' ; EP6  = MOT 'GAYZ'; 
 SI (EGA GMODE 'AXIS'); 
    MU3 = MOT 'UT'; 
    SM1 = MOT 'SMRR' ; SM2 = MOT 'SMZZ' ; SM3 = MOT 'SMTT'; 
    SM4 = MOT 'SMRZ'; 
    EP1 = MOT 'EPRR' ; EP2 = MOT 'EPZZ' ; EP3 = MOT 'EPTT'; 
    EP4 = MOT 'GARZ'; 
 FINSI; 
 *BP: PETIT AJOUT DE NOM DE COMPOSANTE DE CHPOINT 
 SI (BOOL.'J' OU BOOL.'J_DYNA') ; MOCOMP = 'J' ;    FINSI; 
 SI (BOOL.'C*' OU BOOL.'C*H') ; MOCOMP = 'C*' ;   FINSI; 
 SI BOOL.'DJ/DA' ; MOCOMP = 'DJDA' ; FINSI; 
   
 * VALEURS INITIALES 
   
 S10  = 0. ; S20  = 0. ; S30  = 0. ; S40  = 0. ; S41 = 0. ; S50  = 0.; 
 S60  = 0. ; S70  = 0. ; S80  = 0. ; S90  = 0. ; S100 = 0.; 
 S110 = 0. ; S120 = 0. ; S130 = 0. ; S140 = 0. ; S141 = 0.; 
 S150 = 0. ; S160 = 0. ; S170 = 0. ; S180 = 0.; 
 S190 = 0. ; S200 = 0. ; S210 = 0. ; S220 = 0.; 
   
   
 * DETERMINATION DE LA TAILLE DE LA 1ERE COLONNE A AFFICHER 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')); 
     NDEC = DIME 'GLOBAL'; 
     REPE INO (NBEL FF1); 
         PM = (FF1 ELEM &INO) POIN 1; 
         NNO = NOEU PM; 
         NDEC1 = DIME (CHAI NNO); 
         NDEC = MAXI NDEC NDEC1; 
     FIN INO; 
 SINON; 
     PM = FF1 POIN 1; 
     NNO = NOEU PM; 
     NDEC = DIME (CHAI NNO); 
 FINSI; 
   
   
 * TITRES A AFFICHER SELON LE PROBLEME TRAITER 
 * ******************************************* 
   
 * TITRE GENERAL 
 NMESS = OBJUTI.'NMESS'; 
 MOBJ = MOT SUPTAB.'OBJECTIF'; 
 CHINT = CHAI MOBJ; 
 SI (BOOL.'J_DYNA'); 
     MOBJ = CHAI 'J'; 
 SINON; 
     SI (BOOL.'DJ/DA'); 
         SI (EXIS SUPTAB 'FISSURE_2'); 
             MOBJ = CHAI 'CROISEE DJi/DAj'; 
             CHINT = CHAI 'DJi/DAj'; 
         FINSI; 
     FINSI; 
 FINSI; 
 SI BOOL.'THER'; 
     CHATHE = CHAI ' THERMO-'; 
 SINON; 
     CHATHE = CHAI ' '; 
 FINSI; 
 SI BOOL.'DECOUPLAGE'; 
     CHACAL = CHAI 'SEPARATION DES F.I.C. EN' CHATHE 'ELASTICITE'; 
     CHINT = CHAI 'Ki'; 
 SINON; 
     SI BOOL.'PASAPAS'; 
         SI (BOOL.'J' OU BOOL.'DJ/DA'); 
             CHAMAT = CHAI 'ELASTO-PLASTICITE'; 
         SINON; 
             SI BOOL.'J_DYNA'; 
                 CHAMAT = CHAI 'ELASTO-DYNAMIQUE'; 
             SINON; 
                 CHAMAT = CHAI 'VISCO-PLASTICITE'; 
             FINSI; 
         FINSI; 
         CHACAL = CHAI 'INTEGRALE' ' ' MOBJ ' EN' CHATHE CHAMAT; 
         SI (BOOL.'C*H'); 
             CHINT = CHAI 'C*(H)'; 
         FINSI; 
     SINON; 
         CHACAL = CHAI 'INTEGRALE' ' ' MOBJ ' EN ELASTICITE'; 
     FINSI; 
 FINSI; 
 * EN-TETE DES RESULTATS 
 CTITR = CHAI; 
 NCTITR = 0; 
 SI BOOL.'PASAPAS'; 
     CHPAS = CHAI 'No.Pas'; 
     NPMAX = NBG + NBDEP; 
     NDPAS = NCTITR + (MAXI (DIME (CHAI NPMAX)) (DIME CHPAS)) + 1; 
     CTITR = CHAI CTITR CHPAS*NDPAS; 
     NCTITR = DIME CTITR; 
 FINSI; 
 SI BOOL.'DECOUPLAGE'; 
     NDDEC = NCTITR + 5; 
     CTITR = CHAI CTITR 'Mode'*NDDEC; 
     NCTITR = DIME CTITR; 
 FINSI; 
 SI BOOL.'COQ'; 
     NDCOQ = NCTITR + 7; 
     CTITR = CHAI CTITR 'Plan'*NDCOQ; 
     NCTITR = DIME CTITR; 
 FINSI; 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')); 
     SI BOOL.'XFEM'; 
         CHFRO = CHAI 'Int.'; 
     SINON; 
         CHFRO = CHAI 'Noeud'; 
     FINSI; 
     NDFRO = 6; 
     REPE INO (NBEL FF1); 
         PM = (FF1 ELEM &INO) POIN 1; 
         NNO = NOEU PM; 
         NDFRO = MAXI NDFRO (DIME (CHAI NNO)); 
     FIN INO; 
     NDFRO = NDFRO + NCTITR + 1; 
     CTITR = CHAI CTITR CHFRO*NDFRO; 
     NCTITR = DIME CTITR; 
 FINSI; 
 NFLOT = 11 + 2; 
 NDMEC = (DIME CTITR) + NFLOT; 
 CTITR = CHAI CTITR 'Mecanique'*NDMEC; 
 NDTHE = NDMEC + NFLOT; 
 CTITR = CHAI CTITR 'Thermique'*NDTHE; 
 NDVOL = NDTHE + NFLOT; 
 CTITR = CHAI CTITR 'Volumique'*NDVOL; 
 NDINT = NDVOL + NFLOT; 
 CTITR = CHAI CTITR CHINT*NDINT; 
 NDTIT = (NDINT / 2) + ((DIME CHACAL) / 2); 
 SAUT 'LIGNE'; 
 MESS CHACAL*NDTIT; 
 SLIGN = CHAI '_'; 
 REPE ICHAR ((DIME CHACAL) - 1); 
     SLIGN = CHAI SLIGN '_'; 
 FIN ICHAR; 
 MESS SLIGN*NDTIT; 
 SAUT 'LIGNE'; 
 NDCHA = (NDINT / 2) + (45 / 2); 
 MESS 'Detail des contributions de chaque chargement'*NDCHA; 
 MESS '_____________________________________________'*NDCHA; 
 MESS; 
 MESS CTITR; 
 MESS; 
   
   
 *********************************************** 
 *********************************************** 
 ********* BOUCLE SUR LE PAS DE CALCUL ********* 
 *********************************************** 
 *********************************************** 
   
 SI ((EGA GDIME 3) OU BOOL.'PASAPAS' OU BOOL.'DECOUPLAGE'); 
     TABRES = TABL SUPTAB.'RESULTATS'; 
 FINSI; 
   
 REPE BOUCEXT NBDEP; 
   
     IABC = NBG + &BOUCEXT; 
   
 * DECLARATION DES TABLES STOCKANT LES RESULTATS POUR LE PAS DE TEMPS IABC 
     SI BOOL.'PASAPAS'; 
         SI (EGA GDIME 3); 
             SI  BOOL.'DECOUPLAGE'; 
                 REPE IRUPT GDIME; 
                     TABRES.(EXTR 'III' 1 &IRUPT).IABC = TABL; 
                 FIN IRUPT; 
             SINON; 
                 TABRES.IABC = TABL; 
             FINSI; 
         FINSI; 
         SUPTAB.'CHPO_RESULTATS'.IABC = VIDE 'CHPOINT'/'DISCRET'; 
         SUPTAB.'CHAM_RESULTATS'.IABC = VIDE 'MCHAML'; 
     FINSI; 
   
 *************************************************** 
 ** DEPLACEMENTS,CONTRAINTES ... A L INSTANT INST ** 
 *************************************************** 
   
     SI BOOL.'PASAPAS'; 
 * SOLUTION_PASAPAS 
         SI BOOL.'PERSO1'; 
 * CAS PERSO1 
             INST   =  ESTIM . 'TEMPS'; 
             DEPINT = (ESTIM . 'DEPLACEMENTS') REDU ELTETA; 
             SIGF   = (ESTIM . 'CONTRAINTES' ) REDU MOD_MEC_R; 
             SI (BOOL.'GRANDS_DEP' ET (NON BOOL.'ROT_RIG')); 
                 SIGF = 'CAPI' SIGF DEPINT MOD_MEC_R; 
             FINSI; 
             SI BOOL.'ROT_RIG'; 
                 SI (NON (EXIS (SUPTAB.'ROTATION_RIGIDIFIANTE') IABC)); 
                     MESS 'ERREUR : Le deplacement du a une rotation'; 
                     MESS '         rigidifiante au pas ' IABC ' n est pas' 
                     MESS '         donne'; 
                     ERRE 21 ; QUIT G_THETA; 
                 FINSI; 
                 DEPINT = DEPINT - 
                 (REDU SUPTAB.'ROTATION_RIGIDIFIANTE'.IABC ELTETA); 
             FINSI; 
             SI (EXIS ESTIM 'VARIABLES_INTERNES'); 
                 VARF = (ESTIM . 'VARIABLES_INTERNES') REDU MOD_MEC_R; 
             SINON; 
                 VARF = ZERO MOD_MEC_R 'VARINTER' ;; 
             FINSI; 
             SI BOOL.'C*'; 
                 SI (EGA IABC 0); 
                     DELTAT = INST + 1.E+30; 
                     DEPINT = ESTIM . 'DEPLACEMENTS'; 
                     VITDFI = ESTIM . 'DEFORMATIONS_INELASTIQUES'; 
                     SIG1 = SIGF * 1.; 
                 FINSI; 
                 SI (IABC '>' 0); 
                     DELTAT= INST - (ESTIM . 'TEMPS'); 
                     DEPINT= (ESTIM.'DEPLACEMENTS') - (ESTIM.'DEPLACEMENTS'); 
                     VITDFI= (ESTIM.'DEFORMATIONS_INELASTIQUES') 
                                 - (ESTIM.'DEFORMATIONS_INELASTIQUES'); 
                 FINSI; 
                 DEPINT = (REDU ELTETA DEPINT) / DELTAT; 
                 VITDFI = (REDU ELTETA VITDFI) / DELTAT; 
             FINSI; 
             SI BOOL.'J_DYNA'; 
                 VITF = (ESTIM .'VITESSES')      REDU ELTETA; 
                 ACCF = (ESTIM .'ACCELERATIONS') REDU ELTETA; 
             FINSI; 
         SINON; 
 * CAS OU ON APPELLE G_THETA APRES PASAPAS 
             INST = SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.IABC; 
             DEPINT = (SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.IABC) 
             REDU ELTETA; 
             SIGF = (SUPTAB.'SOLUTION_PASAPAS'.'CONTRAINTES'.IABC) 
                     REDU MOD_MEC_R; 
             SI (BOOL.'GRANDS_DEP' ET (NON BOOL.'ROT_RIG')); 
                 SIGF = 'CAPI' SIGF DEPINT MOD_MEC_R; 
             FINSI; 
             SI BOOL.'ROT_RIG'; 
                 SI (NON (EXIS (SUPTAB.'ROTATION_RIGIDIFIANTE') IABC)); 
                     MESS 'ERREUR : Le deplacement du a une rotation'; 
                     MESS '         rigidifiante au pas ' IABC ' n est pas' 
                     MESS '         donne'; 
                     ERRE 21 ; QUIT G_THETA; 
                 FINSI; 
                 DEPINT = DEPINT - 
                 (REDU SUPTAB.'ROTATION_RIGIDIFIANTE'.IABC ELTETA); 
             FINSI; 
             SI (EXIS (SUPTAB.'SOLUTION_PASAPAS') 'VARIABLES_INTERNES'); 
                 VARF = (SUPTAB.'SOLUTION_PASAPAS'.'VARIABLES_INTERNES'.IABC) 
                 REDU MOD_MEC_R; 
             SINON; 
                 VARF = ZERO MOD_MEC_R 'VARINTER' ;; 
             FINSI; 
             SI BOOL.'C*'; 
                 SI (EGA IABC 0); 
                     DELTAT = INST + 1.E+30; 
                     DEPINT = SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.IABC; 
                     VITDFI = SUPTAB.'SOLUTION_PASAPAS'. 
                     'DEFORMATIONS_INELASTIQUES'.IABC; 
                     SIG1 = SIGF * 1.; 
                 FINSI; 
                 SI (IABC > 0); 
                     DELTAT = INST - (SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'. 
                                 (IABC - 1)); 
                     DEPINT = (SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.IABC) - 
                     (SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.(IABC - 1)); 
                     VITDFI = (SUPTAB.'SOLUTION_PASAPAS'. 
                                 'DEFORMATIONS_INELASTIQUES'.IABC) - 
                                 (SUPTAB.'SOLUTION_PASAPAS'. 
                                 'DEFORMATIONS_INELASTIQUES'.(IABC - 1)); 
                 FINSI; 
                 DEPINT = (REDU ELTETA DEPINT) / DELTAT; 
                 VITDFI = (REDU ELTETA VITDFI) / DELTAT; 
             FINSI; 
             SI BOOL.'J_DYNA'; 
                 VITF = (SUPTAB.'SOLUTION_PASAPAS'.'VITESSES'.IABC) 
                 REDU ELTETA; 
                 ACCF = (SUPTAB.'SOLUTION_PASAPAS'.'ACCELERATIONS'.IABC) 
                 REDU ELTETA; 
             FINSI; 
         FINSI; 
     SINON; 
 * SOLUTION_RESO 
         DEPINT = REDU (SUPTAB.'SOLUTION_RESO') ELTETA; 
         SIGF = SIGM 'LINE' DEPINT MOD_MEC_R MAT_MEC; 
     FINSI; 
   
 * ON CHANGE LE DEPLACEMENT DEPINT EN MCHAML AU NOEUD 
     DEPINT = CHAN 'CHAM' DEPINT MOD_MEC_R 'NOEUD' 'DEPLACEMENTS'; 
   
 **************************************************** 
 * MODIFICATION DES CHAMPS THETA ET PI SI GRANDE ROT 
 **************************************************** 
   
     SI (BOOL.'PASAPAS' ET BOOL.'ROT_RIG'); 
         FORM SUPTAB.'ROTATION_RIGIDIFIANTE'.IABC; 
         OTER SUPTAB 'TAB_THETA'; 
         SI BOOL.'DJ/DA'; 
             OTER SUPTAB 'TAB_PI'; 
         FINSI; 
         CH_THETA SUPTAB OBJUTI BOOL; 
     FINSI; 
   
 ********************************************************************** 
 * CALCUL DES GRADIENTS ET DE LA DIVERGENCE DES CHAMPS THETA 
 ********************************************************************** 
   
     SI ((EGA &BOUCEXT 1) OU (BOOL.'PASAPAS' ET BOOL.'ROT_RIG')); 
         TTHETA = SUPTAB.'TAB_THETA'; 
         INDTH = INDE TTHETA; 
         NBOU = DIME TTHETA; 
         SUPTAB.'GRTHETA' = TABL; 
         SUPTAB.'DIVTHETA' = TABL; 
         REPE BCNOEU NBOU; 
             IND0 = INDTH.&BCNOEU; 
             CHTHETA = TTHETA.IND0 + DEP000; 
             GRTHETA = GRAD MOD_MEC_R CHTHETA CAR1; 
             DIVTHETA = (EXCO GR1 GRTHETA 'SCAL') + 
                         (EXCO GR5 GRTHETA 'SCAL') + 
                         (EXCO GR9 GRTHETA 'SCAL'); 
             DIVTHETA = CHAN 'TYPE' DIVTHETA 'SCALAIRE'; 
             SUPTAB.'GRTHETA'.IND0 = GRTHETA; 
             SUPTAB.'DIVTHETA'.IND0 = DIVTHETA; 
         FIN BCNOEU; 
     FINSI; 
   
   
 *************************************************** 
 ********** TEMPERATURES A L INSTANT INST ********** 
 *************************************************** 
   
     SI BOOL.'THER'; 
         SI BOOL.'PASAPAS'; 
             SI BOOL.'THER_DECO'; 
                 TEPINT = 'TIRE' CHAR1 INST 'T'; 
             SINON; 
 * bp, 2014-11-13 : ajout distinction cas BOOL.'THER' et BOOL.'THER_DECO' 
                 TEPINT = REDU ELTETA SUPTAB.'SOLUTION_PASAPAS'.'TEMPERATURES'. 
                             IABC; 
             FINSI; 
         SINON; 
             TEPINT = SUPTAB.'TEMPERATURES'; 
         FINSI; 
     FINSI; 
   
   
 *************************************************** 
 ********** DEF IMPOSEE A L INSTANT INST ********** 
 *************************************************** 
   
     SI BOOL.'DEF_IMP'; 
         SI BOOL.'PASAPAS'; 
             DEFI = 'TIRE' CHAR1 INST 'DEFI'; 
         SINON; 
             DEFI = SUPTAB.'DEFORMATIONS_IMPOSEES'; 
         FINSI; 
     FINSI; 
   
 *************************************************** 
 ********** CONTACT FROTTANT ********** 
 *************************************************** 
   
     SI BOOL.'FROT'; 
         SI BOOL.'PASAPAS'; 
 * ...TODO 
         SINON; 
 * A PRIORI DEPLACEMENT_FISSURE PAS TRES UTILE ... 
             SI (EXIS SUPTAB 'DEPLACEMENT_FISSURE'); 
                 WDEP  = SUPTAB . 'DEPLACEMENT_FISSURE'; 
             SINON; 
                 WDEP  = REDU (SUPTAB.'SOLUTION_RESO') MAICON; 
             FINSI; 
             TOTO = EXTR WDEP 'MAIL'; 
             SI (EGA (NBEL TOTO) 0); 
                 MESS 'ERREUR : IL FAUT DEPLACEMENT_FISSURE SI MODELE_FISSURE'; 
                 ERRE 21 ; QUIT G_THETA; 
             FINSI; 
             SI (EXIS SUPTAB 'PRESSION_FISSURE'); 
                 SIGCON = SUPTAB . 'PRESSION_FISSURE'; 
             SINON; 
                 SIGCON = REDU SIGF OBJCON; 
             FINSI; 
 * PEUT ETRE FAIRE UN TEST SUR SIGCON ... 
         FINSI; 
     FINSI; 
   
 ***************************************************** 
 * CONTRAINTE RECALCULEE SI BOOL.'THER' = VRAI et NON BOOL.'PASAPAS' * 
 ***************************************************** 
   
     SI (BOOL.'THER' ET (NON BOOL.'PASAPAS')); 
         SIGF = SIGF - (THET MOD_MEC_R MAT_MEC TEPINT); 
     FINSI; 
   
   
 *************************************************** 
 ************ MATERIAU A L INSTANT INST ************ 
 *************************************************** 
   
     SI (BOOL.'GRADPROP' ET BOOL.'THER' ET BOOL.'PASAPAS'); 
         MAT_INST = VARI 'NUAG' MOD_MEC_R MAT_MEC (EXCO 'T' TEPINT 'T'); 
     SINON; 
         MAT_INST = MAT_MEC; 
 * bp: ne devrait on pas ecrire ci dessous..? inutile? 
 * MAT_INST = REDU MOD_MEC_R MAT_MEC 
     FINSI; 
     OBJUTI.'MAT_INST' = MAT_INST; 
   
   
 *************************************************** 
 ********* RIGIDITE TOTALE A L INSTANT INST ******** 
 *************************************************** 
   
 * bp: utilite? 
     AUX_MECA = FAUX; 
     SI BOOL.'DECOUPLAGE'; 
         AUX_MECA = EGA SUPTAB.'METH_AUX' 'MECA'; 
     FINSI; 
     SI (BOOL.'DJ/DA' OU AUX_MECA); 
         SI BOOL.'PASAPAS'; 
             SI (BOOL.'GRADPROP' ET BOOL.'THER'); 
                 M1 = VARI 'NUAG' MOD_MEC_R (EXCO 'T' TEPINT 'T') 
                 (SUPTAB.'SOLUTION_PASAPAS'.'CARACTERISTIQUES'); 
             SINON; 
                 M1 = SUPTAB.'SOLUTION_PASAPAS'.'CARACTERISTIQUES'; 
             FINSI; 
             RIGTOT = RIGI M1 (SUPTAB.'SOLUTION_PASAPAS'.'MODELE'); 
         SINON; 
             RIGTOT = RIGI (SUPTAB.'CARACTERISTIQUES') (SUPTAB.'MODELE'); 
         FINSI; 
     FINSI; 
   
 ************************************ 
 *** RIGTOT + BLOCAGES MECANIQUES *** 
 ************************************ 
   
     SI  BOOL.'DJ/DA'; 
       SI BOOL.'PASAPAS'; 
          RIGTOT = RIGTOT ET 
                  (SUPTAB.'SOLUTION_PASAPAS'.'BLOCAGES_MECANIQUES'); 
 * rem bp: on suppose ceux ci identique a ceux de wtab... 
       SINON; 
          RIGTOT = RIGTOT ET SUPTAB.'BLOCAGES_MECANIQUES'; 
       FINSI; 
     FINSI; 
     OBJUTI.'RIGTOT' = RIGTOT; 
   
 ******************************************************************** 
 ****** CHARGEMENT MECANIQUE (FORCES NODALES) A L INSTANT INST ****** 
 ******************************************************************** 
   
     PREINT = FOR000; 
     SI BOOL.'PASAPAS'; 
 *** SOLUTION_PASAPAS ****************************** 
         SI (EXIS CHAR1 'MECA'); 
             PREINT = PREINT + ((TIRE CHAR1 INST 'MECA') REDU ELTETA); 
         FINSI; 
         SI BOOL.'MODE_PRES'; 
 * Dans le cas ou il y a un modele de pression 
             MATPRE = TIRE CHAR1 'PRES' INST; 
 * --> on isole la partie du MMODEL de pression qui est appliquee 
 * sur la fissure 
             SI BOOL.'PRES_FISS'; 
                 MODPF = REDU MODPRE MAILPF; 
                 MATPF = REDU MATPRE MODPF; 
             FINSI; 
 * --> on calcule les forces nodales equivalentes aux pressions 
 * appliquees hors de la fissure 
             MAILPEXT = DIFF MAILPTOT MAILPF; 
             SI ((NBEL MAILPEXT) > 0); 
                 MODPEXT = REDU MODPRE MAILPEXT; 
                 MATPEXT = REDU MATPRE MODPEXT; 
                 PREINT = PREINT + (BSIG MODPEXT MATPEXT); 
             FINSI; 
         FINSI; 
     SINON; 
 *** SOLUTION_RESO ********************************** 
         SI (EXIS SUPTAB 'CHARGEMENTS_MECANIQUES'); 
             PREINT = PREINT + (SUPTAB.'CHARGEMENTS_MECANIQUES' REDU ELTETA); 
         FINSI; 
         SI BOOL.'MODE_PRES'; 
 * Dans le cas ou il y a un modele de pression 
 * --> on isole la partie du MMODEL de pression qui est appliquee sur 
 * la fissure 
             SI BOOL.'PRES_FISS'; 
                 MODPF = REDU MODPRE MAILPF; 
                 MATPF = REDU MATPRE MODPF; 
             FINSI; 
 * --> on calcule les forces nodales equivalentes aux pressions 
 * appliquees hors de la fissure 
             MAILPEXT = DIFF MAILPTOT MAILPF; 
             SI ((NBEL MAILPEXT) > 0); 
                 MODPEXT = REDU MODPRE MAILPEXT; 
                 MATPEXT = REDU MATPRE MODPEXT; 
                 PREINT = PREINT + (BSIG MODPEXT MATPEXT); 
             FINSI; 
         FINSI; 
     FINSI; 
   
 ********************************************************************** 
 ******** POUR LES PRESSIONS APPLIQUEES SUR LA FISSURE 
 *        on calcule le MCHAML vectoriel de [pression * normale] 
 ********************************************************************** 
   
     SI BOOL.'PRES_FISS'; 
 * champ de normale unitaire au maillage de la fissure 
         MAT_INSTF = PRES MODPF 'PRES' 1.; 
         NF1   = BSIG MODPF MAT_INSTF; 
         LCOMP = EXTR NF1 'COMP'; 
         NF2   =  CHAN 'CHAM' NF1 MODPF 'STRESSES'; 
         XX    = PSCA NF2 NF2 LCOMP LCOMP; 
         NF    = NF2 / (XX**0.5); 
 * champ de pression normale au maillage de la fissure 
         PF    = CHAN 'STRESSES' MODPF MATPF; 
         PF    = CHAN 'TYPE' PF 'FORCES'; 
         NCOMP = DIME LCOMP; 
         LCP   = MOTS NCOMP*'PRES'; 
         PNF   = PF * NF LCP LCOMP LCOMP; 
     FINSI; 
   
 **************************************************** 
 ***** APPEL A G_AUX POUR LES CHAMPS AUXILIAIRES **** 
 **************************************************** 
   
 * G_AUX 
     SI AUX_MECA; 
         CH_AUX = G_AUX SUPTAB OBJUTI BOOL; 
         SI (EGA (TYPE CH_AUX) (MOT 'ANNULE')); 
             MESS 'ERREUR : G_AUX A RENCONTRE UN PROBLEME'; 
             QUIT G_CALCUL; 
         FINSI; 
         SUPTAB.'CH_AUX' = CH_AUX; 
         MESS; 
     FINSI; 
   
 *debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
     SI (BOOL.'FROT'); 
         OBJCON = OBJUTI.'OBJCON'; 
         OBJCON2 = OBJUTI.'OBJCON2'; 
     FINSI; 
 *fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
   
   
 *********************************************** 
 *********************************************** 
 **** BOUCLE SUR LES INTEGRALES A CALCULER ***** 
 *********************************************** 
 *********************************************** 
   
 * NBMIXT = nbre d integrale a calculer (=1 si J, =2 si K1 K2, =3 
 * si K1 K2 K3) 
     NBMIXT = 1; 
     SI BOOL.'DECOUPLAGE'; 
         C_MATE = OBJUTI.'C_MATE'; 
         MU_1 = OBJUTI.'MU_1'; 
         NBMIXT = 2; 
         SI (EGA GDIME 3); 
             NBMIXT = 3; 
         FINSI; 
     FINSI; 
     REPE BOUCMIX NBMIXT; 
   
   
 *|=====================================================================| 
 *|=======  I. OBJETS NECESSAIRES  =====================================| 
   
   
         SI BOOL.'DECOUPLAGE'; 
             MOCOMP = CHAI 'K' &BOUCMIX; 
         FINSI; 
   
 **************************************************** 
 **************** EN CAS DE DECOUPLAGE ************** 
 **************************************************** 
   
         SI BOOL.'DECOUPLAGE'; 
             MOTMIX = CH_AUX.&BOUCMIX.'MOTMIX'; 
             MOTMIA = CH_AUX.&BOUCMIX.'MOTMIA'; 
             A_PREI = CH_AUX.&BOUCMIX.'A_PREI'; 
             A_DEPI = CH_AUX.&BOUCMIX.'A_DEPI'; 
             A_SIGF = CH_AUX.&BOUCMIX.'A_SIGF'; 
             A_DEPGR = CH_AUX.&BOUCMIX.'A_DEPGR'; 
 *debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
             SI (BOOL.'FROT'); 
                 B_DEPGR = CH_AUX.&BOUCMIX.'B_DEPGR'; 
             FINSI; 
 *fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
         FINSI; 
   
   
 **************************************************** 
 ******* EN CAS DE CALCUL EN VISCO_PLASTICITE ******* 
 **************************************************** 
   
 * INITIALISATION DE FACT1 
         FACT1 = 1.; 
         SI (BOOL.'C*' OU BOOL.'C*H'); 
             SI (EGA ITYPEF 1); 
                 CHAF1 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF1 ' MAT_INST 'SCAL')) 
                 CHAN 'TYPE' 'SCALAIRE'; 
                 CHAF2 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF2 ' MAT_INST 'SCAL')) 
                 CHAN 'TYPE' 'SCALAIRE'; 
                 CHAF3 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF3 ' MAT_INST 'SCAL')) 
                 CHAN 'TYPE' 'SCALAIRE'; 
                 SI (EXIS MAT_INST 'AF0 '); 
                     CHAF4 =( CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF4 ' MAT_INST 'SCAL')) 
                     CHAN 'TYPE' 'SCALAIRE'; 
                     CHAF5 =( CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF5 ' MAT_INST 'SCAL')) 
                     CHAN 'TYPE' 'SCALAIRE'; 
                     CHAF6 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF6 ' MAT_INST 'SCAL')) 
                     CHAN 'TYPE' 'SCALAIRE'; 
                 FINSI; 
             FINSI; 
             SI BOOL.'C*'; 
                 SI (EGA ITYPEF 1); 
 * DENSITE D'ENERGIE POUR LES FLUAGES DONT ON A UNE 
 * EXPRESSION EXPLICITE DE L'INTEGRATION SUR LE TEMPS 
                     SI (EXIS MAT_INST 'AF0 '); 
                         COE1 = ((MINI (CHAF2 + 1.)) + (MAXI (CHAF2 + 1.)))/2.; 
                         COE2 = ((MINI (CHAF4 + 1.)) + (MAXI (CHAF4 + 1.)))/2.; 
                         COE3 = ((MINI (CHAF6 + 1.)) + (MAXI (CHAF6 + 1.)))/2.; 
                         VMI1 = (EXCO ('VMIS' MOD_MEC_R SIGF MAT_INST) 'SCAL') 
                         CHAN 'TYPE' 'SCALAIRE'        ; 
                         ENERM1 = (CHAF2*((CHAF2 + 1.)**(-1.)))*CHAF1*(VMI1**COE1); 
                         ENERM2 = (CHAF4*((CHAF4 + 1.)**(-1.)))*CHAF3*(VMI1**COE2); 
                         ENERM3 = (CHAF6*((CHAF6 + 1.)**(-1.)))*CHAF5*(VMI1**COE3); 
                         ENERM = ENERM1 + ENERM2 + ENERM3; 
                     SINON; 
                         COE1 = ((MINI (CHAF2 + 1.)) + (MAXI (CHAF2 + 1.)))/2.; 
                         COE2 = ((MINI CHAF3) + (MAXI CHAF3))/2.; 
                         VMI1 = (EXCO ('VMIS' MOD_MEC_R SIGF MAT_INST) 'SCAL') 
                         CHAN 'TYPE' 'SCALAIRE'    ; 
                         SI ((EGA INST 0. 1.E-10) ET ('<'(COE2 - 1) 0.)); 
                             V1 = 0.; 
                         SINON; 
                             V1 = INST**(COE2 - 1); 
                         FINSI; 
                         ENERM = (CHAF2*((CHAF2 + 1.)**(-1.)))* 
                                     CHAF1*(VMI1**COE1)*CHAF3*V1; 
                     FINSI; 
                     SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; ENERM = ENERM*MOD_MEC_R EPAICH ; FINSI; 
                 FINSI; 
                 SI (EGA ITYPEF 2); 
 * ON N'A PAS UNE EXPRESSION EXPLICITE DE 
 * L'INTEGRATION DU FLUAGE SUR LE TEMPS 
                     SIGMOY = 0.5*(SIG1 + SIGF); 
                     SI ((EGA IABC 0) ET (NON BOOL.'REPRI')); 
                         ENERM = 'ENER' MOD_MEC_R VITDFI SIGMOY; 
                     SINON; 
                         ENERM = ENERM + ('ENER' MOD_MEC_R (VITDFI - VDI1) SIGMOY); 
                     FINSI; 
                     SIG11 = SIG1 ; SIG1 = SIGF ; VDI1 = VITDFI; 
                 FINSI; 
             FINSI; 
 * FACTEUR AFFECTE A J SI ON CALCULE C*(H) 
             SI BOOL.'C*H'; 
                 CHAR2 = EXTR CHAR1 'MECA'; 
                 COE1 = ((MINI CHAF1) + (MAXI CHAF1)) / 2.; 
                 COE2 = ((MINI CHAF2) + (MAXI CHAF2)) / 2.; 
                 COE3 = ((MINI CHAF3) + (MAXI CHAF3)) / 2.; 
                 N1 = COE2 / COE3; 
                 SI (EGA INST 0. 1.E-10) ; INST = 1.E-10 ; FINSI; 
                 P1 = PROG 0. 'PAS' (INST / 100.) INST; 
                 P2 = PROG; 
                 REPE BF1 (DIME P1); 
                     T1 = EXTR P1 &BF1; 
                     V1 = 0.; 
                     REPE BF2 (DIME CHAR2); 
                         E1 = EXTR CHAR2 'EVOL' &BF2; 
                         V1 = V1 + ('IPOL' T1 (EXTR E1 'ABSC') (EXTR E1 ORDO)); 
                     FIN BF2; 
                     P2 = P2 ET (PROG V1); 
                 FIN BF1; 
                 E1 = EVOL 'MANU' 'TEMPS' P1 'FORCE' (P2 ** N1); 
                 FACT1 = EXTR (INTG E1) 1; 
                 SI (EGA FACT1 0. 1.E-10) ; FACT1 = 1.E+30 ; FINSI; 
                 FACT1 = ((V1 ** N1) / FACT1) ** COE3; 
             FINSI; 
         FINSI; 
   
   
 ******************************************************** 
 * SI LA COURBE DE TRACTION DEPEND DE LA TEMPERATURE ON * 
 * CALCULE LA VARIATION DE CONTRAINTES DE VON-MISES LORS* 
 * D'UNE AUGMENTATION (DETATE) DE LA TEMPERATURE A INST * 
 ******************************************************** 
 *bp 11/08/2011 : on calcule plutot la variation de la limite d elasticite 
 *                ce qui est moins faux si presence de decharge... 
 *            => on construit VM1 comm VM2 ! 
         SI (((DIME MODPLA) '>' 0) ET BOOL.'THER'); 
             DETATE = 1.; 
             TEP1 = TEPINT + (MANU 'CHPO' ELTETA 1 'T' DETATE); 
             EPS1 = (EXCO VARF 'EPSE') CHAN 'TYPE' 'SCALAIRE'; 
             MSQ1 = 'MASQ' 'SUPERIEUR' EPS1 1.E-10; 
             EPS1 = MSQ1 * EPS1; 
 * rem : on pourrait utiliser BORN dans le futur 
 * VMI1 = (CHAN ('VMIS' MOD_MEC_R SIGF MAT_INST) 
 *         'TYPE' 'SCALAIRE')*MSQ1; 
 * DETAVM = VMI1 * 0.; 
             DETAVM = 0.; 
             REPETER BCMOD2 NBOBJ; 
                 MODI = TABMOD.&BCMOD2; 
 * VM1 = REDU VMI1 MODI; 
                 EPS2 = redu EPS1 MODI; 
                 SI (EXIS MODPLA &BCMOD2); 
                     SI (EGA MODPLA.&BCMOD2 1); 
                         MA1 = VARI 'NUAG' MODI (MATE MODI 
                                 'ECRO' TABTRA.&BCMOD2) TEPINT; 
                         VM1 = VARI 'NUAG' MODI (EXCO 'ECRO' MA1 'SIGM') 
                         EPS2 'STRESSES' 'SCALAIRE'; 
                         VM1 = (EXCO VM1 'SIGM' 'SCAL') CHAN 'TYPE' 'SCALAIRE'; 
                         MA2 = 'VARI' 'NUAG' MODI (MATE MODI 
                                 'ECRO' TABTRA.&BCMOD2) TEP1; 
 * VM2 = 'VARI' 'NUAG' MODI (EXCO 'ECRO' MA2 SIGM) 
 *       (REDU EPS1 MODI) 'STRESSES' 'SCALAIRE'; 
 * VM2 = ((EXCO VM2 SIGM 'SCAL')CHAN 'TYPE' 'SCALAIRE') 
 *         * (REDU MSQ1 MODI); 
                         VM2 = VARI 'NUAG' MODI (EXCO 'ECRO' MA2 'SIGM') 
                                 EPS2 'STRESSES' 'SCALAIRE'; 
                         VM2 = (EXCO VM2 SIGM 'SCAL') CHAN 'TYPE' 'SCALAIRE'; 
                     FINSI; 
                     SI ((EGA MODPLA.&BCMOD2 2) OU 
                         (EGA MODPLA.&BCMOD2 3)); 
                         MA1 = VARI 'NUAG' MODI (REDU MAT_MEC MODI) TEPINT; 
                         VM1 = CHAN 'STRESSES' MODI (EXCO MA1 'SIGY' 'SCAL'); 
                         MA2 = VARI 'NUAG' MODI (REDU MAT_MEC MODI) TEP1; 
 * EPS2 = REDU EPS1 MODI; 
                         VM2 = CHAN 'STRESSES' MODI (EXCO MA2 'SIGY' 'SCAL'); 
                         SI (EGA MODPLA.&BCMOD2 2); 
                             HSCAL1 = (EXCO MA1 'H' 'SCAL') CHAN 'TYPE' 'SCALAIRE'; 
                             VM1 = VM1 + ((CHAN 'STRESSES' MODI HSCAL1)*EPS2); 
                             HSCAL2 = (EXCO MA2 'H' 'SCAL') CHAN 'TYPE' 'SCALAIRE'; 
                             VM2 = VM2 + ((CHAN 'STRESSES' MODI HSCAL2)*EPS2); 
                         FINSI; 
 * VM2 = VM2 * (REDU MSQ1 MODI); 
                     FINSI; 
                     SI (EGA (TYPE DETAVM) 'FLOTTANT'); 
                         DETAVM = ((VM2 - VM1) / DETATE); 
                     SINON; 
                         DETAVM = DETAVM + ((VM2 - VM1) / DETATE); 
                     FINSI; 
                 FINSI; 
             FIN BCMOD2; 
         FINSI; 
   
   
   
 ******************************************************* 
 **** ENERGIE DE DEFORMATION ELASTIQUE ET PLASTIQUE **** 
 ******************************************************* 
 *** 
 *** DENSITE D'ENERGIE EN ELASTO OU THERMO-ELASTO-PLASTICITE ET 
 *** DENSITE D'ENERGIE LIEE A LA VARIATION DE COURBE DE TRACTION 
 *** 
         SI (NON BOOL.'C*'); 
             WELAS = 0.5*('ENER' MOD_MEC_R SIGF ('ELAS' MOD_MEC_R SIGF MAT_INST)); 
 *         SI (BOOL.'PASAPAS' ET (NON BOOL.'DECOUPLAGE')); 
             SI (BOOL.'PASAPAS'); 
                 SI (EGA IABC 0); 
                     VMI1 = CHAN ('VMIS' MOD_MEC_R SIGF MAT_INST) 'TYPE' 'SCALAIRE'; 
                     SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; VMI1 = VMI1*MOD_MEC_R EPAICH ; FINSI; 
                     WPLAS=0.5*VMI1*((EXCO VARF 'EPSE')CHAN 'TYPE' 'SCALAIRE'); 
                     SI (((DIME MODPLA) '>' 0) ET BOOL.'THER'); 
                         WVMIS = 0.5*DETAVM*((EXCO VARF 'EPSE') 
                                     CHAN 'TYPE' 'SCALAIRE'); 
                     FINSI; 
                 SINON; 
                     VMI1 = CHAN (0.5*(('VMIS' MOD_MEC_R SIG1 MAT_INST) + 
                             ('VMIS' MOD_MEC_R SIGF MAT_INST))) 'TYPE' 'SCALAIRE'; 
                     SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; VMI1 = VMI1*MOD_MEC_R EPAICH ; FINSI; 
                     WPLAS = WPLAS + (VMI1*((EXCO (VARF - VAR1) 'EPSE') 
                                 CHAN 'TYPE' 'SCALAIRE')); 
                     SI (((DIME MODPLA) '>' 0) ET BOOL.'THER'); 
                         WVMIS = WVMIS + ((0.5*(DETAV1 + DETAVM))* 
                                     ((EXCO (VARF - VAR1) 'EPSE') 
                                     CHAN 'TYPE' 'SCALAIRE') ); 
                     FINSI; 
                 FINSI; 
                 ENERM = WELAS + WPLAS; 
                 SIG11 = SIG1 ; SIG1 = SIGF*1. ; VAR11 = VAR1 ; VAR1 = VARF*1.; 
                 SI (((DIME MODPLA) '>' 0) ET BOOL.'THER'); 
                     DETAV1 = DETAVM; 
                 FINSI; 
             SINON; 
                 ENERM = WELAS; 
             FINSI; 
         FINSI; 
   
   
   
   
 *|=====================================================================| 
 *|=======  II. CRITERES DE DECHARGES  =================================| 
   
   
 ************************************************************ 
 ****** CRITERE GLOBAL 1 DE DECHARGE DES CONTRAINTES ******** 
 ************************************************************ 
 *** 
 *** EVALUATION EN ELASTO-PLASTICITE OU THERMO-ELASTO-PLASTICITE 
 *** PAR COMPARAISON AVEC UN CALCUL EN ELASTICITE NON-LINEAIRE 
 *** EN PRENANT POUR REFERENCE LES CONTRAINTES DE VON-MISES DU 
 *** CALCUL RENDU PAR PASAPAS ET LES CONTRAINTES EQUIVALENTES LUES 
 *** SUR LES COURBES DE TRACTION 
 *** 
         OUICRIT = FAUX; 
         SI (EXIS SUPTAB 'CALCUL_CRITERE'); 
             OUICRIT = SUPTAB.'CALCUL_CRITERE'; 
         FINSI; 
         SI (BOOL.'MESS' ET OUICRIT); 
             MESS 'on va calculer les CRITERES DE DECHARGES, modpla='; 
 *        list modpla; 
         FINSI; 
   
         SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET OUICRIT); 
   
             XCRIT = 1.; 
   
             REPE BCMOD0 (DIME TABMOD); 
                 EXISCRIT = FAUX; 
                 MODI  = TABMOD.&BCMOD0; 
                 MATI  = REDU MAT_INST MODI; 
                 EPSE1 = EXCO VARF 'EPSE'; 
                 EPSE1 = EPSE1 CHAN TYPE 'SCALAIRE'; 
                 EPSET = REDU EPSE1 MODI; 
                 MSQ   = MASQ 'SUPERIEUR' EPSET 1.E-6; 
   
 * VMIS1 = contraintes de Von-Mises en elastoplastique 
                 VMIS1 = CHAN ('VMIS' MODI (REDU SIGF MODI) MATI) 
                     TYPE 'SCALAIRE'; 
   
                 SI ('EXIS' MODPLA &BCMOD0); 
                     YOU = CHAN 'STRESSES' MODI (EXCO MATI 'YOUN'); 
                     YOU = YOU CHAN TYPE 'SCALAIRE'; 
                     SI (EGA MODPLA.&BCMOD0 1); 
 * modele est plastique isotrope. on utilise la 
 * courbe de traction TABTRA.&BCMOD0 
                         EXISCRIT = VRAI; 
                         MATA = VARI 'NUAG' MODI ('MATE' MODI 
                                'ECRO' TABTRA.&BCMOD0) TEPINT; 
                         EPELAST = EXCO (VMIS1*(YOU**(-1))) 'SCAL' 'EPSE'; 
                         EPSTOT = EPELAST + EPSET; 
 * VMIS2 = contraintes deduites des deformations 
 * equivalentes par la courbe de traction 
                         VMIS2 = VARI 'NUAG' MODI (EXCO 'ECRO' MATA 'SIGM') 
                                   EPSTOT 'STRESSES' 'SCALAIRE'; 
                     FINSI; 
   
                     SI (EGA MODPLA.&BCMOD0 2); 
 * modele est plastique cinematique, cas ou 
 * SIGY et H sont des evolutions 
                         EXISCRIT = VRAI; 
                         VMIS22 = CHAN 'STRESSES' MODI (EXCO MATI 'SIGY' 'SCAL'); 
                         HSCAL = EXCO MATI 'H' 'SCAL'; 
                         HSCAL = HSCAL CHAN TYPE 'SCALAIRE'; 
                         VMIS2 = VMIS22 + ((CHAN 'STRESSES' MODI HSCAL) * EPSET); 
                     FINSI; 
   
                     SI (EGA MODPLA.&BCMOD0 3); 
 * modele est plastique parfait 
                         EXISCRIT = VRAI; 
                         VMIS2 = CHAN 'STRESSES' MODI ((EXCO MATI 'SIGY' 'SCAL') 
                                 CHAN TYPE 'SCALAIRE' ); 
                     FINSI; 
   
                 SINON; 
 *** modele elastoplastique et modele plastique cinematique 
 ***  avec caracteristiques independantes de la temperature 
   
                     SI (EXIS MATI 'ECRO'); 
 * extraction de la courbe de traction du modele MODI 
                         EXISCRIT = VRAI; 
                         TRACTI = EXTR MATI 'ECRO' 1 1 1; 
                         PEPSO  = EXTR TRACTI 'ABSC'; 
                         PSIGM  = EXTR TRACTI 'ORDO'; 
                         TRACTI = 'EVOL' 'MANU' 'EPSE' PEPSO 'SIGM' PSIGM; 
                         YOU    = CHAN 'STRESSES' MODI (EXCO MATI 'YOUN'); 
                         YOU    = YOU CHAN TYPE 'SCALAIRE'; 
                         EPELAST= EXCO (VMIS1*(YOU**(-1))) 'SCAL' 'EPSE'; 
                         EPSTOT = EPELAST + EPSET; 
 * VMIS2 = contraintes deduites des deformations 
 * equivalentes par la courbe de traction 
                         VMIS2 = 'VARI' MODI EPSTOT TRACTI 'STRESSES'; 
 * ?       VMIS2  = VMIS2 CHAN TYPE 'SCALAIRE'; 
                     FINSI; 
   
                     SI ((EXIS MATI 'SIGY') ET (EXIS MATI 'H')); 
 * modele est plastique cinematique traite ici separement du cas 
 * ou SIGY et H sont des evolutions c'est inutile car MAT_INST est 
 * deja instantie en temperature mais il faudra regler le pb de 
 * MODPLA dans son ensemble avec ZONE et une identification 
 * automatique de chacun des sous-modes 
                         EXISCRIT = VRAI; 
                         VMIS22 = CHAN 'STRESSES' MODI (EXCO MATI 'SIGY' 'SCAL'); 
                         VMIS22 = VMIS22 CHAN TYPE 'SACALAIRE'; 
                         HSCAL  = EXCO MATI 'H' 'SCAL'; 
                         HSCAL  = HSCAL CHAN TYPE 'SCALAIRE'; 
                         VMIS2  = VMIS22 + ((CHAN 'STRESSES' MODI HSCAL) * EPSET); 
                     FINSI; 
                     SI ((EXIS MATI 'SIGY') ET (NON (EXIS MATI 'H'))); 
 * modele est plastique parfait 
                         EXISCRIT = VRAI; 
                         VMIS2  = CHAN 'STRESSES' MODI (EXCO MATI 'SIGY' 'SCAL'); 
                         VMIS2  = VMIS2 CHAN TYPE 'SCALAIRE'; 
                     FINSI; 
   
                 FINSI; 
   
                 SI EXISCRIT; 
                     VMIS1P = VMIS1 * MSQ; 
                     VMIS1S = INTG MODI VMIS1P; 
                     VMIS2P = VMIS2 * MSQ; 
                     VMIS2S = INTG MODI VMIS2P; 
                     SI ('NEG' VMIS1S 0.); 
                         XCRIT = XCRIT + ((VMIS2S/VMIS1S) - 1.); 
                     FINSI; 
                 FINSI; 
   
             FIN BCMOD0; 
   
             SUPTAB.'CRIT_DECHA_GLOBAL1'.IABC = XCRIT; 
   
         FINSI; 
   
   
 ********************************************************* 
 ****** CRITERE LOCAL 1 DE DECHARGE DES CONTRAINTES ****** 
 ********************************************************* 
   
         SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET (IABC  > 0) ET OUICRIT); 
             SI BOOL.'MESS'; 
                 MESS 'CRITERE LOCAL 1'; 
             FINSI; 
             EXISCRIT = FAUX; 
             VMITOTF = ZERO MOD_MEC_R STRESSES; 
             VMITOT1 = ZERO MOD_MEC_R STRESSES; 
 * initialisation 
   
             REPE BCMOD0 (DIME TABMOD); 
   
                 MODI  = TABMOD.&BCMOD0; 
                 MATI  = REDU MAT_INST MODI; 
                 EPSE1 = EXCO VARF 'EPSE'; 
                 EPSE1 =  EPSE1 CHAN TYPE 'SCALAIRE'; 
                 EPSET = REDU EPSE1 MODI; 
                 MSQ   = 'MASQ' 'SUPERIEUR' EPSET 1.E-6; 
   
                 SI ('EXIS' MODPLA &BCMOD0); 
                     INST1  = SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.(IABC-1); 
                     TEPIN1 = TIRE CHAR1 INST1 'T'; 
                     TEPIN1 = REDU TEPIN1 ELTETA; 
 * TEPIN1 : temperature absolue au pas precedent 
   
 * modele plastique isotrope 
                     SI (EGA MODPLA.&BCMOD0 1); 
                         MATA = 'VARI' 'NUAG' MODI ('MATE' MODI 
                                       'ECRO' TABTRA.&BCMOD0) TEPINT; 
                         VMISF = CHAN ('VMIS' MODI SIGF MATA) TYPE 'SCALAIRE'; 
 * VMISF : contrainte de Von Mises au pas courant 
                         MATA1 = 'VARI' 'NUAG' MODI ('MATE' MODI 
                                       'ECRO' TABTRA.&BCMOD0) TEPIN1; 
                         VMIS1 = CHAN ('VMIS' MODI SIG11 MATA1) TYPE 'SCALAIRE'; 
 * VMIS1 : contrainte de Von Mises au pas precedent 
                     FINSI; 
   
 * modele plastique cinematique ou plastique parfait 
                     SI  ((EGA MODPLA.&BCMOD0 2) OU (EGA MODPLA.&BCMOD0 3)); 
                         VMISF = CHAN ('VMIS' MODI SIGF MATI) TYPE 'SCALAIRE'; 
                         VMIS1 = CHAN ('VMIS' MODI SIG11 MATI) TYPE 'SCALAIRE'; 
                     FINSI; 
   
 * pour ces 3 modeles 
                     SI ((EGA MODPLA.&BCMOD0 1) OU 
                         (EGA MODPLA.&BCMOD0 2) OU 
                         (EGA MODPLA.&BCMOD0 3)); 
                         EXISCRIT = VRAI; 
                         VMISFP = VMISF * MSQ; 
                         VMIS1P = VMIS1 * MSQ; 
 * VMISFP : contrainte de Von Mises aux points d'integration plastifies 
 **         au pas courant 
 * VMIS1P : contrainte de Von Mises aux points d'integration plastifies 
 **         au pas precedent 
 * on considere la plastification lorsque EPSET > 1E-6 
                         VMISF1P = VMISFP - VMIS1P; 
 * VMISFP : difference entre la contrainte equivalente au temps de 
 * calcul t et celle au temps precedent (t-1) 
                         VMITOTF = VMITOTF + VMISFP; 
                         VMITOT1 = VMITOT1 + VMISF1P; 
                     FINSI; 
   
                 SINON; 
   
                     SI ('EXIS' MATI 'ECRO'); 
 * modele elastoplastique avec 
 ** caracteristiques independantes de la temperature 
                         VMISF = CHAN ('VMIS' MODI (REDU SIGF MODI) MATI) 
                                      TYPE 'SCALAIRE'; 
                         VMIS1 = CHAN ('VMIS' MODI (REDU SIG11 MODI) MATI) 
                                      TYPE 'SCALAIRE'; 
                     FINSI; 
                     SI (EXIS MATI 'SIGY'); 
 * modele plastique cinematique et plastique parfait avec 
 ** caracteristiques independantes de la temperature 
                         VMISF = CHAN ('VMIS' MODI SIGF MATI) 
                                      TYPE 'SCALAIRE'; 
                         VMIS1 = CHAN ('VMIS' MODI SIG11 MATI) 
                                      TYPE 'SCALAIRE'; 
                     FINSI; 
   
                     SI (('EXIS' MATI 'ECRO') OU (EXIS MATI 'SIGY')); 
                         EXISCRIT = VRAI; 
                         VMISFP   = VMISF * MSQ; 
                         VMIS1P   = VMIS1 * MSQ; 
                         VMISF1P  = VMISFP - VMIS1P; 
                         VMITOTF  = VMITOTF + VMISFP; 
                         VMITOT1  = VMITOT1 + VMISF1P; 
                     FINSI; 
                 FINSI; 
   
             FIN BCMOD0; 
   
             SI EXISCRIT; 
 *      MSQO = (CHAN 'CHPO' MOD_MEC_R (VMITOT1*((VMITOTF)**(-1)))) 
 *             'MASQ' 'INFERIEUR' 0.; 
 *      SUPTAB.'CRIT_DECHA_LOCAL1'.IABC = 
 *         (CHAN 'CHPO' MOD_MEC_R ((VMITOT1*((VMITOTF)**(-1)))) * MSQO); 
 * #MC 04/11/98 : pour le MASQ, un produit suffit (pas de risque de /0) 
                 MSQO = (CHAN 'CHPO' MOD_MEC_R (VMITOT1*VMITOTF)) 
                         'MASQ' 'INFERIEUR' 0.; 
 * #MC 04/11/98 : ou il y a des 0, on met 1.E-10 
                 SUPTAB.'CRIT_DECHA_LOCAL1'.IABC = 
                         (CHAN 'CHPO' MOD_MEC_R ((VMITOT1*(( 
                         VMITOTF+(1.E-10*(VMITOTF 'MASQ' 'EGAL' 0.)) 
                         )**(-1)))) * MSQO); 
 *lorsque la valeur du critere est positive, c'est-a-dire qu'il n'y a 
 **pas de decharge, celle-ci est ramenee a zero 
             FINSI; 
   
         FINSI; 
   
   
 ************************************************************ 
 ****** CRITERE GLOBAL 2 DE DECHARGE DES CONTRAINTES ******** 
 ************************************************************ 
   
         SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET (NON BOOL.'REPRI') ET OUICRIT); 
   
             SI BOOL.'MESS'; 
                 MESS 'CRITERE GLOBAL 2'; 
             FINSI; 
   
             SI ('EXIS' SUPTAB.'SOLUTION_PASAPAS' 'DEFORMATIONS_INELASTIQUES'); 
                 SI BOOL.'PERSO1'; 
                     EPPLASF = ESTIM . 'DEFORMATIONS_INELASTIQUES'; 
                 SINON; 
                     EPPLASF = SUPTAB.'SOLUTION_PASAPAS'.'DEFORMATIONS_INELASTIQUES' 
                                       .IABC; 
                 FINSI; 
   
                 XCRIT = 1.; 
                 PRO1  = 0.; 
                 PRO2  = 0.; 
                 CRITLOCA = MANU 'CHML' MOD_MEC_R 'SCAL' 1. 'STRESSES'; 
                 NUMERA   = ZERO MOD_MEC_R 'STRESSES'; 
                 DENOMI   = ZERO MOD_MEC_R 'STRESSES'; 
 * initialisation 
 * glob2 n'est pas calcule si reprise car on ne connait pas i-1 
   
                 VMISF = CHAN ('VMIS' MOD_MEC_R SIGF MAT_INST) TYPE 'SCALAIRE'; 
 * VMISF : contrainte de Von Mises au pas courant 
                 SI ('EXIS' SUPTAB VMISMAX); 
                     MQSIG = SUPTAB.VMISMAX MASQ 'SUPERIEUR' VMISF; 
                     VMISF = VMISF + (MQSIG * ((SUPTAB.VMISMAX) - VMISF)); 
                 FINSI; 
                 SUPTAB.VMISMAX = VMISF; 
   
                 REPE BCMOD0 (DIME TABMOD); 
                     EXISCRIT = FAUX; 
                     MODI   = TABMOD.&BCMOD0; 
                     MATI   = REDU MAT_INST MODI; 
                     MAILI  = EXTR MODI 'MAIL'; 
                     EPSEI  = REDU (EXCO VARF 'EPSE') MODI; 
                     EPSEI  = EPSEI CHAN TYPE 'SCALAIRE'; 
 *       EPPLASI = (SUPTAB.'SOLUTION_PASAPAS'. 
 *                'DEFORMATIONS_INELASTIQUES'.IABC) REDU MODI; 
                     EPPLASI= REDU EPPLASF MODI; 
                     VMISFI = REDU VMISF   MODI; 
                     SIGFI  = REDU SIGF    MODI; 
                     YOU = CHAN 'STRESSES' MODI (EXCO MATI 'YOUN'); 
                     YOU = YOU  CHAN TYPE 'SCALAIRE'; 
                     SI ('EXIS' MODPLA &BCMOD0); 
                         SI ((EGA MODPLA.&BCMOD0 1) OU 
                             (EGA MODPLA.&BCMOD0 2) OU 
                             (EGA MODPLA.&BCMOD0 3)); 
 * modele plastique isotrope 
 * modele plastique cinematique 
 * modele plastique parfait 
                             lm_dein = EXTR epplasi 'COMP'; 
                             lm_defo = EXTR modi 'DEFO'; 
                             ep_u    = nomc lm_dein lm_defo epplasi; 
                             ep_u    = changer ep_u type deformations; 
 *         PRO1    = PRO1 + (INTG MODI (ENER MODI SIGFI EPPLASI)); 
                             PRO1    = PRO1 + (INTG MODI (ENER MODI SIGFI ep_u)); 
                             PRO2    = PRO2 + (INTG MODI (VMISFI * EPSEI)); 
                             SI (PRO2 'NEG' 0.D0); 
                                 XCRIT = XCRIT + (1. - (PRO1/PRO2)); 
                             FINSI; 
                         FINSI; 
                     SINON; 
   
                         SI (('EXIS' MATI 'ECRO') OU (EXIS MATI 'SIGY')); 
 * modele elastoplastique et 
 * modele plastique cinematique et plastique parfait 
 ** avec caracteristiques independantes de la temperature 
                             lm_dein = EXTR epplasi 'COMP'; 
                             lm_defo = EXTR modi 'DEFO'; 
                             ep_u    = NOMC lm_dein lm_defo epplasi; 
                             ep_u    = ep_u changer type deformations; 
 *         PRO1    = PRO1 + (INTG MODI (ENER MODI  SIGFI EPPLASI)); 
                             PRO1    = PRO1 + (INTG MODI (ENER MODI  SIGFI ep_u)); 
                             PRO2    = PRO2 + (INTG MODI (VMISFI * EPSEI)); 
 *         NUMERA  = NUMERA + (ENER MODI  SIGFI EPPLASI); 
                             NUMERA  = NUMERA + (ENER MODI  SIGFI ep_u); 
                             DENOMI  = DENOMI + (VMISFI * EPSEI); 
 *         petit traitement pour eviter de diviser par zero 
                             MIN0 = MINI 'ABS' DENOMI; 
                             MIN1 = MINI DENOMI; 
                             MAX1 = MAXI DENOMI; 
                             AMP = MAX1 - MIN1; 
                             SI (AMP < 1.E-15); 
                                 AMP = 1.E-15; 
                             FINSI; 
                             SI (MIN0 < (1.E-15 * AMP)); 
                                 DENOMI = DENOMI + (1.E-15 * AMP); 
                             FINSI; 
                             CRITLOCA = CRITLOCA + (1. - (NUMERA / DENOMI)); 
                         FINSI; 
                     FINSI; 
                 FIN BCMOD0; 
   
 * Le maxi sert a corriger le probleme castem sur les EPSE 
 * (ENER MODI  SIGFI EPPLASI) n est pas toujours egal a 
 * (VMISFI * EPSEI) lorsque le chargement est proportionnel 
 * A supprimer quand le pb sera resolu 
                 SUPTAB.'CRIT_DECHA_GLOBAL2'  .IABC='MAXI'(prog 0.9999999999 XCRIT); 
                 SUPTAB.'CRIT_DECHA_GLOBAL2_L'.IABC= CRITLOCA; 
   
 * mess 'PRO1' , PRO1 , 'PRO2' , PRO2 ,  'XCRIT' , XCRIT; 
             SINON; 
                 SI BOOL.'MESS'; 
                     MESS 'ATTENTION : LES DEFORMATIONS INELASTIQUES N''ONT'; 
                     MESS '            PAS ETE SAUVEGARDEES LORS DE PASAPAS.'; 
                     MESS '            LE CRITERE GLOBAL 2 NE PEUT DONC PAS'; 
                     MESS '            ETRE CALCULE.'; 
                 FINSI; 
             FINSI; 
         FINSI; 
   
   
 ********************************************************* 
 ****** CRITERE LOCAL 2 DE DECHARGE DES CONTRAINTES ****** 
 ********************************************************* 
   
         SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET (IABC  > 0) ET OUICRIT); 
             SI BOOL.'MESS' ;   MESS 'CRITERE local 2' ; FINSI; 
   
 *initialisation 
             EXISCRIT = FAUX; 
             CRIT0 = 'ZERO' MOD_MEC_R STRESSES; 
   
             REPE BCMOD0 (DIME TABMOD); 
                 MODI = TABMOD.&BCMOD0; 
                 MATI = REDU MAT_INST MODI; 
                 EPSE1 = EXCO VARF 'EPSE'; 
                 EPSE1 = EPSE1 CHAN TYPE 'SCALAIRE'; 
                 EPSET = REDU EPSE1 MODI; 
   
                 SI (('EXIS' MODPLA &BCMOD0) OU ('EXIS' MATI 'ECRO') 
                     OU ('EXIS' MATI 'SIGY')); 
   
                     MAT_z = 'MANU' 'CHML' MODI 'YOUN' 1. 'NU' 0. 'EPAI' 1. 
                                   TYPE 'CARACTERISTIQUES' 'RIGIDITE'; 
                     EXISCRIT = VRAI; 
                     DSIG = ELAS MODI (SIGF - SIG11) MAT_z; 
                     INV1 = ENER MODI (REDU SIGF MODI) (REDU DSIG MODI); 
                     SIGFTRA = ENER MODI (REDU SIGF MODI) 
                                (REDU (ELAS MODI SIGF MAT_z) MODI); 
                     DSIGTRA = ENER MODI (REDU DSIG MODI) 
                                (ELAS MODI DSIG MAT_z); 
                     NOR1 = SIGFTRA**(1./2); 
                     DNOR = DSIGTRA**(1./2); 
                     DENO = NOR1 * DNOR; 
                     CRIT0 = CRIT0 + (INV1 * (DENO**(-1))); 
   
                 FINSI; 
   
             FIN BCMOD0; 
   
             SI EXISCRIT; 
                 SUPTAB.'CRIT_DECHA_LOCAL2'.IABC = CHAN 'CHPO' MOD_MEC_R CRIT0; 
             FINSI; 
   
   
         FINSI; 
   
   
   
 *|=====================================================================| 
 *|=======  III. TRAITEMENT DES CHAMPS MECANIQUES   ====================| 
   
 **************************************************** 
 * ON CHANGE LA TEMPERATURE EN MCHAML AU NOEUD =TEPINT 
 **************************************************** 
         SI (EGA (TYPE TEPINT) 'CHPOINT '); 
             TEPINT = REDU TEPINT ELTETA; 
             TEPINT = CHAN 'CHAM' TEPINT MOD_MEC_R 'NOEUD' 'TEMPERATURES'; 
         SINON; 
             SI (EGA (TYPE TEPINT) 'MCHAML  '); 
                 TEPINT = REDU TEPINT MOD_MEC_R; 
                 TEPINT = CHAN 'NOEUD' MOD_MEC_R TEPINT; 
             FINSI; 
         FINSI; 
         SI (BOOL.'THER' ET (NON BOOL.'COQ')); 
             EPT1 = EPTH MOD_MEC_R MAT_INST TEPINT; 
             EPT1 VAR2 VAR3 = INVA MOD_MEC_R EPT1; 
             EPT1 = CHAN 'CHAM' (EPT1/3.) MOD_MEC_R 'NOEUD'; 
             EPT1 = EPT1 - OBJUTI.'EPTREF'; 
         FINSI; 
   
 *************************************************** 
 ***** GRADIENT DU DEPLACEMENT DEPINT =GRADEP ****** 
 *************************************************** 
         GRADEP = GRAD MOD_MEC_R MAT_INST DEPINT; 
         GRADEF = TEXT '        '; 
         SI (BOOL.'COQ' ET BOOL.'EL_LIN'); 
             GRADEF = 'GRAF' MOD_MEC_R MAT_INST DEPINT; 
         FINSI; 
   
 *************************************************** 
 ***** CAS DU CONTACT FROTTANT : ON CALCULE WSAUTGR = GRADIENT DU SAUT ****** 
 *************************************************** 
         SI BOOL.'FROT'; 
 * WDEP = deplacement de la fissure de composante UX ... AX ... 
 * [grad(w)] = grad [w] car linearite (le saut [w] est donne par AX ...) 
 * on utilise un modele liee a la geo de la fissure (cohesif ou contact) 
             WSAUTGR = GRAD OBJCON WDEP; 
 * SIGCON = sigma*n de composantes SMX... homogene a une contrainte 
 * supporte sur la levre superieure 
             SI (NEG (TYPE SIGCON) 'MCHAML  '); 
                 SIGCON = REDU SIGCON (extr OBJCON2 'MAILLAGE'); 
                 SIGCON = CHAN 'CHAM' SIGCON OBJCON2 'STRESSES' 'CONTRAINTES'; 
             FINSI; 
 *   Vsigcon = 'VECTEUR' sigcon objcon (1E-8) ('MOTS' 'SMX' 'SMY' 'SMZ'); 
 *    'TRACER' vsigcon ('EXTRAIRE' objcon 'MAIL'); 
             SIGXN = (CHAN (exco SIGCON 'SMX' 'SCAL') TYPE 'SCALAIRE'); 
             SIGYN = (CHAN (exco SIGCON 'SMY' 'SCAL') TYPE 'SCALAIRE'); 
             SI (EGA GDIME 3); 
                 SIGZN = (CHAN (exco SIGCON 'SMZ' 'SCAL') TYPE 'SCALAIRE'); 
             FINSI; 
         FINSI; 
   
 *************************************************** 
 ***** GRADIENT DE LA VITESSE VITF   =GRAVIT  ****** 
 *************************************************** 
         SI  BOOL.'J_DYNA'; 
             GRAVIT = GRAD MOD_MEC_R MAT_INST VITF; 
             VITF = CHAN 'CHAM'  MOD_MEC_R VITF 'STRESSES'; 
             ACCF = CHAN 'CHAM'  MOD_MEC_R ACCF 'STRESSES'; 
         FINSI; 
   
 *************************************************** 
 ** GRADIENT TEMPERATURE Grad T pour tous elements =TEPEGR 
 ** et Grad Grad T pour les elements massifs seuls (si DJ/DA) =DEPDTGR 
 *************************************************** 
         SI BOOL.'THER'; 
             SI (NON BOOL.'COQ'); 
                 TEPEGR = GRAD MOD_MEC_R MAT_INST (((EXCO 'T' TEPINT MU1) 
                                 CHAN TYPE 'SCALAIRE') + CMD000); 
                 GR_EPTH = GRAD MOD_MEC_R MAT_INST ((NOMC MU1 EPT1) + CMD000); 
                 SI  BOOL.'DJ/DA'; 
                     DEPDT = ((EXCO GR1 TEPEGR MU1) + (EXCO GR2 TEPEGR MU2)) 
                     CHAN TYPE 'SCALAIRE'; 
                     SI (GDIME EGA 3); 
                         DEPDT=DEPDT + ((EXCO GR3 TEPEGR MU3) CHAN TYPE 'SCALAIRE'); 
                     FINSI; 
                     DEPDTGR = GRAD MOD_MEC_R MAT_INST (CHAN TYPE 
                                 (CHAN 'NOEUD' MOD_MEC_R DEPDT) 'DEPLACEMENTS'); 
 *           DEPDTGR = GRAD MOD_MEC_R MAT_INST (CHAN 'CHPO' MOD_MEC_R DEPDT); 
                 FINSI; 
             SINON; 
                 TEPEGR = GRAD MOD_MEC_R MAT_INST ((((EXCO 'TINF' TEPINT MU1) 
                             CHAN TYPE 'SCALAIRE') ET 
                             ((EXCO 'T   ' TEPINT MU2)CHAN TYPE 'SCALAIRE') ET 
                             ((EXCO 'TSUP' TEPINT MU3)CHAN TYPE 'SCALAIRE')) 
                             + CMD000); 
             FINSI; 
         FINSI; 
   
 *************************************************** 
 **GRADIENT DE PRESSIONS Grad P (si DJ/DA) =PRESGR 
 *************************************************** 
         SI  BOOL.'DJ/DA'; 
             SI ('>' (XTX PREINT) 1.E-10); 
                 M1 = EXTR MOD_MEC_R 'FORC'; 
                 M2 = EXTR MOD_MEC_R 'DEPL'; 
                 REPE B1 (DIME M1); 
                     F1 = DEP000 + (EXCO (EXTR M1 &B1) PREINT (EXTR M2 &B1)); 
                 FIN B1; 
                 PRESGR = GRAD MOD_MEC_R MAT_INST F1; 
             FINSI; 
         FINSI; 
   
 *************************************************** 
 * PROFIL DE L'ENERGIE DANS L'EPAISSEUR DE LA COQUE 
 *************************************************** 
         SI BOOL.'COQ'; 
             PEX1 = PROG ; PEN1 = PROG; 
             REPE NBJ7 (DIME OBJUTI.'MODCOU'); 
                 MCOU1 = OBJUTI.'MODCOU'.&NBJ7; 
                 EX1 = EXTR (REDU MCOU1 MAT_INST) 'EXCE' 1 1 1; 
                 E1 = EXTR (REDU MCOU1 MAT_INST) 'EPAI' 1 1 1; 
                 SI ('<' (E1 / EPAITO) 1.E-4); 
                     ENR1 = EXTR (REDU MCOU1 ENERM) 'SCAL' 1 1 1; 
                     PEX1 = PEX1 ET ('PROG' EX1); 
                     PEN1 = PEN1 ET ('PROG' ENR1); 
                 FINSI; 
             FIN NBJ7; 
             M1 = MOT ' DANS L EPAISSEUR DE LA COQUE A T ='; 
             TITR ('CHAI' 'INTEGRALE ' CHINT M1 INST); 
             EVENR = 'EVOL' 'MANU' 'COOR.Z LOCAL' PEX1 CHINT PEN1; 
             SOM1 = ('INTG' EVENR); 
             SI (EGA SOM1 0.); 
                 SOM1 = SOM1 + 1.E-10; 
             FINSI; 
             EVENR = EVENR * EPAITO / SOM1; 
             NN = DIME (EXTR EVENR 'ORDO' 1); 
             V_SUPE = EXTR NN (EXTR EVENR 'ORDO' 1); 
             V_MOYE = EXTR ((NN - 1) / 2) (EXTR EVENR 'ORDO' 1); 
             V_INFE = EXTR 1 (EXTR EVENR 'ORDO' 1); 
         FINSI; 
   
 **************************************************** 
 *  RECUPERATION DU NOMBRE DE CALCULS A FAIRE 
 **************************************************** 
         TTHETA = SUPTAB.'TAB_THETA'; 
         INDTH = INDE TTHETA; 
         NBOU = DIME TTHETA; 
         SI  BOOL.'DJ/DA'; 
             TPI = SUPTAB.'TAB_PI'; 
             INDPI = INDE TPI; 
         FINSI; 
   
 ******************************************************** 
 * DENSITE DE MATERIAU EN CAS DE CALCUL DE J DYNAMIQUE ** 
 ******************************************************** 
         SI  BOOL.'J_DYNA'; 
             RHO1 = REDU (EXCO MAT_INST 'RHO' 'SCAL') MOD_MEC_R; 
             RHO1 = (CHAN MOD_MEC_R 'STRESSES' RHO1) CHAN TYPE 'SCALAIRE'; 
         FINSI; 
   
   
   
 *|=====================================================================| 
 *|======= BOUCLE SUR LES NOEUDS A AVANCER VIRTUELLEMENT =============> 
         GCHAM1 = VIDE 'MCHAML'; 
         GCHPO1 = VIDE 'CHPOINT'/'DISCRET'; 
   
         REPE BCNOEU NBOU; 
 ************************************************** 
 * RECUP DU CHAMP THETA ASSOCIE AU NOEUD PM DE NUMERO NUNOE 
 * ET DU CHAMP PI (SI DJ/DA) 
 ************************************************** 
   
             IND0 = INDTH.&BCNOEU; 
             CHTHETA = TTHETA.IND0 + DEP000; 
             SI  BOOL.'DJ/DA'; 
                 CHPI = TPI.(INDPI.&BCNOEU); 
             FINSI; 
   
   
 ************************************************** 
 * GRADIENT, DIVERGENCE DU CHAMP THETA =TETAGR, DIVTETA 
 * CHAMELEM THETA =(TETX,TETY,TETZ) 
 ************************************************** 
             TETAGR = SUPTAB.'GRTHETA'.IND0; 
             DIVTETA = SUPTAB.'DIVTHETA'.IND0; 
 * btrolle 2013 : ajout de TETAX, TETAY et TETAZ 
             TETAX= CHAN 'CHAM' MOD_MEC_R (EXCO MU1 CHTHETA 'SCAL') 'SCALAIRE'; 
             TETAY= CHAN 'CHAM' MOD_MEC_R (EXCO MU2 CHTHETA 'SCAL') 'SCALAIRE'; 
             TETX = CHAN 'CHAM' MOD_MEC_R (EXCO MU1 CHTHETA 'SCAL') 'STRESSES'; 
             TETY = CHAN 'CHAM' MOD_MEC_R (EXCO MU2 CHTHETA 'SCAL') 'STRESSES'; 
             TETX = TETX CHAN TYPE'SCALAIRE'; 
             TETY = TETY CHAN TYPE'SCALAIRE'; 
             THET_GR = ZERO MOD_MEC_R 'GRADIENT'; 
             THET_GR = THET_GR + (NOMC GR1 TETX) + (NOMC GR2 TETY); 
             SI (GDIME EGA 3); 
                 TETAZ= CHAN 'CHAM' MOD_MEC_R (EXCO MU3 CHTHETA 'SCAL') 'SCALAIRE'; 
                 TETZ = CHAN 'CHAM' MOD_MEC_R (EXCO MU3 CHTHETA 'SCAL') 'STRESSES'; 
                 TETZ = TETZ CHAN TYPE'SCALAIRE'; 
                 THET_GR = THET_GR + (NOMC GR3 TETZ); 
             FINSI; 
   
   
 ************************************************** 
 * GRADIENT, DIVERGENCE DU CHAMP PI =PIGR, DIVPI 
 * CHAMELEM PI =(PIX,PIY,PIZ) 
 * ... 
 ************************************************** 
             SI  BOOL.'DJ/DA'; 
                 NORM1 = ((EXCO MU1 CHPI 'SCAL')**2) + ((EXCO MU2 CHPI 'SCAL')**2); 
                 SI (EGA GDIME 3); 
                     NORM1 = NORM1 + ((EXCO MU3 CHPI 'SCAL')**2); 
                 FINSI; 
                 CHPI = CHPI + DEP000; 
                 CHPI = CHPI / ('MAXI' (NORM1**0.5)); 
                 PIGR = GRAD MOD_MEC_R MAT_INST CHPI; 
                 DIVPI = (EXCO GR1 PIGR 'SCAL') + 
                          (EXCO GR5 PIGR 'SCAL') + 
                          (EXCO GR9 PIGR 'SCAL'); 
                 DIVPI = DIVPI CHAN TYPE 'SCALAIRE'; 
                 PITAGR = (MOD_MEC_R PIGR * TETAGR); 
                 DIVPITA = (EXCO GR1 PITAGR 'SCAL') + 
                             (EXCO GR5 PITAGR 'SCAL') + 
                             (EXCO GR9 PITAGR 'SCAL'); 
                 DIVPITA = DIVPITA CHAN TYPE 'SCALAIRE'; 
                 ADJ = (DIVPITA - (DIVPI * DIVTETA)); 
                 PIX = CHAN 'CHAM' MOD_MEC_R (EXCO MU1 CHPI 'SCAL') 'STRESSES'; 
                 PIY = CHAN 'CHAM' MOD_MEC_R (EXCO MU2 CHPI 'SCAL') 'STRESSES'; 
                 PIX= PIX CHAN TYPE'SCALAIRE'; 
                 PIY= PIY CHAN TYPE'SCALAIRE'; 
                 SI (GDIME EGA 3); 
                     PIZ = CHAN 'CHAM' MOD_MEC_R (EXCO MU3 CHPI 'SCAL') 'STRESSES'; 
                     PIZ= PIZ CHAN TYPE'SCALAIRE'; 
                 FINSI; 
             FINSI; 
   
 ******************************************************** 
 *********** SI LE MATERIAU N'EST PAS CONSTANT ********** 
 * YOU1 = YOUGR * THETA = (grad E) * THETA 
 * SIGPRIM = (grad D)*THETA*(EPSI elas)   ou grad D =D(grad E,nu) =DMAT 
 * ALF1 = ALFGR*THETA = (grad Alpha)*THETA 
 * DMAT = D(1,nu,ALF1) 
 ******************************************************** 
             SI BOOL.'GRADPROP'; 
 *** Le coefficient de Poisson est constant *** 
 *    NU1 = REDU (EXCO MAT_INST 'NU' 'SCAL') MOD_MEC_R; 
 *    NU1 = EXCO NU1 'SCAL' 'NU'; 
                 NU1 = REDU (EXCO MAT_INST 'NU') MOD_MEC_R; 
                 NU1 = NU1 CHAN TYPE 'SCALAIRE'; 
 ****** Gradient de Module d'young ****** 
                 SI BOOL.'GRADYOUN'; 
                     YOU1 = REDU (EXCO MAT_INST 'YOUN' 'SCAL') MOD_MEC_R; 
                     YOU1 = YOU1   CHAN TYPE 'SCALAIRE'; 
                     YOUGR = GRA000 ; I = 0; 
                     REPE NBJ2 (DIME TABMOD); 
                         I = I + 1; 
                         YO1 = CHAN 'STRESSES' TABMOD.I 
                                 (REDU ((EXCO MAT_INST 'YOUN' MU1) 
                                 CHAN TYPE 'SCALAIRE') TABMOD.I); 
                         YOUGR = YOUGR + (GRAD TABMOD.I MAT_INST (YO1 + 
                                 (REDU CMD001 TABMOD.I))); 
 *       YO1 = CHAN 'CHPO' TABMOD.I 
 *            (REDU (EXCO MAT_INST 'YOUN' 'SCAL') TABMOD.I); 
 *       YOUGR = YOUGR + (GRAD TABMOD.I MAT_INST ((NOMC MU1 YO1) 
 *               + (REDU DEP000 (EXTR YO1 'MAIL')))); 
                     FIN NBJ2; 
                     YOU1 = (((EXCO GR1 YOUGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR2 YOUGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY); 
                     SI (GDIME EGA 3); 
                         YOU1 = YOU1 + (((EXCO GR3 YOUGR 'SCAL') 
                         CHAN TYPE 'SCALAIRE') * MOD_MEC_R TETZ); 
                     FINSI; 
                     YOU1 = (EXCO YOU1 'SCAL' 'YOUN') CHAN TYPE 'SCALAIRE'; 
                     DMAT = 'MATE' MOD_MEC_R 'YOUN' YOU1 'NU' NU1; 
                     SIGPRIM = (HOOK MOD_MEC_R DMAT)*MOD_MEC_R 
                                 (ELAS MOD_MEC_R SIGF MAT_INST); 
                 FINSI; 
 ****** Gradient de Coefficient de Dilatation ****** 
                 SI (BOOL.'THER' ET BOOL.'GRADALPH'); 
                     ALF1 = REDU (EXCO MAT_INST 'ALPH' 'SCAL') MOD_MEC_R; 
                     ALF1 = ALF1 CHAN TYPE 'SCALAIRE'; 
                     ALFGR = GRA000 ; I = 0; 
                     REPE NBJ3 (DIME TABMOD); 
                         I = I + 1; 
                         AL1 = CHAN 'STRESSES' TABMOD.I 
                                 (REDU (EXCO MAT_INST 'ALPH' MU1) TABMOD.I); 
                         AL1 = AL1 CHAN TYPE 'SCALAIRE'; 
                         ALFGR = ALFGR + (GRAD TABMOD.I MAT_INST (AL1 + 
                                 (REDU CMD001 TABMOD.I))); 
 *!       AL1 = CHAN 'CHPO' TABMOD.I 
 *!             (REDU (EXCO MAT_INST 'ALPH' 'SCAL') TABMOD.I); 
 *!       ALFGR = ALFGR + (GRAD TABMOD.I MAT_INST ((NOMC MU1 AL1) 
 *!               + (REDU DEP000 (EXTR AL1 'MAIL')))); 
                     FIN NBJ3; 
                     ALF1 = (((EXCO GR1 ALFGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR2 ALFGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY); 
   
                     SI (GDIME EGA 3); 
                         ALF1 = ALF1 + (((EXCO GR3 ALFGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                                 MOD_MEC_R TETZ); 
                     FINSI; 
                     ALF1 = EXCO ALF1 'SCAL' 'ALPH'; 
                     ALF1 = ALF1 CHAN TYPE 'SCALAIRE'; 
                     DMAT = 'MATE' MOD_MEC_R 'YOUN' 1. 'NU' NU1 'ALPH' ALF1; 
                 FINSI; 
             FINSI; 
   
 *********************************************** 
 * TEMU  = (Grad T)*THETA 
 * TEMU1 = (Grad T)*PI 
 * TEMU2 = (Grad (Grad T))*PI*THETA 
 * EPSTU = D^-1 sigma^th 
 *         avec sigma^th = (-3lambda-2mu)*alpha*(grad T)*THETA*I 
 * GR_EPTH_THET = (grad epsilon_th)*THETA 
 *********************************************** 
             SI BOOL.'THER'; 
                 SI (NON BOOL.'COQ'); 
                     TEMU = PSCA TEPEGR THET_GR MGI MGI; 
                     TEMU = CHAN TYPE (EXCO 'SCAL' TEMU 'T') 'TEMPERATURES'; 
                     GR_EPTH_THET = PSCA GR_EPTH THET_GR MGI MGI; 
                     GR_EPTH_THET = NOMC 'T' GR_EPTH_THET; 
                     GR_EPTH_THET = CHAN 'TYPE' GR_EPTH_THET 'TEMPERATURES'; 
                     MAT0 = MATE MOD_MEC_R 'YOUN' 1. 'NU' 0. 'ALPH' 1. 
                             'TALP' 0. 'TREF' 0.; 
                     GR_EPTH_THET = EPTH MOD_MEC_R MAT0 GR_EPTH_THET; 
                 SINON; 
                     T1 = (((EXCO GR1 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR2 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY) + 
                             (((EXCO GR3 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                     T2 = (((EXCO GR4 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR5 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY) + 
                             (((EXCO GR6 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                     T3 = (((EXCO GR7 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR8 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY) + 
                             (((EXCO GR9 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                     TEMU = CHAN TYPE ((EXCO 'SCAL' T1 'TINF') ET 
                             (EXCO 'SCAL' T2 'T   ') ET 
                             (EXCO 'SCAL' T3 'TSUP')) 'TEMPERATURES'; 
                 FINSI; 
                 EPSTU = ELAS MOD_MEC_R (THET MOD_MEC_R MAT_INST TEMU) MAT_INST; 
                 SI  BOOL.'DJ/DA'; 
                     TEMU1 = (((EXCO GR1 TEPEGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                                 MOD_MEC_R PIX) + (((EXCO GR2 TEPEGR 'SCAL') 
                                 CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIY); 
                     SI (GDIME EGA 3); 
                         TEMU1 = TEMU1 + (((EXCO GR3 TEPEGR 'SCAL') 
                                     CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIZ); 
                     FINSI; 
                     SI BOOL.'COQ'; 
                         TEMU1 = CHAN TYPE ((EXCO 'SCAL' TEMU1 'T') ET 
                                 (EXCO 'SCAL' TEMU1 'TINF') ET 
                                 (EXCO 'SCAL' TEMU1 'TSUP')) 'TEMPERATURES'; 
                     SINON; 
                         TEMU1 = CHAN TYPE (EXCO 'SCAL' TEMU1 'T') 
                                 'TEMPERATURES'; 
                     FINSI; 
                     EPSTU1 = ELAS MOD_MEC_R (THET MOD_MEC_R MAT_INST TEMU1) 
                                 MAT_INST; 
                     TXXPIX = ((EXCO GR1 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                                 MOD_MEC_R PIX; 
                     TYXPIY = ((EXCO GR2 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                                 MOD_MEC_R PIY; 
                     TXYPIX = ((EXCO GR4 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                                 MOD_MEC_R PIX; 
                     TYYPIY = ((EXCO GR5 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') * 
                                 MOD_MEC_R PIY; 
                     TEMU2 = (TETX*MOD_MEC_R (TXXPIX + TYXPIY)) + 
                                 (TETY*MOD_MEC_R (TXYPIX + TYYPIY)); 
                     SI (GDIME EGA 3); 
                         TEMU1 = TEMU1 + (((EXCO GR3 TEPEGR 'SCAL') 
                                     CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIZ); 
                         TZXPIZ = ((EXCO GR3 DEPDTGR 'SCAL') 
                                     CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIZ; 
                         TZYPIZ = ((EXCO GR6 DEPDTGR 'SCAL') 
                                     CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIZ; 
                         TXZPIX = ((EXCO GR7 DEPDTGR 'SCAL') 
                                     CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIX; 
                         TYZPIY = ((EXCO GR8 DEPDTGR 'SCAL') 
                                     CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIY; 
                         TZZPIY = ((EXCO GR9 DEPDTGR 'SCAL') 
                                     CHAN TYPE 'SCALAIRE') * MOD_MEC_R PIZ; 
                         TEMU2 = (TETX*MOD_MEC_R (TXXPIX + TYXPIY + TZXPIZ)) + 
                                 (TETY*MOD_MEC_R (TXYPIX + TYYPIY + TZYPIZ)) + 
                                 (TETZ*MOD_MEC_R (TXZPIX + TYZPIY + TZZPIZ)); 
                     FINSI; 
                     SI BOOL.'COQ'; 
                         TEMU2 = CHAN TYPE ((EXCO 'SCAL' TEMU2 'T') ET 
                                     (EXCO 'SCAL' TEMU2 'TINF') ET 
                                     (EXCO 'SCAL' TEMU2 'TSUP')) 'TEMPERATURES'; 
                     SINON; 
                         TEMU2 = CHAN TYPE (EXCO 'SCAL' TEMU2 'T') 'TEMPERATURES'; 
                     FINSI; 
                     EPSTU2 = ELAS MOD_MEC_R (THET MOD_MEC_R MAT_INST TEMU2) MAT_INST; 
                 FINSI; 
             FINSI; 
   
 * modif sm 
 *********************************************** 
 * CUMDEFI = SIG_{IJ} * (deps_{ij} / dx_{,k}) * thet_{k} 
 *********************************************** 
             CUMDEFI = ZERO MOD_MEC_R 'STRESSES'; 
             SI (BOOL.'DEF_IMP' ET (NON BOOL.'COQ')); 
                 LMOEP = EXTR MOD_MEC_R 'DEFO'; 
                 LMOSI = EXTR MOD_MEC_R 'CONT'; 
                 LMOGR = EXTR MOD_MEC_R 'GRAD'; 
                 NIDEF = DIME LMOSI; 
                 REPETER BDEFI NIDEF; 
                     MOEP = EXTR LMOEP &BDEFI; 
                     MOSI = EXTR LMOSI &BDEFI; 
                     EIJ  = EXCO DEFI MOEP  MU1; 
                     SMIJ = EXCO SIGF   MOSI 'SCAL'; 
                     GREIJ = GRAD MOD_MEC_R MAT_INST 
                                 ((CHAN (CHAN 'NOEUD' MOD_MEC_R EIJ) 
                                 'TYPE' 'SCALAIRE') + CMD000); 
                     DEIJX = (CHAN (CHAN 'STRESSES' MOD_MEC_R 
                                 (EXCO GREIJ (EXTR LMOGR 1) 'SCAL')) 
                                 TYPE 'SCALAIRE') * 
                                 (CHAN SMIJ TYPE 'SCALAIRE') * TETX; 
                     DEIJY = (CHAN (CHAN 'STRESSES' MOD_MEC_R 
                                 (EXCO GREIJ (EXTR LMOGR 2) 'SCAL')) 
                                 TYPE 'SCALAIRE') * 
                                 (CHAN SMIJ TYPE 'SCALAIRE') * TETY; 
                     CUMDEFI = CUMDEFI + DEIJX + DEIJY; 
                     SI (GDIME EGA 3); 
                         DEIJZ = (CHAN (CHAN 'STRESSES' MOD_MEC_R 
                                     (EXCO GREIJ (EXTR LMOGR 3) 'SCAL')) 
                                     TYPE 'SCALAIRE') * 
                                     (CHAN SMIJ TYPE 'SCALAIRE') * TETZ; 
                         CUMDEFI = CUMDEFI + DEIJZ; 
                     FINSI; 
                 FIN BDEFI; 
             FINSI; 
   
 *********************************************** 
 * PEMU1 = (Grad P)*TETA 
 * PEMU2 = (Grad P)*(Grad PI)*TETA 
 *********************************************** 
             SI  BOOL.'DJ/DA'; 
                 SI ((XTX PREINT) > 1.E-10); 
 * NOUVELLE IMPLEMENTATION JB : 
 *                   PEMU = VIDE 'CHPOINT'/'DISCRET'; 
 *                   REPE ICOMP GDIME; 
 *                           IDEB = 1 + (3*(&ICOMP - 1)); 
 *                           IFIN = IDEB + GDIME - 1; 
 *                       LMO1 = EXTR MGI (LECT IDEB PAS 1 IFIN); 
 *                       LMO2 = EXTR MUI (LECT 1 PAS GDIME); 
 *                       FI = PSCA PRESGR PI LMO1 LMO2; 
 *                       FI = NOMC (EXTR MUI &ICOMP) FI; 
 *                       PEMU = PEMU + (CHAN 'CHPO' MOD_MEC_R FI); 
 *                   FIN ICOMP; 
 * CETTE SECTION N'EST PAS TESTEE ACTUELLEMENT DANS LA BASE DE CAS-TESTS 
 * IL FAUT DONC AJOUTER UN CAS-TEST AVANT DE POUVOIR REMPLACER CE QUI SUIT 
 * PAR LES LIGNES COMMENTEES CI-DESSUS 
                     F1 = (((EXCO GR1 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIX) + 
                             (((EXCO GR2 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIY); 
                     F2 = (((EXCO GR4 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIX) + 
                             (((EXCO GR5 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIY); 
                     PEMU = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
                             (EXCO 'SCAL' F2 MF2)); 
                     SI (EGA GDIME 3); 
                         F1 = F1 + 
                             (((EXCO GR3 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIZ); 
                         F2 = F2 + 
                             (((EXCO GR6 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIZ); 
                         F3 = (((EXCO GR7 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIX) + 
                             (((EXCO GR8 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIY) + 
                             (((EXCO GR9 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R PIZ); 
                         PEMU = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
                                 (EXCO 'SCAL' F2 MF2) ET (EXCO 'SCAL' F3 MF3)); 
                     FINSI; 
                     F1 = (((EXCO GR1 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR2 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY); 
                     F2 = (((EXCO GR4 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR5 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY); 
                     PEMU1 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
                             (EXCO 'SCAL' F2 MF2)); 
                     SI (EGA GDIME 3); 
                         F1 = F1 + 
                             (((EXCO GR3 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                         F2 = F2 + 
                             (((EXCO GR6 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                         F3 = (((EXCO GR7 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR8 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY) + 
                             (((EXCO GR9 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                         PEMU1 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
                                 (EXCO 'SCAL' F2 MF2) ET (EXCO 'SCAL' F3 MF3)); 
                     FINSI; 
                     F1 = (((EXCO GR1 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR2 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY); 
                     F2 = (((EXCO GR4 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR5 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY); 
                     SI (EGA GDIME 3); 
                         F1 = F1 + 
                             (((EXCO GR3 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                         F2 = F2 + 
                             (((EXCO GR6 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                         F3 = (((EXCO GR7 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETX) + 
                             (((EXCO GR8 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETY) + 
                             (((EXCO GR9 PIGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R TETZ); 
                     FINSI; 
                     F4 = (((EXCO GR1 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F1) + 
                             (((EXCO GR2 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F2); 
                     F5 = (((EXCO GR4 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F1) + 
                             (((EXCO GR5 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F2); 
                     PEMU2 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F4 MF1) ET 
                             (EXCO 'SCAL' F5 MF2)); 
                     SI (EGA GDIME 3); 
                         F4 = F4 + 
                             (((EXCO GR3 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F3); 
                         F5 = F5 + 
                             (((EXCO GR6 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F3); 
                         F6 = (((EXCO GR7 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F1) + 
                             (((EXCO GR8 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F2) + 
                             (((EXCO GR9 PRESGR 'SCAL') CHAN TYPE 'SCALAIRE') * 
                             MOD_MEC_R F3); 
                         PEMU2 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F4 MF1) ET 
                                 (EXCO 'SCAL' F5 MF2) ET (EXCO 'SCAL' F6 MF3)); 
                     FINSI; 
                 FINSI; 
             FINSI; 
   
 *********************************************** 
 * DANS LE CAS DE CALCUL DE DJ/DA 
 * U^aux=A_DEPI  et  SIGMA^aux=A_SIGF 
 *********************************************** 
             SI  BOOL.'DJ/DA'; 
                 GRAD11 = (MOD_MEC_R GRADEP * PIGR); 
                 EPXX1 = (EXCO GR1 GRAD11 'SCAL') CHAN TYPE 'SCALAIRE'; 
                 EPYY1 = (EXCO GR5 GRAD11 'SCAL') CHAN TYPE 'SCALAIRE'; 
                 EPZZ1 = (EXCO GR9 GRAD11 'SCAL') CHAN TYPE 'SCALAIRE'; 
                 GAXY1 = ((EXCO GR2 GRAD11 'SCAL') + (EXCO GR4 GRAD11 'SCAL')) 
                             CHAN TYPE 'SCALAIRE'; 
                 GAXZ1 = ((EXCO GR3 GRAD11 'SCAL') + (EXCO GR7 GRAD11 'SCAL')) 
                             CHAN TYPE 'SCALAIRE'; 
                 GAYZ1 = ((EXCO GR6 GRAD11 'SCAL') + (EXCO GR8 GRAD11 'SCAL')) 
                             CHAN TYPE 'SCALAIRE'; 
                 SI (GDIME EGA 3); 
                     EPSIA1 = MANU 'CHML' MOD_MEC_R EP1 EPXX1 EP2 
                                 EPYY1 EP3 EPZZ1 EP4 GAXY1 EP5 GAXZ1 EP6 
                                 GAYZ1 TYPE 'DEFORMATIONS' 'STRESSES'; 
                 SINON; 
                     EPSIA1 = MANU 'CHML' MOD_MEC_R EP1 EPXX1 EP2 
                                 EPYY1 EP3 EPZZ1 EP4 GAXY1 
                                 TYPE 'DEFORMATIONS' 'STRESSES'; 
                 FINSI; 
                 SI BOOL.'THER' ; EPSIA1 = EPSIA1 + EPSTU1 ; FINSI; 
                 F11 = BSIG MOD_MEC_R (((HOOK MOD_MEC_R MAT_INST)*MOD_MEC_R EPSIA1) 
                         - (MOD_MEC_R SIGF*DIVPI)) + (FOFI MOD_MEC_R SIGF PIGR); 
                 SI ((XTX PREINT) > 1.E-10); 
                     F11 = F11 + PEMU + (PREINT*(CHAN 'CHPO' MOD_MEC_R DIVPI)); 
                 FINSI; 
                 A_PREI = FOR000; 
                 A_DEPI = REDU (RESO F11 RIGTOT) ELTETA; 
                 A_SIGF = MOD_MEC_R (HOOK MOD_MEC_R MAT_INST) * 
                             ((EPSI MOD_MEC_R A_DEPI) - EPSIA1); 
                 A_DEPGR = GRAD MOD_MEC_R MAT_INST A_DEPI; 
                 SI (BOOL.'COQ' ET BOOL.'EL_LIN'); 
                     A_DEPGF = 'GRAF' MOD_MEC_R MAT_INST A_DEPI; 
                 SINON; 
                     A_DEPGF = TEXT '        '; 
                 FINSI; 
             FINSI; 
   
 *********************************************** 
 * DEP0 = (grad U)*THETA 
 *********************************************** 
             LO1 = ((BOOL.'J') OU  BOOL.'C*'  OU  BOOL.'C*H' 
                     OU  BOOL.'DJ/DA'  OU  BOOL.'J_DYNA' ) 
                     ET ('>' (XTX PREINT) 1.E-10); 
             LO2 = FAUX; 
             SI  BOOL.'DECOUPLAGE'; 
                 LO2 = (XTX A_PREI) > 1.E-10; 
             FINSI; 
             SI (LO1 OU LO2); 
                 GRADCH = CHAN 'CHPO' MOD_MEC_R GRADEP; 
 *  mess 'gcalcul : CHAN CHPO grad(U)'; 
 *bp : on se ramene a un chpoint pour faire XTY avec preint ensuite 
 *     on moyenne avce CHAN CHPO, pourrait on l'eviter? 
                 DEPLX = ((EXCO GR1 GRADCH 'SCAL')*(EXCO MU1 CHTHETA 'SCAL')) + 
                         ((EXCO GR2 GRADCH 'SCAL')*(EXCO MU2 CHTHETA 'SCAL')); 
                 DEPLY = ((EXCO GR4 GRADCH 'SCAL')*(EXCO MU1 CHTHETA 'SCAL')) + 
                         ((EXCO GR5 GRADCH 'SCAL')*(EXCO MU2 CHTHETA 'SCAL')); 
                 DEP0 = (NOMC DEPLX MU1) + (NOMC DEPLY MU2); 
                 SI (GDIME EGA 3); 
                     DEPLX = DEPLX + 
                             ((EXCO GR3 GRADCH 'SCAL')*(EXCO MU3 CHTHETA 'SCAL')); 
                     DEPLY = DEPLY + 
                             ((EXCO GR6 GRADCH 'SCAL')*(EXCO MU3 CHTHETA 'SCAL')); 
                     DEPLZ = ((EXCO GR7 GRADCH 'SCAL')*(EXCO MU1 CHTHETA 'SCAL')) + 
                             ((EXCO GR8 GRADCH 'SCAL')*(EXCO MU2 CHTHETA 'SCAL')) + 
                             ((EXCO GR9 GRADCH 'SCAL')*(EXCO MU3 CHTHETA 'SCAL')); 
                     DEP0 = (NOMC DEPLX MU1) + (NOMC DEPLY MU2) + 
                             (NOMC DEPLZ MU3); 
                 FINSI; 
                 SI (BOOL.'COQ' ET BOOL.'EL_LIN'); 
                     GRAFCH = CHAN 'CHPO' MOD_MEC_R GRADEF; 
                     BXX = EXCO 'BX,X' GRAFCH 'SCAL'; 
                     BXY = EXCO 'BX,Y' GRAFCH 'SCAL'; 
                     BYX = EXCO 'BY,X' GRAFCH 'SCAL'; 
                     BYY = EXCO 'BY,Y' GRAFCH 'SCAL'; 
                     DEPFX = NOMC 'RX' ( (BXX*(EXCO 'UX' CHTHETA 'SCAL')) + 
                             (BXY*(EXCO 'UY' CHTHETA 'SCAL')) ); 
                     DEPFY = NOMC 'RY' ( (BYX*(EXCO 'UX' CHTHETA 'SCAL')) + 
                             (BYY*(EXCO 'UY' CHTHETA 'SCAL')) ); 
                     DEP0 = DEP0 + DEPFX + DEPFY; 
                 FINSI; 
             FINSI; 
   
   
 *************************************************************** 
 * S'il y a une pression sur la fissure, on calcule 
 * GRUTE = (grad U)*THETA sur les elements du modele de pression 
 * et dans la zone d'etude (ou le champ TETA est definit) 
 *************************************************************** 
             SI BOOL.'PRES_FISS'; 
 * on isole les elements de la fissure ou la pression s'applique et ou le 
 * champ teta est definit 
                 FISSP = EXTR MODPRE 'MAIL'; 
                 PFISSP = CHAN 'POI1' FISSP; 
                 FISSP = FISSP ELEM 'APPU' 'STRI' MAILMOD; 
                 MODPFT = VIDE 'MMODEL'; 
                 GRADEPF = VIDE 'MCHAML'; 
 * on interpole le gradient de deplacement (GRADEP) sur les elements du 
 * modele de pression touchant la levre inferieure 
                 SI (EXIS SUPTAB 'LEVRE_INFERIEURE'); 
                     FISI = INTE FISSP (SUPTAB . 'LEVRE_INFERIEURE'); 
                     MODPFI = REDU MODPF FISI; 
                     MP1 = DIFF (CHAN 'POI1' FISI) FF1; 
                     EL1 = MAILMOD ELEM 'APPU' 'LARG' MP1; 
                     MOD_MEC_R1 = REDU MOD_MEC_R EL1; 
                     GRADEP1 = REDU GRADEP MOD_MEC_R1; 
                     GRADEP1 = CHAN 'CHAM' GRADEP1 MOD_MEC_R1 'NOEUD'; 
                     GRUI = PROI GRADEP1 MODPFI 'STRESSES'; 
                     MODPFT = MODPFT ET MODPFI; 
                     GRADEPF = GRADEPF ET GRUI; 
                 FINSI; 
 * on interpole le gradient de deplacement (GRADEP) sur les elements du 
 * modele de pression touchant la levre superieure 
                 SI (EXIS SUPTAB 'LEVRE_SUPERIEURE'); 
                     FISS = INTE FISSP (SUPTAB . 'LEVRE_SUPERIEURE'); 
                     MODPFS = REDU MODPF FISS; 
                     MP1 = DIFF (CHAN 'POI1' FISS) FF1; 
                     EL1 = MAILMOD ELEM 'APPU' 'LARG' MP1; 
                     MOD_MEC_R1 = REDU MOD_MEC_R EL1; 
                     GRADEP1 = REDU GRADEP MOD_MEC_R1; 
                     GRADEP1 = CHAN 'CHAM' GRADEP1 MOD_MEC_R1 'NOEUD'; 
                     GRUS = PROI GRADEP1 MODPFS 'STRESSES'; 
                     MODPFT = MODPFT ET MODPFS; 
                     GRADEPF = GRADEPF ET GRUS; 
                 FINSI; 
                 GRADEPF = REDU GRADEPF MODPFT; 
 * on interpole le champ theta (THETA) sur les elements du modele de 
 * pression ==> TETAF 
                 TETAF = REDU CHTHETA FISSP; 
                 TETAF = CHAN 'CHAM' MODPFT TETAF 'STRESSES'; 
 * on fait ensuite le produit (GRADEPF * TETAF) ==> GRUTE 
                 LCT = EXTR TETAF   'COMP'; 
                 LCG = EXTR GRADEPF 'COMP'; 
                 SI (EGA GDIME 2); 
                     LCG12 = EXTR LCG (LECT 1 2); 
                     LCG45 = EXTR LCG (LECT 4 5); 
                     GRUTE1 = PSCA GRADEPF TETAF LCG12 LCT; 
                     GRUTE2 = PSCA GRADEPF TETAF LCG45 LCT; 
                     GRUTE  = (NOMC (EXTR LCT 1) GRUTE1) ET 
                                 (NOMC (EXTR LCT 2) GRUTE2); 
                 FINSI; 
                 SI (EGA GDIME 3); 
                     LCG123 = EXTR LCG (LECT 1 2 3); 
                     LCG456 = EXTR LCG (LECT 4 5 6); 
                     LCG789 = EXTR LCG (LECT 7 8 9); 
                     GRUTE1 = PSCA GRADEPF TETAF LCG123 LCT; 
                     GRUTE2 = PSCA GRADEPF TETAF LCG456 LCT; 
                     GRUTE3 = PSCA GRADEPF TETAF LCG789 LCT; 
                     GRUTE  = (NOMC (EXTR LCT 1) GRUTE1) ET 
                                 (NOMC (EXTR LCT 2) GRUTE2) ET 
                                 (NOMC (EXTR LCT 3) GRUTE3); 
                 FINSI; 
                 GRUTE = CHAN 'TYPE' GRUTE 'FORCES'; 
             FINSI; 
   
   
 *********************************************** 
 * DEP1 = (grad A_DEPI)*THETA 
 *********************************************** 
             LO1 =  BOOL.'DJ/DA'  ET ('>' (XTX PREINT) 1.E-10); 
             LO2 = FAUX; 
             SI  BOOL.'DECOUPLAGE'; 
                 LO2 = ('>' (XTX A_PREI) 1.E-10) OU ('>' (XTX PREINT) 1.E-10); 
             FINSI; 
             SI (LO1 OU LO2); 
 *  mess 'gcalcul : CHAN CHPO grad(U^aux)'; 
                 GRADCH = CHAN 'CHPO' MOD_MEC_R A_DEPGR; 
 *bp : on se ramene a un chpoint pour faire XTY avec preint ensuite 
 *     on moyenne avec CHAN CHPO, pourrait on l'eviter? 
                 DEPLX = ((EXCO GR1 GRADCH 'SCAL')*(EXCO MU1 CHTHETA 'SCAL')) + 
                         ((EXCO GR2 GRADCH 'SCAL')*(EXCO MU2 CHTHETA 'SCAL')); 
                 DEPLY = ((EXCO GR4 GRADCH 'SCAL')*(EXCO MU1 CHTHETA 'SCAL')) + 
                         ((EXCO GR5 GRADCH 'SCAL')*(EXCO MU2 CHTHETA 'SCAL')); 
                 DEP1 = (NOMC DEPLX MU1) + (NOMC DEPLY MU2); 
                 SI (GDIME EGA 3); 
                     DEPLX = DEPLX + 
                             ((EXCO GR3 GRADCH 'SCAL')*(EXCO MU3 CHTHETA 'SCAL')); 
                     DEPLY = DEPLY + 
                             ((EXCO GR6 GRADCH 'SCAL')*(EXCO MU3 CHTHETA 'SCAL')); 
                     DEPLZ = ((EXCO GR7 GRADCH 'SCAL')*(EXCO MU1 CHTHETA 'SCAL')) + 
                             ((EXCO GR8 GRADCH 'SCAL')*(EXCO MU2 CHTHETA 'SCAL')) + 
                             ((EXCO GR9 GRADCH 'SCAL')*(EXCO MU3 CHTHETA 'SCAL')); 
                     DEP1 = (NOMC DEPLX MU1) + (NOMC DEPLY MU2) + 
                             (NOMC DEPLZ MU3); 
                 FINSI; 
                 SI (BOOL.'COQ' ET BOOL.'EL_LIN'); 
                     GRAFCH = CHAN 'CHPO' MOD_MEC_R GRADEF; 
                     BXX = EXCO 'BX,X' GRAFCH 'SCAL'; 
                     BXY = EXCO 'BX,Y' GRAFCH 'SCAL'; 
                     BYX = EXCO 'BY,X' GRAFCH 'SCAL'; 
                     BYY = EXCO 'BY,Y' GRAFCH 'SCAL'; 
                     DEPFX = NOMC 'RX' ( (BXX*(EXCO 'UX' CHTHETA 'SCAL')) + 
                             (BXY*(EXCO 'UY' CHTHETA 'SCAL')) ); 
                     DEPFY = NOMC 'RY' ( (BYX*(EXCO 'UX' CHTHETA 'SCAL')) + 
                             (BYY*(EXCO 'UY' CHTHETA 'SCAL')) ); 
                     DEP1 = DEP1 + DEPFX + DEPFY; 
                 FINSI; 
             FINSI; 
 *********************************************** 
 * Termes supplemenetaire en Dynamique 
 * VCARE = V*V 
 * GRUTV = (grad U)*THETA*V      (Attigui) 
 * GRVTV = V^T * (grad V)*THETA  (BP) 
 * GRWTU = W^T * (grad U)*THETA  (BP) 
 *********************************************** 
             SI  BOOL.'J_DYNA'; 
                 VCARE = PSCA VITF VITF MUI MUI; 
 * NOUVELLE IMPLEMENTATION JB : 
 *               CHML_TETA = CHAN 'CHAM' MOD_MEC_R TETA 'STRESSES'; 
 *               GRUTV = MANU 'CHML' MOD_MEC_R 'SCAL' 0. 
 *                           'TYPE' 'DEPLACEM' 'STRESSES'; 
 *               GRVTV = COPI GRUTV; 
 *               GRWTU = COPI GRUTV; 
 *               REPE ICOMP GDIME; 
 * CALCUL DE DEPFI ET VITFI 
 *                   IDEB = 1 + (3*(&ICOMP - 1)); 
 *                   IFIN = IDEB + GDIME - 1; 
 *                   LMO1 = EXTR MGI (LECT IDEB PAS 1 IFIN); 
 *                   LMO2 = MUI; 
 *                   DEPFI = PSCA GRADEP CHML_TETA LMO1 LMO2; 
 *                   VITFI = PSCA GRAVIT CHML_TETA LMO1 LMO2; 
 * CALCUL DE GRUTV 
 *                   MO1 = EXTR MUI &ICOMP; 
 *                   GRUTV = GRUTV + ((EXCO MO1 VITF 'SCAL') * DEPFI); 
 * CALCUL DE GRVTV 
 *                   GRVTV = GRVTV + ((EXCO MO1 VITF 'SCAL') * VITFI); 
 * CALCUL DE GRWTU 
 *                   GRWTU = GRWTU + ((EXCO MO1 ACCF 'SCAL') * DEPFI); 
 *               FIN ICOMP; 
 * CETTE SECTION N'EST PAS ASSEZ TESTEE ACTUELLEMENT DANS LA BASE DE CAS-TESTS 
 * IL FAUT DONC AJOUTER DES CAS-TESTS AVANT DE POUVOIR REMPLACER CE QUI SUIT 
 * PAR LES LIGNES COMMENTEES CI-DESSUS 
                 DEPFX = (((EXCO GR1 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
                         (((EXCO GR2 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETY); 
                 DEPFY = (((EXCO GR4 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
                         (((EXCO GR5 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETY); 
                 VITFX = (((EXCO GR1 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
                         (((EXCO GR2 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETY); 
                 VITFY = (((EXCO GR4 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
                         (((EXCO GR5 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETY); 
                 SI (EGA GDIME 3); 
                     DEPFX=DEPFX +(((EXCO GR3 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ); 
                     DEPFY=DEPFY +(((EXCO GR6 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ); 
                     DEPFZ = (((EXCO GR7 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETX) + 
                             (((EXCO GR8 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETY) + 
                             (((EXCO GR9 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ); 
                     VITFX=VITFX +(((EXCO GR3 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ); 
                     VITFY=VITFY +(((EXCO GR6 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ); 
                     VITFZ = (((EXCO GR7 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETX) + 
                             (((EXCO GR8 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETY) + 
                             (((EXCO GR9 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ); 
                     GRUTV = ((EXCO MU1 VITF 'SCAL')*DEPFX) + 
                             ((EXCO MU2 VITF 'SCAL')*DEPFY) + 
                             ((EXCO MU3 VITF 'SCAL')*DEPFZ); 
                     GRWTU = ((EXCO MU1 ACCF 'SCAL')*DEPFX) + 
                             ((EXCO MU2 ACCF 'SCAL')*DEPFY) + 
                             ((EXCO MU3 ACCF 'SCAL')*DEPFZ); 
                     GRVTV = ((EXCO MU1 VITF 'SCAL')*VITFX) + 
                             ((EXCO MU2 VITF 'SCAL')*VITFY) + 
                             ((EXCO MU3 VITF 'SCAL')*VITFZ); 
                 SINON; 
                     GRUTV = ((EXCO MU1 VITF 'SCAL')*DEPFX) + 
                             ((EXCO MU2 VITF 'SCAL')*DEPFY); 
                     GRWTU = ((EXCO MU1 ACCF 'SCAL')*DEPFX) + 
                             ((EXCO MU2 ACCF 'SCAL')*DEPFY); 
                     GRVTV = ((EXCO MU1 VITF 'SCAL')*VITFX) + 
                             ((EXCO MU2 VITF 'SCAL')*VITFY); 
                 FINSI; 
             FINSI; 
   
   
 *|=====================================================================| 
 *|========  IV. CALCUL DE J,C*,C*(h) ou J_DYNA  =======================| 
   
 *********************************************** 
 * S10 = w*(div THETA) 
 * S20 = sigma*(grad U)*(grad THETA) 
 * S40 = Tr(sigma)*Alpha*(Grad T)*THETA 
 * S50 = F*(grad U)*THETA 
 * S60 = 0.5*(grad D)*THETA*(EPSI elas)*(EPSI elas) 
 * S70 = Tr(sigma)*T*(Grad Alpha)*THETA 
 * S100 = (W(b) - W(a))*THETA(x) 
 * S110 = SIGF*n*[ (dU/dX)(b) - (dU/dX)(a) ]*THETA(x) 
 * S120 = wvmis*(Grad T)*THETA 
 *     ou wvmis = SOME d(Von_mises)/d(Temperature) d(EPSE) 
 *********************************************** 
 * Termes supplementaires pour le J dynamique (Formulation de Attigui) 
 * S130 = 0.5*RHO*(V^2)*(div THETA) 
 * S140 = [Delta (RHO*V*(grad U)*THETA)]/(Delta Temps) 
 * Termes supplementaires pour le J dynamique (Formulation de BP) 
 * S130 = -0.5*RHO*(V^2)*(div THETA) 
 * S140 =  RHO*W*(grad U)*THETA 
 * S141 = -RHO*V*(grad V)*THETA 
 *********************************************** 
 * Termes supplementaires pour le J en grands-deplacements 
 * S150 = sigma*((grad U)t)*(grad U)*(grad THETA) 
 *********************************************** 
 *********************************************** 
 * Termes supplementaires pour un chaergement en deformation imposee (modif sm) 
 * S160 = sigma*(deps/dx)*(THETA) 
 *      = SIG_{IJ} * (deps^{imp}_{ij} / dx_{,k}) * thet_{k} 
 *********************************************** 
 * Termes supplementaires pour le contact frottant (modif BP,BT) 
 * S111 = SIGF*n*[ (dU/dX)(b) - (dU/dX)(a) ]*THETA(x) 
 *********************************************** 
   
   
             SI ((BOOL.'J') OU  BOOL.'C*' OU BOOL.'C*H' OU  BOOL.'J_DYNA' ); 
                 GMCANI = 0.; 
                 GTERMI = 0.; 
                 GPRESS = 0.; 
   
                 S10 = INTG MOD_MEC_R (ENERM*MOD_MEC_R DIVTETA) MAT2; 
                 GMCANI = GMCANI - S10; 
                 SI (BOOL.'COQ' ET BOOL.'EL_LIN'); 
                     S20 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                             (GRADEP*MOD_MEC_R TETAGR) 
                             (GRADEF*MOD_MEC_R TETAGR)); 
                 SINON; 
                     S20 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                             (GRADEP*MOD_MEC_R TETAGR)) MAT2; 
                 FINSI; 
                 GMCANI = GMCANI + S20; 
                 SI BOOL.'GRANDS_DEP'; 
                     SI (BOOL.'COQ' ET BOOL.'EL_LIN'); 
                         S150 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                                 (((TAGR GRADEP)*MOD_MEC_R GRADEP)*MOD_MEC_R TETAGR) 
                                 (((TAGR GRADEF)*MOD_MEC_R GRADEF)*MOD_MEC_R TETAGR)); 
                     SINON; 
                         S150 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                                 (((TAGR GRADEP)*MOD_MEC_R GRADEP)*MOD_MEC_R TETAGR)) MAT2; 
                     FINSI; 
                     GMCANI = GMCANI + S150; 
                 FINSI; 
                 SI (BOOL.'GRADPROP' ET BOOL.'GRADYOUN'); 
                     S60 = INTG MOD_MEC_R (0.5*(ENER MOD_MEC_R 
                             SIGPRIM (ELAS MOD_MEC_R SIGF MAT_INST))) MAT2; 
                     GMCANI = GMCANI - S60; 
                 FINSI; 
                 SI (((DIME LINTER) > 0) ET (NON BOOL.'PARAL')); 
                     I = 0 ; IND1 = INDE LINTER; 
                     REPE NBJ4 (DIME IND1); 
                         I = I + 1; 
                         LE1 = IND1.&NBJ4; 
                         L1 = LINTER.LE1; 
                         M1 = TABMOD.(EXTR LE1 1); 
                         M2 = TABMOD.(EXTR LE1 2); 
                         OBJINT = MODE L1 'MECANIQUE' 'ELASTIQUE'; 
                         TETXL = REDU L1 (EXCO MU1 CHTHETA 'SCAL'); 
                         TETXLC = CHAN 'CHAM' OBJINT TETXL 'STRESSES'; 
 *** 
                         ENEMA = REDU L1 (CHAN 'CHPO' M1 (REDU M1 ENERM)); 
                         ENEMB = REDU L1 (CHAN 'CHPO' M2 (REDU M2 ENERM)); 
                         ENRMAL = CHAN 'CHAM' OBJINT ENEMA 'STRESSES'; 
                         ENRMBL = CHAN 'CHAM' OBJINT ENEMB 'STRESSES'; 
                         S100 = S100 + (INTG OBJINT 
                                 ((ENRMBL - ENRMAL) * OBJINT TETXLC) MAT2); 
 *** 
                         GRADA = REDU L1 (CHAN 'CHPO' M1 (REDU M1 GRADEP)); 
                         GRADB = REDU L1 (CHAN 'CHPO' M2 (REDU M2 GRADEP)); 
                         UXXAL = CHAN 'CHAM' OBJINT (EXCO GR1 GRADA 'SCAL') 
                                 'STRESSES'; 
                         UXXBL = CHAN 'CHAM' OBJINT (EXCO GR1 GRADB 'SCAL') 
                                 'STRESSES'; 
                         UYXAL = CHAN 'CHAM' OBJINT (EXCO GR4 GRADA 'SCAL') 
                                 'STRESSES'; 
                         UYXBL = CHAN 'CHAM' OBJINT (EXCO GR4 GRADB 'SCAL') 
                                 'STRESSES'; 
                         SIGML = REDU L1 (CHAN 'CHPO' MOD_MEC_R SIGF); 
                         SIXXL = CHAN 'CHAM' OBJINT (EXCO SM1 SIGML 'SCAL') 
                                 'STRESSES'; 
                         SIXYL = CHAN 'CHAM' OBJINT (EXCO SM4 SIGML 'SCAL') 
                                 'STRESSES'; 
                         AAAA1 = (SIXXL * OBJINT (UXXBL - UXXAL)) + 
                                 (SIXYL * OBJINT (UYXBL - UYXAL)); 
                         S110 = S110 + (INTG OBJINT (AAAA1*OBJINT TETXLC) MAT2); 
                     FIN NBJ4; 
                     GMCANI = GMCANI - S100 + S110; 
                 FINSI; 
 * Termes supplementaire en Dynamique ********** 
                 SI  BOOL.'J_DYNA'; 
                     S130 = INTG MOD_MEC_R (0.5*(RHO1 * VCARE * DIVTETA)) MAT2; 
                     S140 = INTG MOD_MEC_R (RHO1 * GRWTU) MAT2; 
                     S141 = INTG MOD_MEC_R (RHO1 * GRVTV) MAT2; 
                     GMCANI = GMCANI - S130 + S140 - S141; 
                 FINSI; 
 * Termes supplementaire pour le contact frottant (btrolle 19/02/2013) 
                 SI (BOOL.'FROT'); 
 * teta 
                     TETXC = PROI OBJCON2 TETAX 'STRESSES'; 
                     TETYC = PROI OBJCON2 TETAY 'STRESSES'; 
                     SI (EGA GDIME 3); 
                         TETZC = PROI OBJCON2 TETAZ 'STRESSES'; 
                     FINSI; 
 * [grad(w)] = grad [w] = WSAUTGR 
 * sigma*n 
                     AAAAX = (SIGXN * (CHAN (exco WSAUTGR AX,X 'SCAL') TYPE 'SCALAIRE')) 
                             + (SIGYN * (CHAN (exco WSAUTGR AY,X 'SCAL') TYPE 'SCALAIRE')); 
                     AAAAY = (SIGXN * (CHAN (exco WSAUTGR AX,Y 'SCAL') TYPE 'SCALAIRE')) 
                             + (SIGYN * (CHAN (exco WSAUTGR AY,Y 'SCAL') TYPE 'SCALAIRE')); 
                     SI (EGA GDIME 3); 
                         AAAAX = AAAAX 
                                 + (SIGZN *  (CHAN(exco WSAUTGR AZ,X) TYPE 'SCALAIRE')); 
                         AAAAY = AAAAY 
                                 + (SIGZN *  (CHAN(exco WSAUTGR AZ,Y) TYPE 'SCALAIRE')); 
                         AAAAZ = (SIGXN *  (CHAN(exco WSAUTGR AX,Z) TYPE 'SCALAIRE')) 
                                 + (SIGYN *  (CHAN(exco WSAUTGR AY,Z) TYPE 'SCALAIRE')) 
                                 + (SIGZN *  (CHAN(EXCO WSAUTGR AZ,Z) TYPE 'SCALAIRE')); 
                         AAAA111 = (AAAAX * OBJCON2 TETXC) + (AAAAY * OBJCON2 TETYC) 
                                     + (AAAAZ * OBJCON2 TETZC); 
                     SINON; 
                         AAAA111 = (AAAAX * OBJCON2 TETXC) + (AAAAY * OBJCON2 TETYC); 
                     FINSI; 
 *    AAAA111 = 'MANUEL' CHML objcon 'SCAL' 1 TYPE 'SCALAIRE' 'STRESSES'; 
                     S111 = INTG OBJCON2 AAAA111 ; mess 'S111=' S111; 
                     GMCANI = GMCANI - S111; 
                 SINON; 
                     S111 = 0.0; 
                 FINSI; 
 * fin du cas contact frottant (btrolle 19/02/2013) 
   
                 S50 = 0.; 
                 SI ((XTX PREINT) > 1.E-10); 
                     S50 = XTY PREINT DEP0 MFI MUI; 
                 FINSI; 
                 SI BOOL.'PRES_FISS'; 
                     PNF = REDU PNF MODPFT; 
                     LC1 = EXTR PNF   'COMP'; 
                     LC2 = EXTR GRUTE 'COMP'; 
                     PGRU = MANU 'CHML' MODPFT 'SCAL' 0. 'STRESSES'; 
                     REPE B1 (DIME LC1); 
                         PGRU = PGRU + ((EXCO (EXTR LC1 &B1) PNF   'SCAL') * 
                                 (EXCO (EXTR LC2 &B1) GRUTE 'SCAL')); 
                     FIN B1; 
                     S50 = S50 + (INTG MODPFT PGRU); 
                 FINSI; 
                 GPRESS = GPRESS - S50; 
 * Termes supplementaire pour un chargement en deformation imposee (SM) ********* 
                 S160 = 0.; 
                 SI (BOOL.'J' ET BOOL.'DEF_IMP'); 
                     S160 = INTG MOD_MEC_R CUMDEFI MAT2; 
                     GPRESS = GPRESS + S160; 
                 FINSI; 
   
                 SI BOOL.'THER'; 
                     SI BOOL.'COQ'; 
                         S40 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF EPSTU) MAT2; 
                         GTERMI = GTERMI + S40; 
                         SI BOOL.'GRADALPH'; 
                             S70 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF (ELAS 
                                     MOD_MEC_R (THET MOD_MEC_R TEPINT DMAT) DMAT)) MAT2; 
                             GTERMI = GTERMI + S70; 
                         FINSI   ; 
                     SINON; 
                         S41 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF GR_EPTH_THET) MAT2; 
                         GTERMI = GTERMI + S41; 
                     FINSI; 
                     SI ((DIME MODPLA) > 0); 
                         TEMU = CHAN TYPE (EXCO 'T' TEMU 'SCAL') 'SCALAIRE'; 
                         S120 = INTG MOD_MEC_R (WVMIS * TEMU) MAT2; 
                         GTERMI = GTERMI - S120   ; 
                     FINSI; 
                 FINSI; 
   
 * somme des termes *************************** 
                 GTOTA = (GMCANI + GTERMI + GPRESS)*FACT1; 
             FINSI; 
   
   
   
 *|=====================================================================| 
 *|=======  V. CALCUL DE DJ/DA  ========================================| 
   
 *********************************************** 
 * S10 = -SIGF*(Grad U)*(Grad PI)*(Grad TETA) 
 * S20 = -SIGF*(Grad U)*(Grad TETA)*(Grad PI) 
 * S30 = SIGF*(Grad U)*(Grad TETA)*(Div PI) 
 * S40 = SIGF*(Grad U)*(Grad PI)*(Div TETA) 
 * S50 = ENEGIE*(ADJ TETA*PI) 
 * S60 = ALPH*SIGF*(Grad (Grad T))*PI*TETA 
 * S70 = ALPH*SIGF*((Grad T)*PI)*(Div TETA) 
 * S80 = ALPH*SIGF*((Grad T)*TETA)*(Div PI) 
 * S90 = SIG11*(Grad U)*(Grad TETA) 
 * S100= SIGF*(Grad U1)*(Grad TETA) 
 * S110= -SIGF*(Grad U1)*(Div TETA) 
 * S120= ALPH*SIG11*((Grad T)*TETA) 
 * S130= -PRESSION*(grad A_DEPI)*THETA 
 * S140= -(Grad PRESSION)*(Grad PI)*TETA*U 
 * S150= (Grad PRESSION)*TETA*U*(Div PI) 
 * S160= -(Grad PRESSION)*PI*(Grad U)*TETA 
 *********************************************** 
             SI  BOOL.'DJ/DA'; 
                 S10 = 0. - (INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                         (MOD_MEC_R GRADEP * (MOD_MEC_R PIGR * TETAGR)))); 
                 S20 = 0. - (INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                         (MOD_MEC_R GRADEP * (MOD_MEC_R TETAGR * PIGR)))); 
                 S30 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R 
                         SIGF (MOD_MEC_R GRADEP * TETAGR)) * DIVPI); 
                 S40 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R 
                         SIGF (MOD_MEC_R GRADEP * PIGR)) * DIVTETA); 
                 S50 = INTG MOD_MEC_R (ENERM * ADJ); 
                 SI BOOL.'THER'; 
                     S60 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF EPSTU2); 
                     S70 = INTG MOD_MEC_R ((ENER MOD_MEC_R SIGF EPSTU1)*DIVTETA); 
                     S80 = INTG MOD_MEC_R ((ENER MOD_MEC_R SIGF EPSTU)*DIVPI); 
                     S120 = INTG MOD_MEC_R (ENER MOD_MEC_R A_SIGF EPSTU); 
                 FINSI; 
                 SI ((XTX PREINT) > 1.E-10); 
                     S130 = XTY PREINT DEP1 MFI MUI; 
                     S140 = XTY PEMU2 (CHAN 'CHPO' MOD_MEC_R DEPINT) MFI MUI; 
                     S150 = XTY (PEMU1*(CHAN 'CHPO' MOD_MEC_R DIVPI)) 
                             (CHAN 'CHPO' MOD_MEC_R DEPINT) MFI MUI; 
                     S160 = XTY PEMU DEP0 MFI MUI; 
                 FINSI; 
                 S90 = INTG MOD_MEC_R (WORK MOD_MEC_R A_SIGF (MOD_MEC_R GRADEP * TETAGR)); 
                 S100 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF (MOD_MEC_R A_DEPGR * TETAGR)); 
                 S110 = 0. - (INTG MOD_MEC_R (MOD_MEC_R (WORK 
                         MOD_MEC_R SIGF A_DEPGR) * DIVTETA)); 
                 GMCANI = S10 + S20 + S30 + S40 + S50 + S90 + S100 + S110; 
                 GTERMI = S60 + S70 + S80 + S120; 
                 GPRESS = S150 - S130 - S140 - S160; 
                 GTOTA = GMCANI + GTERMI + GPRESS; 
             FINSI; 
   
   
   
 *|=====================================================================| 
 *|======  VI. CALCUL DES FACTEURS D INTENSITE DES CONTRAINTES  =======| 
   
 *********************************************** 
 * En pratique on les deduit de l integrale d interaction 
 * M(u,u^aux) = 2/E^* (K1*K1^aux + K2*K2^aux) 
 * On calcule donc : 
 *  J1 = 1/E^* K1^2 = M(u,u^aux_1)**2 / 4*J(u^aux_1,u^aux_1) 
 *  J2 = 1/E^* K2^2 = M(u,u^aux_2)**2 / 4*J(u^aux_2,u^aux_2) 
 *********************************************** 
 * l'integrale J(u^aux, u^aux) est la somme de : 
 * S10 = 0.5*Tr(A_sigf*(grad A_depi))*(div THETA) 
 * S20 = Tr[A_sigf*(grad A_depi)*(grad THETA)] * 
 * S50 = A_prei*(grad A_depi)*THETA 
 *********************************************** 
 * l'integrale M(u, u^aux) et la somme de : 
 * S60 = Tr[A_sigf*(Grad U)*(Grad THETA)] 
 * S70 = Tr[SIGF*(Grad A_depi)*(Grad THETA)] 
 * S80 = Tr[SIGF*(Grad A_depi)*(Div THETA)] 
 * S90 = PREINT*(grad A_depi)*THETA 
 * S100= A_prei*(grad U)*THETA 
 * S110= ALPH*A_sigf*((Grad T)*TETA) 
 *********************************************** 
 * Termes supplementaires pour le contact frottant (modif BP,BT) 
 * S111 = SIGF*n*[ (dU^aux/dX)(b) - (dU^aux/dX)(a) ]*TETA(x) 
 *********************************************** 
   
   
             SI  BOOL.'DECOUPLAGE'; 
 *    si(BOOL.'XFEM'); 
 * *  REM: pour les elements XFEM on a contruit les champs aux. tq 
 * *      (K_I^aux, K_II^aux)  =  (1,0)  et (0,1) 
 * *      => inutile de calculer J(u^aux,u^aux) (= C_MATE) 
 *bp 07/07/2011 : cela est faux dans le cas d'une fissure courbee 
 *      COE_M2K = 2. * C_MATE; 
 *    SINON; 
                 S10 = 0.5*( INTG MOD_MEC_R 
                         (MOD_MEC_R (WORK MOD_MEC_R A_SIGF A_DEPGR) * DIVTETA) ); 
                 S20 = INTG MOD_MEC_R 
                         (WORK MOD_MEC_R A_SIGF (A_DEPGR*MOD_MEC_R TETAGR) ) MAT2; 
                 SI ((XTX A_PREI) > 1.E-10); 
                     S50 = XTY A_PREI DEP1 MFI MUI; 
                 FINSI; 
                 JETOILE = 'ABS' (S20 - S10 - S50); 
                 SI ((EGA &BOUCMIX 1) OU (EGA &BOUCMIX 2)); 
                     FACTK = 0.5 / ((C_MATE * JETOILE)**0.5); 
                 SINON; 
                     FACTK = 0.5 * ((2. * MU_1 / JETOILE)**0.5); 
                 FINSI; 
 *    FINSI; 
 *  integrale M(u, u^aux) 
                 S60 = INTG MOD_MEC_R (WORK MOD_MEC_R A_SIGF (MOD_MEC_R GRADEP * TETAGR)); 
                 S70 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF (MOD_MEC_R A_DEPGR * TETAGR)); 
                 S80 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R SIGF A_DEPGR) * DIVTETA); 
 *rem: on pourrait calculer M avec les 2 lignes ci dessous: 
 *    S81 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R A_SIGF GRADEP) * DIVTETA); 
 *    S80 = 0.5*(S80+S81); 
 * Termes supplementaire pour le contact frottant (btrolle 19/02/2013) 
 * on calcule WSAUTGR^aux = GRADIENT DU SAUT^aux 
                 SI (BOOL.'FROT' 'ET' BOOL.'XFEM'); 
 * WDEP = deplacement de la fissure de composante UX ... AX ... 
 * [grad(w)] = grad [w] car linearite (le saut [w] est donne par AX ...) 
 * on utilise un modele liee a la geo de la fissure (cohesif ou contact) 
 * mess 'I avec contact frottant'; 
 * SIGCON = sigma*n de composantes SMX... homogene a une contrainte 
 * supporte sur la levre superieure 
                     SI (NEG (TYPE SIGCON) 'MCHAML  '); 
                         SIGCON = REDU SIGCON (extr OBJCON2 'MAILLAGE'); 
                         SIGCON = CHAN 'CHAM' SIGCON OBJCON2 'STRESSES' 'CONTRAINTES'; 
                     FINSI; 
                     SIGXN = (CHAN (exco SIGCON 'SMX' 'SCAL') TYPE 'SCALAIRE'); 
                     SIGYN = (CHAN (exco SIGCON 'SMY' 'SCAL') TYPE 'SCALAIRE'); 
                     SI (EGA GDIME 3); 
                         SIGZN = (CHAN (exco SIGCON 'SMZ' 'SCAL') TYPE 'SCALAIRE'); 
                     FINSI; 
 * teta 
                     TETXC = PROI OBJCON2 TETAX 'STRESSES'; 
                     TETYC = PROI OBJCON2 TETAY 'STRESSES'; 
                     SI (EGA GDIME 3); 
                         TETZC = PROI OBJCON2 TETAZ 'STRESSES'; 
                     FINSI; 
 * [grad(w)] = grad [w] = WSAUTGR 
 * sigma*n 
                     AAAAX= (SIGXN * (CHAN (exco B_DEPGR AX,X 'SCAL') TYPE 'SCALAIRE')) 
                     + (SIGYN * (CHAN (exco B_DEPGR AY,X 'SCAL') TYPE 'SCALAIRE')); 
                     AAAAY= (SIGXN * (CHAN (exco B_DEPGR AX,Y 'SCAL') TYPE 'SCALAIRE')) 
                     '+' (SIGYN * (CHAN (exco B_DEPGR AY,Y 'SCAL') TYPE 'SCALAIRE')); 
                     SI (EGA GDIME 3); 
                         AAAAX = AAAAX 
                                 + (SIGZN *  (CHAN(EXCO B_DEPGR AZ,X) TYPE 'SCALAIRE')); 
                         AAAAY = AAAAY 
                                 + (SIGZN *  (CHAN(EXCO B_DEPGR AZ,Y) TYPE 'SCALAIRE')); 
                         AAAAZ = (SIGXN *  (CHAN(EXCO B_DEPGR AX,Z) TYPE 'SCALAIRE')) 
                                 + (SIGYN *  (CHAN(EXCO B_DEPGR AY,Z) TYPE 'SCALAIRE')) 
                                 + (SIGZN *  (CHAN(EXCO B_DEPGR AZ,Z) TYPE 'SCALAIRE')); 
                         AAAA111 = (AAAAX * OBJCON2 TETXC) 
                                     + (AAAAY * OBJCON2 TETYC) 
                                     + (AAAAZ * OBJCON2 TETZC); 
                     SINON; 
                         AAAA111 = (AAAAX * OBJCON2 TETXC) 
                                     + (AAAAY * OBJCON2 TETYC); 
                     FINSI; 
                     S111 = INTG OBJCON2 AAAA111; 
                 SINON; 
                     S111 = 0.0; 
                 FINSI; 
 * fin du cas contact frottant (btrolle 19/02/2013) 
                 SI ((XTX PREINT) > 1.E-10); 
                     S90 = XTY PREINT DEP1 MFI MUI; 
                 FINSI; 
                 SI ((XTX A_PREI) > 1.E-10); 
                     S100 = XTY A_PREI DEP0 MFI MUI; 
                 FINSI; 
                 SI BOOL.'THER'; 
                     S110 = INTG MOD_MEC_R (ENER MOD_MEC_R A_SIGF EPSTU); 
                 FINSI; 
 *  facteurs d intensite des contraintes 
                 GMCANI = (S60 + S70 - S80 + S111) * FACTK; 
                 GTERMI = (S110) * FACTK; 
                 GPRESS = (-1.*(S100 + S90)) * FACTK; 
                 GTOTA = GMCANI + GTERMI + GPRESS; 
             FINSI; 
   
   
 *|=====================================================================| 
 *|=======  VII. STOCKAGE DES RESULTATS ET IMPRESSIONS  ===============| 
   
             SI ((NBOU > 1) ET (EGA &BCNOEU NBOU)); 
                 NUNOE = CHAI 'GLOBAL'; 
             SINON; 
                 SI ((EGA GDIME 2) OU BOOL.'COQ'); 
                     PM = FF1 POIN 1; 
                     NUNOE = CHAI (NOEU PM)*NDEC; 
                 SINON; 
                     SI BOOL.'XFEM'; 
                         NUNOE = &BCNOEU; 
                     SINON; 
                         FTHETA = REDU CHTHETA FF1; 
                         NTHETA = (PSCA FTHETA FTHETA MUI MUI)**0.5; 
                         PM = (NTHETA POIN 'MAXI') POIN 1; 
                         NUNOE = CHAI (NOEU PM)*NDEC; 
                     FINSI; 
                 FINSI; 
             FINSI; 
   
 *************************************************** 
 ** PROFILE DE G DANS L EPAISSEUR EN CAS DE COQUE ** 
 *************************************************** 
             SI BOOL.'COQ'; 
                 SI BOOL.'PASAPAS'; 
                     SUPTAB.'EPAISSEUR_RESULTATS'.IABC = EVENR * GTOTA; 
                 SINON; 
                     SUPTAB.'EPAISSEUR_RESULTATS' = EVENR * GTOTA; 
                 FINSI; 
             FINSI; 
   
 **************************** 
 ** AFFICHAGE DES RESULTATS** 
 **************************** 
             CHARES = CHAI; 
             SI BOOL.'PASAPAS'; 
                 CHARES = CHAI CHARES IABC*NDPAS; 
             FINSI; 
             SI BOOL.'DECOUPLAGE'; 
                 CHARES = CHAI CHARES MOTMIA*NDDEC; 
             FINSI; 
             SI ((EGA GDIME 3) ET (NON BOOL.'COQ')); 
                 CHARES = CHAI CHARES NUNOE*NDFRO; 
             FINSI; 
             SI BOOL.'COQ'; 
                 PVAL = PROG V_SUPE V_MOYE V_INFE 1.; 
                 LMVAL = MOTS 'Superi' 'Median' 'Inferi' 'GLOBAL'; 
                 REPE IVAL 4; 
                     XVAL = EXTR PVAL &IVAL; 
                     MVAL = EXTR LMVAL &IVAL; 
                     CHARES = CHAI CHARES MVAL*NDCOQ; 
                     MESS CHARES (GMCANI*XVAL)*NDMEC (GTERMI*XVAL)*NDTHE 
                          (GPRESS*XVAL)*NDVOL (GTOTA*XVAL)*NDINT; 
                 FIN IVAL; 
             SINON; 
                 MESS CHARES GMCANI*NDMEC GTERMI*NDTHE GPRESS*NDVOL 
                      GTOTA*NDINT; 
             FINSI; 
   
 *************************************************** 
 ** STOCKAGE DES RESULTATS DANS SUPTAB.'RESULTATS'** 
 *************************************************** 
             SI BOOL.'PASAPAS'; 
 * CAS PASAPAS 
                 SI (EGA GDIME 2); 
                     SI  BOOL.'DECOUPLAGE'; 
                         TABRES.MOTMIX.IABC = GTOTA; 
                     SINON; 
                         TABRES.IABC = GTOTA; 
                     FINSI; 
                 FINSI; 
                 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')); 
                     SI  BOOL.'DECOUPLAGE'; 
                         TABRES.MOTMIX.IABC.NUNOE = GTOTA; 
                     SINON; 
                         TABRES.IABC.NUNOE = GTOTA; 
                     FINSI; 
                 FINSI; 
                 SI BOOL.'COQ'; 
                     SI  BOOL.'DECOUPLAGE'; 
                         TABRES.MOTMIX = GTOTA; 
                     SINON; 
                         TABRES.IABC.'SUPERI' = GTOTA*V_SUPE; 
                         TABRES.IABC.'MEDIAN' = GTOTA*V_MOYE; 
                         TABRES.IABC.'INFERI' = GTOTA*V_INFE; 
                         TABRES.IABC.'GLOBAL' = GTOTA; 
                     FINSI; 
                 FINSI; 
 * CAS RESOU 
             SINON; 
                 SI (EGA GDIME 2); 
                     SI  BOOL.'DECOUPLAGE'; 
                         TABRES.MOTMIX = GTOTA; 
                     SINON; 
                         SUPTAB.'RESULTATS' = GTOTA; 
                     FINSI; 
                 FINSI; 
                 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')); 
                     SI  BOOL.'DECOUPLAGE'; 
                         TABRES.MOTMIX.NUNOE = GTOTA; 
                     SINON; 
                         TABRES.NUNOE = GTOTA; 
                     FINSI; 
                 FINSI; 
                 SI BOOL.'COQ'; 
                     SI  BOOL.'DECOUPLAGE'; 
                         TABRES.MOTMIX = GTOTA; 
                     SINON; 
                         TABRES.'SUPERI' = GTOTA*V_SUPE; 
                         TABRES.'MEDIAN' = GTOTA*V_MOYE; 
                         TABRES.'INFERI' = GTOTA*V_INFE; 
                         TABRES.'GLOBAL' = GTOTA; 
                     FINSI; 
                 FINSI; 
             FINSI; 
   
 **************************** 
 ** AJOUT AU CHPO OU CHAML ** 
 **************************** 
             SI ((&BCNOEU < NBOU) OU (EGA NBOU 1)); 
                 SI (BOOL.'XFEM' ET (EGA GDIME 3)); 
                     GCHAM1 = GCHAM1 ET (MANU 'CHML' IND0 MOCOMP GTOTA); 
                 SINON; 
                     GCHPO1 = GCHPO1 + (NOMC MOCOMP (GTOTA * IND0)); 
                 FINSI; 
             FINSI; 
   
         FIN BCNOEU; 
 *<== FIN DE BOUCLE SUR LES NOEUDS A AVANCER VIRTUELLEMENT =============| 
 *|=====================================================================| 
   
   
         SI (BOOL.'XFEM' ET (EGA GDIME 3)); 
 * EN XFEM 3D ON A LE RESULTAT UNIQUEMENT SOUS FORME DE CHAMELEM 
 * ON LE TRANSFORME DONC EN CHPO 
             EFJ = INTE (EXTR GCHAM1 'MAILLAGE') ELTETA; 
             MOD_MEC_RJ = REDU MOD_MEC_R EFJ; 
             GCHPO1 = CHAN 'CHPO' GCHAM1 MOD_MEC_RJ 'MOYE'; 
             GCHPO1 = INT_COMP ELTETA GCHPO1 SUPTAB.'FRONT_FISSURE'; 
         SINON; 
 * EN STD ON REDUIT LE CHAMP RESULTAT AU FRONT DE FISSURE 
             GCHPO1 = REDU GCHPO1 SUPTAB.'FRONT_FISSURE'; 
         FINSI; 
   
 * ON AJOUTE LES COMPOSANTES DANS L'EPAISSEUR DANS LE CAS DES COQUES 
         SI BOOL.'COQ'; 
             GCHPO1 = NOMC 'GLOB' GCHPO1; 
             GCHPO2 = NOMC 'SUPE' (GCHPO1*V_SUPE); 
             GCHPO3 = NOMC 'MEDI' (GCHPO1*V_MOYE); 
             GCHPO4 = NOMC 'INFE' (GCHPO1*V_INFE); 
             GCHPO1 = GCHPO2 ET GCHPO3 ET GCHPO4 ET GCHPO1; 
         FINSI; 
   
 ********************************************************************* 
 ** STOCKAGE DES CHAMPS RESULTATS (+ logique qu'une table a priori) ** 
 ********************************************************************* 
 *CAS PASAPAS 
         SI (BOOL.'PASAPAS'); 
             SUPTAB.'CHPO_RESULTATS'.IABC 
                     = SUPTAB.'CHPO_RESULTATS'.IABC ET GCHPO1; 
             SI (NON (VIDE GCHAM1) ); 
                 SUPTAB.'CHAM_RESULTATS'.IABC 
                     = SUPTAB.'CHAM_RESULTATS'.IABC ET GCHAM1; 
             FINSI; 
 *CAS RESOU 
         SINON; 
             SUPTAB.'CHPO_RESULTATS' = SUPTAB.'CHPO_RESULTATS' ET GCHPO1; 
             SI (NON (VIDE GCHAM1) ); 
                 SUPTAB.'CHAM_RESULTATS' = SUPTAB.'CHAM_RESULTATS' ET GCHAM1; 
             FINSI; 
         FINSI; 
   
 * ON SE PREPARE A PARTIR... 
         MENA; 
         SI (BOOL.'PASAPAS' ET BOOL.'COQ'); 
             MESS; 
         FINSI; 
         SI (BOOL.'PASAPAS' ET (NBOU '>' 1)); 
             MESS; 
         FINSI; 
         SI (BOOL.'PASAPAS' ET (NBOU EGA 1) ET (NON BOOL.'COQ')); 
             SI (EGA ((&BOUCEXT/10)*10) &BOUCEXT); 
                 'SAUT' 'LIGNE'; 
             FINSI; 
         FINSI; 
   
   
     FIN BOUCMIX; 
 * FIN DE BOUCLE SUR LES INTEGRALES A CALCULER ========================* 
   
 **************************************************** 
 ******* FIN DE BOUCLE SUR LES PAS DE CALCUL ******** 
 **************************************************** 
 FIN BOUCEXT; 
   
   
 **************************************************** 
 ** STOCKAGE DES RESULTATS DANS L OBJET EVOLUTIONS ** 
 **************************************************** 
 * en plus de ce qui existe dans SUPTAB.'RESULTATS' 
 * et dans CHPO_RESULTATS 
 SI (BOOL.'PASAPAS' ET (NON BOOL.'PERSO1')); 
 * TITRE DES EVOLUTIONS 
     SI BOOL.'DECOUPLAGE'; 
         CHATIT = CHAI 'F.I.C. Ki'; 
     SINON; 
         CHAINT = MOBJ; 
         SI BOOL.'J_DYNA'; 
             CHAINT = CHAI 'J DYNAMIQUE'; 
         FINSI; 
         CHATIT = CHAI 'INTEGRALE' ' ' CHAINT; 
     FINSI; 
     CHATIT = CHAI CHATIT ' EN FONCTION DU TEMPS'; 
     TITR CHATIT; 
     PINST = PROG; 
     TINST = SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'; 
     LCHPO1 = VIDE 'LISTCHPO'; 
     REPE IINST (DIME TINST); 
         PINST = PINST ET (PROG TINST.(&IINST - 1)); 
         CHPO1 = SUPTAB.'CHPO_RESULTATS'.(&IINST - 1); 
         LCHPO1 = LCHPO1 ET (SUIT CHPO1); 
     FIN IINST; 
     MCOMP = EXTR CHPO1 'COMP'; 
     SI (EGA (DIME MCOMP) 1); 
 * MCOMP EST UN LISTMOT, ON LE TRANSFORME EN MOT S'IL Y EN A QU'UN 
         MCOMP = EXTR MCOMP 1; 
     FINSI; 
     SI ((EGA GDIME 2) OU BOOL.'COQ'); 
 * EN 2D ET 3D COQUE L'INDICE EVOLUTION_RESULTATS EST UNE EVOLUTION 
         POIN1 = (FF1 ELEM 1) POIN 1; 
         EVO1 = EVOL 'TEMP' LCHPO1 PINST MCOMP POIN1; 
         SUPTAB.'EVOLUTION_RESULTATS' = EVO1; 
     SINON; 
 * SINON C'EST UNE TABLE INDICEE PAR LES POINTS DU FRONT 
         REPE INOEU (NBEL FF1); 
             POIN1 = (FF1 ELEM &INOEU) POIN 1; 
             EVO1 = EVOL 'TEMP' LCHPO1 PINST MCOMP POIN1; 
             SUPTAB.'EVOLUTION_RESULTATS'.POIN1 = EVO1; 
         FIN INOEU; 
 * ET IL Y A LE RESULTAT GLOBAL 
         PG = PROG ; 
         REPE IINST (DIME TINST) ; 
             G0 = SUPTAB.'RESULTATS'.(&IINST - 1).'GLOBAL' ; 
             PG = PG ET (PROG G0) ; 
         FIN IINST ; 
         EVO1 = EVOL 'MANU' 'TEMPS' PINST MCOMP PG ; 
         SUPTAB.'EVOLUTION_RESULTATS'.'GLOBAL' = EVO1 ; 
     FINSI; 
 FINSI; 
   
   
 ******************************************************** 
 **** STOCKAGE POUR UNE EVENTUELLE REPRISE DE CALCUL **** 
 ******************************************************** 
 SI BOOL.'PASAPAS'; 
     SUPTAB.'OBJ1' = MOT SUPTAB.'OBJECTIF'; 
     SUPTAB.'IABC' = IABC; 
     SUPTAB.'MAT_INST' = MAT_INST; 
     SUPTAB.'END1' = ENERM; 
     SI (((DIME MODPLA) '>' 0) ET BOOL.'THER'); 
         SUPTAB.'ENV1' = WVMIS; 
     FINSI; 
     SI (EGA ITYPEF 2); 
         SUPTAB.'VDI1' = VDI1; 
     FINSI; 
 FINSI; 
   
 ******************************************************** 
 ************* OBJETS POUR REPRISE ET XFEM ************** 
 ******************************************************** 
 SI (EXIS SUPTAB 'COUCHE'); 
     SUPTAB.'COU1' = SUPTAB.'COUCHE'; 
 FINSI; 
   
 *bp: soyons coherent... CHAMP_THETA est deja renseigne 
 SI (EXIS SUPTAB 'CHAMP_THETA'); 
     SUPTAB.'CHAMP_THET1' = SUPTAB.'CHAMP_THETA'; 
 FINSI; 
 *OTER SUPTAB 'CHAMP_THETA'; 
 OTER SUPTAB 'GRTHETA'; 
 OTER SUPTAB 'DIVTHETA'; 
   
 FINP; 
 G_cal = GTAB . 'RESULTATS'  ; 
 * formule d'Irwin en DP 
 *K_G = (you * G_cal/(1 - (v**2)))**0.5; 
 * formule d'Irwin en CP 
 K_G = (you * G_cal)**0.5; 
   
 mess 'K1 calcule par Interpolation :'  K1INT; 
 mess 'K2 calcule par Interpolation :'  K2INT; 
 mess '---K calcule par G et Irwin :'  K_G ; 
   
   
   
 opti donn 5; 
 fin; 
